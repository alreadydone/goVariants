{"version":3,"sources":["src/node_modules/browser-pack/_prelude.js","src/node_modules/go-variants-engine/node_modules/lodash/_DataView.js","src/node_modules/go-variants-engine/node_modules/lodash/_Hash.js","src/node_modules/go-variants-engine/node_modules/lodash/_ListCache.js","src/node_modules/go-variants-engine/node_modules/lodash/_Map.js","src/node_modules/go-variants-engine/node_modules/lodash/_MapCache.js","src/node_modules/go-variants-engine/node_modules/lodash/_Promise.js","src/node_modules/go-variants-engine/node_modules/lodash/_Set.js","src/node_modules/go-variants-engine/node_modules/lodash/_SetCache.js","src/node_modules/go-variants-engine/node_modules/lodash/_Stack.js","src/node_modules/go-variants-engine/node_modules/lodash/_Symbol.js","src/node_modules/go-variants-engine/node_modules/lodash/_Uint8Array.js","src/node_modules/go-variants-engine/node_modules/lodash/_WeakMap.js","src/node_modules/go-variants-engine/node_modules/lodash/_addMapEntry.js","src/node_modules/go-variants-engine/node_modules/lodash/_addSetEntry.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayEach.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayFilter.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayLikeKeys.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayMap.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayPush.js","src/node_modules/go-variants-engine/node_modules/lodash/_arrayReduce.js","src/node_modules/go-variants-engine/node_modules/lodash/_arraySome.js","src/node_modules/go-variants-engine/node_modules/lodash/_assignValue.js","src/node_modules/go-variants-engine/node_modules/lodash/_assocIndexOf.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseAssign.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseAssignIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseAssignValue.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseClone.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseCreate.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseFindIndex.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseGet.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseGetAllKeys.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseGetTag.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseHasIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsArguments.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsEqual.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsEqualDeep.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsMatch.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsNative.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIsTypedArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseIteratee.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseKeys.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseKeysIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseMatches.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseMatchesProperty.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseProperty.js","src/node_modules/go-variants-engine/node_modules/lodash/_basePropertyDeep.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseTimes.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseToString.js","src/node_modules/go-variants-engine/node_modules/lodash/_baseUnary.js","src/node_modules/go-variants-engine/node_modules/lodash/_cacheHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_castPath.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneArrayBuffer.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneBuffer.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneDataView.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneMap.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneRegExp.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneSet.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneSymbol.js","src/node_modules/go-variants-engine/node_modules/lodash/_cloneTypedArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_copyArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_copyObject.js","src/node_modules/go-variants-engine/node_modules/lodash/_copySymbols.js","src/node_modules/go-variants-engine/node_modules/lodash/_copySymbolsIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_coreJsData.js","src/node_modules/go-variants-engine/node_modules/lodash/_defineProperty.js","src/node_modules/go-variants-engine/node_modules/lodash/_equalArrays.js","src/node_modules/go-variants-engine/node_modules/lodash/_equalByTag.js","src/node_modules/go-variants-engine/node_modules/lodash/_equalObjects.js","src/node_modules/go-variants-engine/node_modules/lodash/_freeGlobal.js","src/node_modules/go-variants-engine/node_modules/lodash/_getAllKeys.js","src/node_modules/go-variants-engine/node_modules/lodash/_getAllKeysIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_getMapData.js","src/node_modules/go-variants-engine/node_modules/lodash/_getMatchData.js","src/node_modules/go-variants-engine/node_modules/lodash/_getNative.js","src/node_modules/go-variants-engine/node_modules/lodash/_getPrototype.js","src/node_modules/go-variants-engine/node_modules/lodash/_getRawTag.js","src/node_modules/go-variants-engine/node_modules/lodash/_getSymbols.js","src/node_modules/go-variants-engine/node_modules/lodash/_getSymbolsIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_getTag.js","src/node_modules/go-variants-engine/node_modules/lodash/_getValue.js","src/node_modules/go-variants-engine/node_modules/lodash/_hasPath.js","src/node_modules/go-variants-engine/node_modules/lodash/_hashClear.js","src/node_modules/go-variants-engine/node_modules/lodash/_hashDelete.js","src/node_modules/go-variants-engine/node_modules/lodash/_hashGet.js","src/node_modules/go-variants-engine/node_modules/lodash/_hashHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_hashSet.js","src/node_modules/go-variants-engine/node_modules/lodash/_initCloneArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_initCloneByTag.js","src/node_modules/go-variants-engine/node_modules/lodash/_initCloneObject.js","src/node_modules/go-variants-engine/node_modules/lodash/_isIndex.js","src/node_modules/go-variants-engine/node_modules/lodash/_isKey.js","src/node_modules/go-variants-engine/node_modules/lodash/_isKeyable.js","src/node_modules/go-variants-engine/node_modules/lodash/_isMasked.js","src/node_modules/go-variants-engine/node_modules/lodash/_isPrototype.js","src/node_modules/go-variants-engine/node_modules/lodash/_isStrictComparable.js","src/node_modules/go-variants-engine/node_modules/lodash/_listCacheClear.js","src/node_modules/go-variants-engine/node_modules/lodash/_listCacheDelete.js","src/node_modules/go-variants-engine/node_modules/lodash/_listCacheGet.js","src/node_modules/go-variants-engine/node_modules/lodash/_listCacheHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_listCacheSet.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapCacheClear.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapCacheDelete.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapCacheGet.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapCacheHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapCacheSet.js","src/node_modules/go-variants-engine/node_modules/lodash/_mapToArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_matchesStrictComparable.js","src/node_modules/go-variants-engine/node_modules/lodash/_memoizeCapped.js","src/node_modules/go-variants-engine/node_modules/lodash/_nativeCreate.js","src/node_modules/go-variants-engine/node_modules/lodash/_nativeKeys.js","src/node_modules/go-variants-engine/node_modules/lodash/_nativeKeysIn.js","src/node_modules/go-variants-engine/node_modules/lodash/_nodeUtil.js","src/node_modules/go-variants-engine/node_modules/lodash/_objectToString.js","src/node_modules/go-variants-engine/node_modules/lodash/_overArg.js","src/node_modules/go-variants-engine/node_modules/lodash/_root.js","src/node_modules/go-variants-engine/node_modules/lodash/_setCacheAdd.js","src/node_modules/go-variants-engine/node_modules/lodash/_setCacheHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_setToArray.js","src/node_modules/go-variants-engine/node_modules/lodash/_stackClear.js","src/node_modules/go-variants-engine/node_modules/lodash/_stackDelete.js","src/node_modules/go-variants-engine/node_modules/lodash/_stackGet.js","src/node_modules/go-variants-engine/node_modules/lodash/_stackHas.js","src/node_modules/go-variants-engine/node_modules/lodash/_stackSet.js","src/node_modules/go-variants-engine/node_modules/lodash/_stringToPath.js","src/node_modules/go-variants-engine/node_modules/lodash/_toKey.js","src/node_modules/go-variants-engine/node_modules/lodash/_toSource.js","src/node_modules/go-variants-engine/node_modules/lodash/clone.js","src/node_modules/go-variants-engine/node_modules/lodash/eq.js","src/node_modules/go-variants-engine/node_modules/lodash/findIndex.js","src/node_modules/go-variants-engine/node_modules/lodash/get.js","src/node_modules/go-variants-engine/node_modules/lodash/hasIn.js","src/node_modules/go-variants-engine/node_modules/lodash/identity.js","src/node_modules/go-variants-engine/node_modules/lodash/isArguments.js","src/node_modules/go-variants-engine/node_modules/lodash/isArray.js","src/node_modules/go-variants-engine/node_modules/lodash/isArrayLike.js","src/node_modules/go-variants-engine/node_modules/lodash/isBuffer.js","src/node_modules/go-variants-engine/node_modules/lodash/isFunction.js","src/node_modules/go-variants-engine/node_modules/lodash/isLength.js","src/node_modules/go-variants-engine/node_modules/lodash/isObject.js","src/node_modules/go-variants-engine/node_modules/lodash/isObjectLike.js","src/node_modules/go-variants-engine/node_modules/lodash/isSymbol.js","src/node_modules/go-variants-engine/node_modules/lodash/isTypedArray.js","src/node_modules/go-variants-engine/node_modules/lodash/keys.js","src/node_modules/go-variants-engine/node_modules/lodash/keysIn.js","src/node_modules/go-variants-engine/node_modules/lodash/memoize.js","src/node_modules/go-variants-engine/node_modules/lodash/property.js","src/node_modules/go-variants-engine/node_modules/lodash/stubArray.js","src/node_modules/go-variants-engine/node_modules/lodash/stubFalse.js","src/node_modules/go-variants-engine/node_modules/lodash/toFinite.js","src/node_modules/go-variants-engine/node_modules/lodash/toInteger.js","src/node_modules/go-variants-engine/node_modules/lodash/toNumber.js","src/node_modules/go-variants-engine/node_modules/lodash/toString.js","src/node_modules/go-variants-engine/src/engine.js","src/node_modules/lodash/_arrayIncludes.js","src/node_modules/lodash/_arrayIncludesWith.js","src/node_modules/lodash/_baseFlatten.js","src/node_modules/lodash/_baseIndexOf.js","src/node_modules/lodash/_baseIsNaN.js","src/node_modules/lodash/_baseUniq.js","src/node_modules/lodash/_createSet.js","src/node_modules/lodash/_freeGlobal.js","src/node_modules/lodash/_isFlattenable.js","src/node_modules/lodash/_strictIndexOf.js","src/node_modules/lodash/flatten.js","src/node_modules/lodash/noop.js","src/node_modules/lodash/uniqBy.js","src/node_modules/smartgame/index.js","src/node_modules/smartgamer/index.js","src/src/transform.js","src/src/transformer.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzFA;AACA;AACA;AACA;AACA;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnVA;;;;AAKA,OAAO,OAAP,GAAiB,UAAC,UAAD,EAAa,OAAb,EAAyB;AACxC;;AACA,MAAI,cAAc,QAAQ,eAAR,CAAlB;AAAA,MACE,YAAY,QAAQ,WAAR,CADd;AAAA,MAEE,aAAa,QAAQ,YAAR,CAFf;AAAA,MAGE,MAAM,QAAQ,oBAA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","file":"transform.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\nmodule.exports = addMapEntry;\n","/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\nmodule.exports = addSetEntry;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isObject = require('./isObject'),\n    keys = require('./keys');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n","var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n","var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n","var addMapEntry = require('./_addMapEntry'),\n    arrayReduce = require('./_arrayReduce'),\n    mapToArray = require('./_mapToArray');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1;\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\nmodule.exports = cloneMap;\n","/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n","var addSetEntry = require('./_addSetEntry'),\n    arrayReduce = require('./_arrayReduce'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1;\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\nmodule.exports = cloneSet;\n","var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n","var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneMap = require('./_cloneMap'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSet = require('./_cloneSet'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n","var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var baseClone = require('./_baseClone');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = clone;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","/* globals module: false, require: false */\r\nmodule.exports = function (options) {\r\n\t'use strict';\r\n\tlet _fi = require('lodash/findIndex')\r\n\t\t// , _iseq = require('lodash/isEqual')\r\n\t\t, _clone = require('lodash/clone')\r\n\t\t//utilities\r\n\t\t// const\r\n\r\n\t\t, _iseq = (x, y) => {\r\n\r\n\t\t\tif (!Array.isArray(x) || !Array.isArray(y)) {\r\n\t\t\t\treturn x == y// eslint-disable-line eqeqeq\r\n\t\t\t\t// return x === y\r\n\t\t\t}\r\n\t\t\tif (x.length !== y.length) return false\r\n\t\t\tfor (let index = 0; index < x.length; index++) {\r\n\t\t\t\tif (!_iseq(x[index], y[index])) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true\r\n\r\n\t\t}\r\n\t\t, myIndexOf = (a, b) => {\r\n\t\t\treturn _fi(a, function (x) { return _iseq(x, b) });\r\n\t\t}\r\n\t// this version, without the _fi dependency, doesn't work!todo\r\n\t//  , myIndexOf = (array, item) => {\r\n\t// \t\tfor (let index = 0; index < array.length; index++) {\r\n\t// \t\t\tif (_iseq(array[index], item)) {\r\n\t// \t\t\t\treturn index;\r\n\r\n\t// \t\t\t}\r\n\t// \t\t\treturn -1;\r\n\t// \t\t}\r\n\r\n\t// \t}\r\n\r\n\t// \t, _clone = require('lodash/clone')\r\n\r\n\r\n\toptions = options || {}\r\n\t// boardMode = options.boardMode || 't'/*t:toroid; c:classic …*/\r\n\t// , boardDimensions = options.boardDimensions || [11, 11]/*move later*/\r\n\t// , rules = options.rules || {\r\n\t// suicide: true,\r\n\t// superko: false\r\n\t// }\r\n\tlet $ = {}\r\n\t////problem with the object spread operator and the build so using Object.assign instead.\r\n\t// $.rules = {\r\n\t// \t\tsuicide: true,\r\n\t// \t\t// superko: false /*⇒todo: enforce when true?*/,\r\n\t// \t\tkomi: 7.5,\r\n\t// \t\t... options.rules\r\n\t// \t}\r\n\t$.rules = Object.assign({}, {\r\n\t\tsuicide: true,\r\n\t\t// superko: false /*⇒todo: enforce when true?*/,\r\n\t\tkomi: 7.5,\r\n\t}, options.rules)\r\n\r\n\t// $.moves = options.moves || []\r\n\t$.options = options\r\n\toptions.boardDimensions = options.boardDimensions || [11, 11]\r\n\toptions.boardMode = options.boardMode || 't'/*t:toroid; c:classic …*/\r\n\t$.board = {}\r\n\t$.board.blackStones = options.blackStones || []\r\n\t$.board.whiteStones = options.whiteStones || []\r\n\r\n\t$.board.nextPlayer = options.nextPlayer || \"b\"\r\n\t$.board.captured = options.captured || [0, 0]\r\n\r\n\t$.exportData = function () {\r\n\t\treturn {\r\n\t\t\tblackStones: $.board.blackStones.map(_clone),\r\n\r\n\t\t\twhiteStones: $.board.whiteStones.map(_clone),\r\n\t\t\tcaptured: _clone($.board.captured),\r\n\t\t\tnextPlayer: $.board.nextPlayer\r\n\t\t}\r\n\t}\r\n\r\n\t$.loadData = function (data) {\r\n\t\t$.board.blackStones = data.blackStones\r\n\t\t$.board.whiteStones = data.whiteStones\r\n\t\t$.board.captured = data.captured\r\n\t\t$.board.nextPlayer = data.nextPlayer\r\n\t}\r\n\r\n\t//toroid\r\n\tif (options.boardMode === 't') $.board.getNeighbours =\r\n\t\tfunction (point) {\r\n\t\t\tlet result = []\r\n\t\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\t\tlet newPoint\r\n\t\t\t\tswitch (i) {\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\tnewPoint = [point[0] + 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tnewPoint = [point[0] - 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] + 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] - 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tresult.push([(newPoint[0] + options.boardDimensions[0]) % options.boardDimensions[0], (newPoint[1] + options.boardDimensions[1]) % options.boardDimensions[1]])\r\n\t\t\t}\r\n\t\t\treturn result\r\n\t\t}\r\n\tif (options.boardMode === 'c') $.board.getNeighbours =\r\n\t\tfunction (point) {\r\n\t\t\tlet result = []\r\n\t\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\t\tlet newPoint\r\n\t\t\t\tswitch (i) {\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\tnewPoint = [point[0] + 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tnewPoint = [point[0] - 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] + 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] - 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tif (newPoint[0] >= 0 && newPoint[0] < options.boardDimensions[0]\r\n\t\t\t\t\t&& newPoint[1] >= 0 && newPoint[1] < options.boardDimensions[1]\r\n\t\t\t\t)\r\n\t\t\t\t\tresult.push(newPoint)\r\n\t\t\t}\r\n\t\t\treturn result\r\n\t\t}\r\n\t//todo: klein, projective plane, …\r\n\r\n\t$.board.isEmpty = function (point) {\r\n\t\treturn myIndexOf($.board.blackStones, point) < 0\r\n\t\t\t&& myIndexOf($.board.whiteStones, point) < 0\r\n\t}\r\n\t$.board.getColour = function (point) {\r\n\t\tif (myIndexOf($.board.blackStones, point) >= 0) return 'b'\r\n\t\tif (myIndexOf($.board.whiteStones, point) >= 0) return 'w'\r\n\t\treturn 'e'\r\n\t}\r\n\t/**\r\n\t * Determines if a point is part of a chain with a liberty; if there are no liberties then it returns the chain of stones of the same colour that are connected to `startPoint`. Also used for counting to return connected components of same colour (black, white or empty).\r\n\t * @param {*} startPoint \r\n\t * @param {string|null} chainColour indicates the colour of the starting point.\r\n\t * @param {*} [stopColour='e'] stop working if the chain meets this colour\r\n\t * @param {Function} [getColour=$.board.getColour] Function used to determine the colour of a point.\r\n\t * @returns {bool|array} Returns `true` if the the component meets `stopColour`, and an array containing connected component of points linked to `startPoint` otherwise. \r\n\t */\t\r\n\tfunction chainHasLiberty (startPoint, chainColour, stopColour, getColour) {\r\n\t\tif (stopColour === undefined)\r\n\t\t\tstopColour = 'e'//by default, stop getting the chain when there is a liberty.\r\n\t\tif (getColour === undefined)\r\n\t\t\tgetColour = $.board.getColour//by default, use the usual board colour function\r\n\r\n\t\tif (chainColour === null)\r\n\t\t\tchainColour = getColour(startPoint)\r\n\t\tlet\r\n\t\t\tchain = [startPoint]\r\n\t\t\t, toExplore = []\r\n\t\t\t, point = startPoint //assumed to be of colour chainColour\r\n\r\n\t\twhile (point !== undefined) {\r\n\r\n\t\t\tlet neighbours = $.board.getNeighbours(point)\r\n\t\t\tfor (let i = 0; i < neighbours.length; i++) {\r\n\t\t\t\tlet newPoint = neighbours[i],\r\n\t\t\t\t\tnewColour = getColour(newPoint)\r\n\t\t\t\tif (newColour === stopColour) return true;\r\n\t\t\t\tif (newColour === chainColour) {\r\n\t\t\t\t\tif (myIndexOf(chain, newPoint) < 0) {\r\n\t\t\t\t\t\tchain.push(newPoint)\r\n\t\t\t\t\t\t// if (myIndexOf(toExplore, newPoint) < 0)\r\n\t\t\t\t\t\ttoExplore.push(newPoint)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tpoint = toExplore.pop()\r\n\t\t}\r\n\r\n\t\treturn chain;\r\n\t}\r\n\r\n\t$.board.chainHasLiberty = chainHasLiberty \r\n\r\n\t$.board.score = function (deadStones) {\r\n\t\t/*\r\n\t\tgo through the whole board \r\n\t\t*/\r\n\t\tif (deadStones === undefined) {\r\n\t\t\tdeadStones = []\r\n\t\t}\r\n\r\n\t\tlet result = {\r\n\t\t\tblackEmpty: []\r\n\t\t\t, whiteEmpty: []\r\n\t\t\t, dame: []\r\n\t\t\t, blackAlive: []\r\n\t\t\t, whiteAlive: []\r\n\t\t\t, blackDead: []\r\n\t\t\t, whiteDead: []\r\n\t\t\t, totalBlackCaptured: $.board.captured[0] //nb B stones removed by W during the game\r\n\t\t\t, totalWhiteCaptured: $.board.captured[1] //nb W stones removed by B during the game\r\n\t\t\t//todo:could replace by an class. data stored in a big array of pairs [point, status]\r\n\t\t}\r\n\r\n\t\tfor (let index = 0; index < deadStones.length; index++) {\r\n\t\t\tconst deadStone = deadStones[index];\r\n\t\t\tlet deadColour = $.board.getColour(deadStone)\r\n\t\t\tif (deadColour === 'e') throw new Error('invalid marked dead stone')\r\n\t\t\tlet\r\n\t\t\t\tdeadToFill = deadColour === 'b' ? result.blackDead : result.whiteDead\r\n\t\t\t\t, emptyToFill = deadColour === 'b' ? result.whiteEmpty : result.blackEmpty\r\n\t\t\t\t, aliveToFill = deadColour === 'b' ? result.whiteAlive : result.blackAlive\r\n\t\t\t\t, processPoint = (point, colour) => {\r\n\t\t\t\t\tif (colour === deadColour && myIndexOf(deadToFill, point) < 0) {\r\n\t\t\t\t\t\tdeadToFill.push(point)\r\n\t\t\t\t\t\temptyToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((colour === deadColour || colour === 'e') && myIndexOf(emptyToFill, point) < 0) {\r\n\t\t\t\t\t\temptyToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (colour !== deadColour && colour !== 'e' && myIndexOf(aliveToFill, point) < 0) {\r\n\t\t\t\t\t\taliveToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t, getColourForDeadComponent = (point) => {\r\n\t\t\t\t\tlet colour = $.board.getColour(point)\r\n\t\t\t\t\tprocessPoint(point, colour)\r\n\t\t\t\t\treturn colour === deadColour ? 'e' : colour\r\n\t\t\t\t}\r\n\t\t\tprocessPoint(deadStone, deadColour)\r\n\t\t\t$.board.chainHasLiberty(deadStone, 'e', '', getColourForDeadComponent)\r\n\t\t}\r\n\r\n\t\tfor (let i = 0,exitLoop = false; i < options.boardDimensions[0]; i++) {\r\n\t\t\tif (exitLoop) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tfor (let j = 0; j < options.boardDimensions[1]; j++) {\r\n\t\t\t\tif (result.blackEmpty.length\r\n\t\t\t\t\t+ result.whiteEmpty.length\r\n\t\t\t\t\t+ result.dame.length\r\n\t\t\t\t\t+ result.blackAlive.length\r\n\t\t\t\t\t+ result.whiteAlive.length\r\n\t\t\t\t\t// + result.blackDead.length\r\n\t\t\t\t\t// + result.whiteDead.length\r\n\t\t\t\t\t=== options.boardDimensions[0] * options.boardDimensions[1]\r\n\t\t\t\t) {\r\n\t\t\t\t\texitLoop = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tconst point = [i, j], colour = $.board.getColour(point)\r\n\r\n\t\t\t\tif (colour === 'b'\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (myIndexOf(result.blackAlive, point) < 0\r\n\t\t\t\t\t\t&& myIndexOf(result.blackDead, point) < 0) {\r\n\t\t\t\t\t\tresult.blackAlive.push(point)\r\n\t\t\t\t\t} else continue\r\n\t\t\t\t}\r\n\t\t\t\tif (colour === 'w') {\r\n\t\t\t\t\tif (myIndexOf(result.whiteAlive, point) < 0\r\n\t\t\t\t\t\t&& myIndexOf(result.whiteDead, point) < 0) {\r\n\t\t\t\t\t\tresult.whiteAlive.push(point)\r\n\t\t\t\t\t} else continue\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (colour === 'e') {\r\n\t\t\t\t\tif (myIndexOf(result.blackEmpty, point) >= 0\r\n\t\t\t\t\t\t|| myIndexOf(result.whiteEmpty, point) >= 0\r\n\t\t\t\t\t\t|| myIndexOf(result.dame, point) >= 0) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet\r\n\t\t\t\t\t\tmeetsBlack = false\r\n\t\t\t\t\t\t, meetsWhite = false\r\n\t\t\t\t\t\t, isBlackTerritory = false\r\n\t\t\t\t\t\t, isWhiteTerritory = false\r\n\t\t\t\t\t\t, getColourForScoring = (point) => {\r\n\r\n\t\t\t\t\t\t\tlet colour = $.board.getColour(point)\r\n\t\t\t\t\t\t\tswitch (colour) {\r\n\t\t\t\t\t\t\t\tcase 'b':\r\n\t\t\t\t\t\t\t\t\tif (myIndexOf(result.blackDead, point) >= 0) {\r\n\t\t\t\t\t\t\t\t\t\tcolour = 'e'\r\n\t\t\t\t\t\t\t\t\t\tisWhiteTerritory = true\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tmeetsBlack = true\r\n\t\t\t\t\t\t\t\t\t\tif (myIndexOf(result.blackAlive, point) < 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tresult.blackAlive.push(point)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase 'w':\r\n\t\t\t\t\t\t\t\t\tif (myIndexOf(result.whiteDead, point) >= 0) {\r\n\t\t\t\t\t\t\t\t\t\tcolour = 'e'\r\n\t\t\t\t\t\t\t\t\t\tisBlackTerritory = true\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tmeetsWhite = true\r\n\t\t\t\t\t\t\t\t\t\tif (myIndexOf(result.whiteAlive, point) < 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tresult.whiteAlive.push(point)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tdefault://nothing needed for 'e'\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn colour\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tlet emptyComponent = $.board.chainHasLiberty(point, 'e', '', getColourForScoring)\r\n\t\t\t\t\tif (!meetsBlack && !meetsWhite) {\r\n\t\t\t\t\t\tthrow new Error('counting an empty board!')\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isBlackTerritory && isWhiteTerritory) {\r\n\t\t\t\t\t\tthrow new Error('too many stones marked as dead')\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//could store the different empty components: V2 \r\n\t\t\t\t\tif (meetsBlack && meetsWhite) {\r\n\t\t\t\t\t\tresult.dame = result.dame.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (meetsBlack) {\r\n\t\t\t\t\t\tresult.blackEmpty = result.blackEmpty.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (meetsWhite) {\r\n\t\t\t\t\t\tresult.whiteEmpty = result.whiteEmpty.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//totals\r\n\t\tresult.totalBlackDead = result.blackDead.length\r\n\t\tresult.totalWhiteDead = result.whiteDead.length\r\n\t\tresult.totalBlackTerritory = result.blackEmpty.length\r\n\t\tresult.totalWhiteTerritory = result.whiteEmpty.length\r\n\r\n\r\n\t\t//todo: implement other rulesets. For now, just do territory + prisoners (Japanese style counting)\r\n\t\tresult.blackScore =\r\n\t\t\tresult.totalWhiteDead\r\n\t\t\t+ result.totalWhiteCaptured\r\n\t\t\t+ result.totalBlackTerritory\r\n\t\tresult.whiteScore =\r\n\t\t\tresult.totalBlackDead\r\n\t\t\t+ result.totalBlackCaptured\r\n\t\t\t+ result.totalWhiteTerritory\r\n\t\t\t+ $.rules.komi\r\n\t\tlet r = result.blackScore - result.whiteScore\r\n\t\tif (r === 0) result.RE = '0'\r\n\t\telse if (r > 0) result.RE = 'B+' + r\r\n\t\telse result.RE = 'W+' + (-r)\r\n\t\treturn result\r\n\t}\r\n\r\n\t$.board.empty = function () {\r\n\t\t$.board.whiteStones = []\r\n\t\t$.board.blackStones = []\r\n\t\t$.board.captured = [0, 0]\r\n\r\n\t}\r\n\r\n\t$.removeChain = function (chain, colour) {\r\n\t\tlet toRemoveFrom = colour === 'w' ? $.board.whiteStones : $.board.blackStones\r\n\t\tfor (let j = 0; j < chain.length; j++) {\r\n\t\t\tlet index = myIndexOf(toRemoveFrom, chain[j])\r\n\t\t\ttoRemoveFrom.splice(index, 1)\r\n\t\t\tif (colour === 'w') $.board.captured[1] = $.board.captured[1] + 1\r\n\t\t\telse $.board.captured[0] = $.board.captured[0] + 1\r\n\t\t}\r\n\t}\r\n\t$.play = function (playerColour, point) {\r\n\r\n\r\n\r\n\t\t// let result = \"ok\"\r\n\t\tif (!$.board.isEmpty(point))\r\n\t\t\tthrow new Error('point is not empty')\r\n\t\t// console.log('point is not empty' + point)\r\n\r\n\t\tif (playerColour === 'b') $.board.blackStones.push(point)\r\n\t\telse $.board.whiteStones.push(point)\r\n\r\n\t\tlet neighbours = $.board.getNeighbours(point)\r\n\t\t\t, removed = []//chains removed\r\n\r\n\t\tfor (let i = 0; i < neighbours.length; i++) {\r\n\t\t\tlet neighbour = neighbours[i], colour = $.board.getColour(neighbour)\r\n\t\t\tif (colour === playerColour || colour === 'e') continue\r\n\t\t\tlet oppColour = $.getOppositeColour(playerColour),\r\n\t\t\t\tr = $.board.chainHasLiberty(neighbour, oppColour)\r\n\t\t\tif (r === true) continue\r\n\t\t\t////remove - no liberties\r\n\t\t\tremoved[removed.length] = r\r\n\r\n\t\t\t$.removeChain(r, oppColour)\r\n\r\n\t\t\t// let chainToRemove = r[1],\r\n\t\t\t// toRemoveFrom = playerColour === 'b' ? $.board.whiteStones : $.board.blackStones\r\n\t\t\t// for (let j = 0; j<chainToRemove.length; j++)\r\n\t\t\t// {\r\n\t\t\t// let index = myIndexOf(toRemoveFrom,chainToRemove[j])\r\n\t\t\t// toRemoveFrom.splice(index, 1)\r\n\t\t\t// if (playerColour === 'b') $.board.captured[1] = $.board.captured[1] + 1\r\n\t\t\t// else $.board.captured[0] = $.board.captured[0] + 1\r\n\t\t\t// }\r\n\t\t\t// removed = true\r\n\t\t}\r\n\t\tlet suicide = false\r\n\t\tif (removed.length === 0) {\r\n\t\t\tlet s = $.board.chainHasLiberty(point, playerColour)\r\n\t\t\tif (s !== true) {\r\n\t\t\t\tif ($.rules.suicide) {\r\n\t\t\t\t\t$.removeChain(s, playerColour)\r\n\t\t\t\t\tsuicide = s\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrow new Error('suicide')//isn’t allowed\r\n\t\t\t\t\t//todo: remove point from whiteStones or blackStones\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t\tstoring the situation in memory - would be useful when implementing going back a move, superko, …\r\n\t\t\tnot needed for now\r\n\t\t*/\r\n\t\t//$.moves.push([playerColour,point,_.clone($.board.whiteStones),_.clone($.board.blackStones)])\r\n\t\t// $.moves.push([playerColour,point])\r\n\r\n\t\t// getNeighbours[i] = [getNeighbours[i], $.board.getColour[getNeighbours[i]]\r\n\t\t// //…\r\n\r\n\r\n\t\treturn { removed, suicide }\r\n\t}\r\n\t$.getOppositeColour = function (colour) {\r\n\t\tswitch (colour) {\r\n\t\t\tcase 'b':\r\n\t\t\t\treturn 'w'\r\n\t\t\tcase 'w':\r\n\t\t\t\treturn 'b'\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\treturn $\r\n\r\n}","var baseIndexOf = require('./_baseIndexOf');\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n","/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIsNaN = require('./_baseIsNaN'),\n    strictIndexOf = require('./_strictIndexOf');\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n","/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    cacheHas = require('./_cacheHas'),\n    createSet = require('./_createSet'),\n    setToArray = require('./_setToArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n","var Set = require('./_Set'),\n    noop = require('./noop'),\n    setToArray = require('./_setToArray');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n","var baseFlatten = require('./_baseFlatten');\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var baseIteratee = require('./_baseIteratee'),\n    baseUniq = require('./_baseUniq');\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nmodule.exports = uniqBy;\n","/**\n * Convert SGF files to a JS object\n * @param {string} sgf A valid SGF file.\n * @see http://www.red-bean.com/sgf/sgf4.html\n * @return {object} The SGF file represented as a JS object\n */\nexports.parse = function (sgf) {\n\t'use strict';\n\n\tvar parse;\n\tvar parser;\n\tvar collection = {};\n\n\t// tracks the current sequence\n\tvar sequence;\n\n\t// tracks the current node\n\tvar node;\n\n\t// tracks the last PropIdent\n\tvar lastPropIdent;\n\n\t// A map of functions to parse the different components of an SGF file\n\tparser = {\n\n\t\tbeginSequence: function (sgf) {\n\t\t\tvar key = 'sequences';\n\n\t\t\t// Top-level sequences are gameTrees\n\t\t\tif (!sequence) {\n\t\t\t\tsequence = collection;\n\t\t\t\tkey = 'gameTrees';\n\t\t\t}\n\n\t\t\tif (sequence.gameTrees) {\n\t\t\t\tkey = 'gameTrees';\n\t\t\t}\n\n\t\t\tvar newSequence = {\n\t\t\t\tparent: sequence\n\t\t\t};\n\n\t\t\tsequence[key] = sequence[key] || [];\n\t\t\tsequence[key].push(newSequence);\n\t\t\tsequence = newSequence;\n\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tendSequence: function (sgf) {\n\t\t\tif (sequence.parent) {\n\t\t\t\tsequence = sequence.parent;\n\t\t\t} else {\n\t\t\t\tsequence = null;\n\t\t\t}\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tnode: function (sgf) {\n\t\t\tnode = {};\n\t\t\tsequence.nodes = sequence.nodes || [];\n\t\t\tsequence.nodes.push(node);\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tproperty: function (sgf) {\n\t\t\tvar propValue;\n\n\t\t\t// Search for the first unescaped ]\n\t\t\tvar firstPropEnd = sgf.match(/([^\\\\\\]]|\\\\(.|\\n|\\r))*\\]/);\n\n\t\t\tif (!firstPropEnd.length) {\n\t\t\t\tthrow new Error('malformed sgf');\n\t\t\t}\n\n\t\t\tfirstPropEnd = firstPropEnd[0].length;\n\n\t\t\tvar property = sgf.substring(0, firstPropEnd);\n\t\t\tvar propValueBegin = property.indexOf('[');\n\t\t\tvar propIdent = property.substring(0, propValueBegin);\n\n\t\t\t// Point lists don't declare a PropIdent for each PropValue\n\t\t\t// Instead, they should use the last declared property\n\t\t\t// See: http://www.red-bean.com/sgf/sgf4.html#move/pos\n\t\t\tif (!propIdent) {\n\t\t\t\tpropIdent = lastPropIdent;\n\n\t\t\t\t// If this is the first property in a list of multiple\n\t\t\t\t// properties, we need to wrap the PropValue in an array\n\t\t\t\tif (!Array.isArray(node[propIdent])) {\n\t\t\t\t\tnode[propIdent] = [node[propIdent]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlastPropIdent = propIdent;\n\n\t\t\tpropValue = property.substring(propValueBegin + 1, property.length - 1);\n\n\t\t\t// We have no problem parsing PropIdents of any length, but the spec\n\t\t\t// says they should be no longer than two characters.\n\t\t\t//\n\t\t\t// http://www.red-bean.com/sgf/sgf4.html#2.2\n\t\t\tif (propIdent.length > 2) {\n\t\t\t\t// TODO: What's the best way to issue a warning?\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'SGF PropIdents should be no longer than two characters:', propIdent\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (Array.isArray(node[propIdent])) {\n\t\t\t\tnode[propIdent].push(propValue);\n\t\t\t} else {\n\t\t\t\tnode[propIdent] = propValue;\n\t\t\t}\n\n\t\t\treturn sgf.substring(firstPropEnd);\n\t\t},\n\n\t\t// Whitespace, tabs, or anything else we don't recognize\n\t\tunrecognized: function (sgf) {\n\n\t\t\t// March ahead to the next character\n\t\t\treturn sgf.substring(1);\n\t\t}\n\t};\n\n\t// Processes an SGF file character by character\n\tparse = function (sgf) {\n\t\twhile (sgf) {\n\t\t\tvar initial = sgf.substring(0, 1);\n\t\t\tvar type;\n\n\t\t\t// Use the initial (the first character in the remaining sgf file) to\n\t\t\t// decide which parser function to use\n\t\t\tif (initial === '(') {\n\t\t\t\ttype = 'beginSequence';\n\t\t\t} else if (initial === ')') {\n\t\t\t\ttype = 'endSequence';\n\t\t\t} else if (initial === ';') {\n\t\t\t\ttype = 'node';\n\t\t\t} else if (initial.search(/[A-Z\\[]/) !== -1) {\n\t\t\t\ttype = 'property';\n\t\t\t} else {\n\t\t\t\ttype = 'unrecognized';\n\t\t\t}\n\n\t\t\tsgf = parser[type](sgf);\n\t\t}\n\n\t\treturn collection;\n\t};\n\n\t// Begin parsing the SGF file\n\treturn parse(sgf);\n};\n\n/**\n * Generate an SGF file from a SmartGame Record JavaScript Object\n * @param {object} record A record object.\n * @return {string} The record as a string suitable for saving as an SGF file\n */\nexports.generate = function (record) {\n\t'use strict';\n\n\tfunction stringifySequences(sequences) {\n\t\tvar contents = '';\n\n\t\tsequences.forEach(function (sequence) {\n\t\t\tcontents += '(';\n\n\t\t\t// Parse all nodes in this sequence\n\t\t\tif (sequence.nodes) {\n\t\t\t\tsequence.nodes.forEach(function (node) {\n\t\t\t\t\tvar nodeString = ';';\n\t\t\t\t\tfor (var property in node) {\n\t\t\t\t\t\tif (node.hasOwnProperty(property)) {\n\t\t\t\t\t\t\tvar prop = node[property];\n\t\t\t\t\t\t\tif (Array.isArray(prop)) {\n\t\t\t\t\t\t\t\tprop = prop.join('][');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnodeString += property + '[' + prop + ']';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontents += nodeString;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Call the function we're in recursively for any child sequences\n\t\t\tif (sequence.sequences) {\n\t\t\t\tcontents += stringifySequences(sequence.sequences);\n\t\t\t}\n\n\t\t\tcontents += ')';\n\t\t});\n\n\t\treturn contents;\n\t}\n\n\treturn stringifySequences(record.gameTrees);\n};\n\n","/**\n * Interact with smartgame objects.\n * @param {object} smartgame A JS Object representing a smartgame\n * @see http://www.red-bean.com/sgf/sgf4.html\n * @return {object} An object with methods for navigating and manipulating a\n * smartgame\n */\nmodule.exports = function (smartgame) {\n\t'use strict';\n\n\tvar sequence;\n\tvar node;\n\n\tvar Smartgamer = function () {\n\t\tthis.init();\n\t};\n\n\tSmartgamer.prototype = {\n\t\tinit: function () {\n\t\t\tif (smartgame) {\n\t\t\t\tthis.game = smartgame.gameTrees[0];\n\t\t\t\tthis.reset();\n\t\t\t}\n\t\t},\n\n\t\t// Load a smartgame to make it possible to load new games or add one after\n\t\t// initialization, if desired\n\t\tload: function (newSmartgame) {\n\t\t\tsmartgame = newSmartgame;\n\t\t\tthis.init();\n\t\t},\n\n\t\t// Having multiple games in a collection is not common, but it's part of\n\t\t// the spec\n\t\tgames: function () {\n\t\t\treturn smartgame.gameTrees;\n\t\t},\n\n\t\tselectGame: function (i) {\n\t\t\tif (i < smartgame.gameTrees.length) {\n\t\t\t\tthis.game = smartgame.gameTrees[i];\n\t\t\t\tthis.reset();\n\t\t\t} else {\n\t\t\t\tthrow new Error('the collection doesn\\'t contain that many games');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\treset: function () {\n\t\t\tsequence = this.game;\n\t\t\tnode = sequence.nodes[0];\n\t\t\tthis.path = { m: 0 };\n\n\t\t\treturn this;\n\t\t},\n\n\t\tgetSmartgame: function () {\n\t\t\treturn smartgame;\n\t\t},\n\n\t\t/**\n\t\t * Return any variations available at the current move\n\t\t **/\n\t\tvariations: function () {\n\t\t\tif (sequence) {\n\t\t\t\tvar localNodes = sequence.nodes;\n\t\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t\tif (localNodes) {\n\t\t\t\t\tif (localIndex === (localNodes.length - 1)) {\n\t\t\t\t\t\treturn sequence.sequences || [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Go to the next move\n\t\t **/\n\t\tnext: function (variation) {\n\t\t\tvariation = variation || 0;\n\n\t\t\tvar localNodes = sequence.nodes;\n\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t// If there are no additional nodes in this sequence,\n\t\t\t// advance to the next one\n\t\t\tif (localIndex === null || localIndex >= (localNodes.length - 1)) {\n\t\t\t\tif (sequence.sequences) {\n\t\t\t\t\tif (sequence.sequences[variation]) {\n\t\t\t\t\t\tsequence = sequence.sequences[variation];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsequence = sequence.sequences[0];\n\t\t\t\t\t}\n\n\t\t\t\t\tnode = sequence.nodes[0];\n\n\t\t\t\t\t// Note the fork chosen for this variation in the path\n\t\t\t\t\tthis.path[this.path.m] = variation;\n\t\t\t\t\tthis.path.m += 1;\n\t\t\t\t} else {\n\t\t\t\t\t// End of sequence / game\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = localNodes[localIndex + 1];\n\t\t\t\tthis.path.m += 1;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Go to the previous move\n\t\t **/\n\t\tprevious: function () {\n\t\t\tvar localNodes = sequence.nodes;\n\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t// Delete any variation forks at this point\n\t\t\t// TODO: Make this configurable... we should keep this if we're\n\t\t\t// remembering chosen paths\n\t\t\tdelete this.path[this.path.m];\n\n\t\t\tif (!localIndex || localIndex === 0) {\n\t\t\t\tif (sequence.parent && !sequence.parent.gameTrees) {\n\t\t\t\t\tsequence = sequence.parent;\n\t\t\t\t\tif (sequence.nodes) {\n\t\t\t\t\t\tnode = sequence.nodes[sequence.nodes.length - 1];\n\t\t\t\t\t\tthis.path.m -= 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode = null;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Already at the beginning\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = localNodes[localIndex - 1];\n\t\t\t\tthis.path.m -= 1;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t// Go to the last move of the game\n\t\tlast: function () {\n\t\t\tvar totalMoves = this.totalMoves();\n\n\t\t\twhile(this.path.m < totalMoves) {\n\t\t\t\tthis.next();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t// Go to the first move of the game\n\t\tfirst: function () {\n\t\t\tthis.reset();\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Go to a particular move, specified as a\n\t\t * a) number\n\t\t * b) path string\n\t\t * c) path object\n\t\t **/\n\t\tgoTo: function (path) {\n\t\t\tif (typeof path === 'string') {\n\t\t\t\tpath = this.pathTransform(path, 'object');\n\t\t\t} else if (typeof path === 'number') {\n\t\t\t\tpath = { m: path };\n\t\t\t}\n\n\t\t\tthis.reset();\n\n\t\t\tvar n = node;\n\n\t\t\tfor (var i = 0; i < path.m && n; i += 1) {\n\t\t\t\t// Check for a variation in the path for the upcoming move\n\t\t\t\tvar variation = path[i + 1] || 0;\n\t\t\t\tn = this.next(variation);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tgetGameInfo: function () {\n\t\t\treturn this.game.nodes[0];\n\t\t},\n\n\t\t// Provide the current node\n\t\tnode: function () {\n\t\t\treturn node;\n\t\t},\n\n\t\t// Get the total number of moves in a game\n\t\ttotalMoves: function () {\n\t\t\tvar localSequence = this.game;\n\t\t\tvar moves = 0;\n\t\t\twhile(localSequence) {\n\t\t\t\tmoves += localSequence.nodes.length;\n\n\t\t\t\tif (localSequence.sequences) {\n\t\t\t\t\tlocalSequence = localSequence.sequences[0];\n\t\t\t\t} else {\n\t\t\t\t\tlocalSequence = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: Right now we're *assuming* that the root node doesn't have a\n\t\t\t// move in it, which is *recommended* but not required practice.\n\t\t\t// @see http://www.red-bean.com/sgf/sgf4.html\n\t\t\t// \"Note: it's bad style to have move properties in root nodes.\n\t\t\t// (it isn't forbidden though)\"\n\t\t\treturn moves - 1;\n\t\t},\n\n\t\t// Get or set a comment on the current node\n\t\t// @see http://www.red-bean.com/sgf/sgf4.html#text\n\t\tcomment: function (text) {\n\t\t\tif (typeof text === 'undefined') {\n\t\t\t\t// Unescape characters\n\t\t\t\tif (node.C) {\n\t\t\t\t\treturn node.C.replace(/\\\\([\\\\:\\]])/g, '$1');\n\t\t\t\t} else {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Escape characters\n\t\t\t\tnode.C = text.replace(/[\\\\:\\]]/g, '\\\\$&');\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Translate alpha coordinates into an array\n\t\t * @param string alphaCoordinates\n\t\t * @return array [x, y]\n\t\t **/\n\t\ttranslateCoordinates: function (alphaCoordinates) {\n\t\t\tvar coordinateLabels = 'abcdefghijklmnopqrst';\n\t\t\tvar intersection = [];\n\n\t\t\tintersection[0] = coordinateLabels.indexOf(alphaCoordinates.substring(0, 1));\n\t\t\tintersection[1] = coordinateLabels.indexOf(alphaCoordinates.substring(1, 2));\n\n\t\t\treturn intersection;\n\t\t},\n\n\t\t/**\n\t\t * Convert path objects to strings and path strings to objects\n\t\t **/\n\t\tpathTransform: function (input, outputType, verbose) {\n\t\t\tvar output;\n\n\t\t\t// If no output type has been specified, try to set it to the\n\t\t\t// opposite of the input\n\t\t\tif (typeof outputType === 'undefined') {\n\t\t\t\toutputType = (typeof input === 'string') ? 'object' : 'string';\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Turn a path object into a string.\n\t\t\t */\n\t\t\tfunction stringify(input) {\n\t\t\t\tif (typeof input === 'string') {\n\t\t\t\t\treturn input;\n\t\t\t\t}\n\n\t\t\t\tif (!input) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\n\t\t\t\toutput = input.m;\n\n\t\t\t\tvar variations = [];\n\t\t\t\tfor (var key in input) {\n\t\t\t\t\tif (input.hasOwnProperty(key) && key !== 'm') {\n\t\t\t\t\t\t// Only show variations that are not the primary one, since\n\t\t\t\t\t\t// primary variations are chosen by default\n\t\t\t\t\t\tif (input[key] > 0) {\n\t\t\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\t\t\tvariations.push(', variation ' + input[key] + ' at move ' + key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvariations.push('-' + key + ':' + input[key]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toutput += variations.join('');\n\t\t\t\treturn output;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Turn a path string into an object.\n\t\t\t */\n\t\t\tfunction parse(input) {\n\t\t\t\tif (typeof input === 'object') {\n\t\t\t\t\tinput = stringify(input);\n\t\t\t\t}\n\n\t\t\t\tif (!input) {\n\t\t\t\t\treturn { m: 0 };\n\t\t\t\t}\n\n\t\t\t\tvar path = input.split('-');\n\t\t\t\toutput = {\n\t\t\t\t\tm: Number(path.shift())\n\t\t\t\t};\n\n\t\t\t\tif (path.length) {\n\t\t\t\t\tpath.forEach(function (variation, i) {\n\t\t\t\t\t\tvariation = variation.split(':');\n\t\t\t\t\t\toutput[Number(variation[0])] = parseInt(variation[1], 10);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\t\t\t}\n\n\t\t\tif (outputType === 'string') {\n\t\t\t\toutput = stringify(input);\n\t\t\t} else if (outputType === 'object') {\n\t\t\t\toutput = parse(input);\n\t\t\t} else {\n\t\t\t\toutput = undefined;\n\t\t\t}\n\n\t\t\treturn output;\n\t\t}\n\t};\n\n\treturn new Smartgamer();\n};\n","/* globals module: false, require: false\r\n\r\n*/\r\n\r\n\r\nmodule.exports = (variantSgf, options) => {\r\n  'use strict' \r\n  let transformer = require('./transformer')\r\n\t,  smartgame = require('smartgame')\r\n\t,  smartgamer = require('smartgamer')\r\n\t,  tGo = require('go-variants-engine')()\r\n    return (transformer(options)).transform(\r\n  \r\n    variantSgf\r\n    , tGo\r\n    , smartgame\r\n    , smartgamer\r\n    )\r\n  }","﻿/* globals module: false, require: false\r\n\r\n*/\r\n/**\r\n * Provides a function for transforming SGF for a Go variant to SGF for a standard Go viewer; also provides a function for the inverse transformation.\r\n * @param {object} [options=] Defines various options for the output SGF. May be omitted, in which case the default options (see below) are used.\r\n * @param {boolean} [options.addComments = false] When flagged, comments are added to each node giving the move number and the number of stones captured by Black and White.\r\n * @param {boolean} [options.addPasses = true] When flagged, a pass is added to each node corresponding to a move by a player. This can make the output more easy to navigate in some viewers.\r\n * @param {array} [options.boardDimensions = [11, 11]] May be used for rectangular t-Go. Should be ommitted for [n, n] t-Go, where n is specified in the input SGF (@param variantSgf).\r\n * @param {number} [options.coordinatesType = 0] 0: none;\r\n * 1: (→↑;A|1-K|11): Western;\r\n * 2: (→↑;A|1-L|11): Western, no “I”;\r\n * 3: (→↓;1|1-11|11): Latin/Latin, top to bottom;\r\n * 4: (→↓;1|1-11|十一): Latin/Chinese, top to bottom;\r\n * @param {number} [options.wraparoundMarkersType = 1] 0: none;\r\n * 1: Full outline, using unicode Box Drawing symbols;\r\n * 2: corners and middles, using unicode Box Drawing symbols;\r\n * 3: just corners, using unicode Box Drawing symbols;\r\n * 4: just middles, using unicode Box Drawing symbols;\r\n * @param {object} [options.projectionSettings=] Further optional settings for how the (toroidal, or other sort of) board is projected to a flat grid.\r\n * @param {number} [options.projectionSettings.wraparound = 4]  Number of lines to add for the “wraparound”.\r\n * @param {array} [options.projectionSettings.offset = [0,0]]  Translation to apply to all moves.\r\n * @param {boolean} [options.transformToString=true] When set to false, the output is an object (an instance of a Smartgame).\r\n * @public\r\n * @return {object} An object exposing functions for going back and forth between SGF for a standard viewer, and SGF for a game of toroidal Go\r\n *//*todos:\r\noptions.markLastMove Default value: 'CR'\r\nopions.placesToCount Default: undefined. May be: 'last'|[countInfo1, .. countInfo1]. countInfo is a path plus an array with a point for each chain to be considered as dead. {path, deadChains: [...]}\r\noptions.projectionSettings.rotation {integer} Default value: 0. Allowed values: 0 .. 3\r\noptions.projectionSettings.normalizePlace array, or one of: C, TL TR BL BR (centre, top left, top right, bottom left, bottom right)\r\noptions.projectionSettings.normalize {boolean} \r\n\r\n*/\r\nfunction transformer(options\r\n) {\r\n\t'use strict';\r\n\tconst\r\n\t\t_flatten = require('lodash/flatten')\r\n\t\t, _uniqBy = require('lodash/uniqBy')\r\n\t\t, _fi = require('lodash/findIndex')\r\n\t\t, modulo = (x, y) => (x % y + y) % y\r\n\t\t, sourceSgfMessage = 'source sgf for toroidal Go has been adapted by go-variants-transformer so as to be rendered by any standard Go application'\r\n\toptions = {\r\n\t\taddPasses: true\r\n\t\t, boardDimensions: [11, 11]\r\n\t\t, transformToString: true\r\n\t\t, addComments: true\r\n\t\t, coordinatesType: 0\r\n\t\t, wraparoundMarkersType: 1\r\n\t\t//above are the defaults\r\n\t\t, ...options\r\n\t}\r\n\toptions.projectionSettings =\r\n\t\t{\r\n\t\t\twraparound: 4,\r\n\t\t\toffset: [0, 0],\r\n\t\t\t...options.projectionSettings\r\n\t\t}\r\n\r\n\tif (options.addPasses === undefined)\r\n\t\toptions.addPasses = true;\r\n\r\n\toptions.boardDimensions = options.boardDimensions || [11, 11]\r\n\r\n\tif (options.transformToString === undefined)\r\n\t\toptions.transformToString = true;\r\n\r\n\tif (options.addComments === undefined)\r\n\t\toptions.addComments = true;\r\n\t// options.projectionSettings = \r\n\r\n\tlet wraparound = options.projectionSettings.wraparound\r\n\r\n\tlet $ = {}\r\n\t\t// , _markersForWraparound = null\r\n\t\t, coordinateLabels = function (i) {\r\n\t\t\t// 97..122 and 65..90\r\n\t\t\treturn String.fromCharCode(i < 26 ? i + 97 : i + 39)\r\n\t\t\t//65 - 26 =\r\n\t\t}\r\n\t\t,\r\n\t\ttranslateCoordinate = (c) => {\r\n\t\t\tlet r = c.charCodeAt(0)\r\n\t\t\treturn r >= 97 ? r - 97 : r - 26\r\n\t\t},\r\n\t\t/**\r\n\t\t * Translate alpha coordinates into an array\r\n\t\t * @param string alphaCoordinates\r\n\t\t * @return array [x, y]\r\n\t\t **/\r\n\t\ttranslateCoordinates = (alphaCoordinates) => {\r\n\t\t\treturn [translateCoordinate(alphaCoordinates.substring(0, 1))\r\n\t\t\t\t, translateCoordinate(alphaCoordinates.substring(1, 2))]\r\n\r\n\t\t}\r\n\r\n\r\n\t$.coordinateLabels = coordinateLabels\r\n\t$.translateCoordinates = translateCoordinates\r\n\t/**\r\n\t * @public\r\n\t */\r\n\t$.options = options\r\n\r\n\t$.projectOnLine = function (a, isVertical) {\r\n\t\t/*\r\n\t\tm: boardDimensions[0] : 11\r\n\t\tn: wraparound : 4\r\n\t\tline: 0,...,(m-1)\r\n\t\t=>\r\n\t\t0,...,(n-1), (start line) n, ... , (n + m - 1) end line,  (n+m), ... , (2n + m - 1)\r\n\r\n\t\tcoordinate a ∈ {0 .. m-1} projects to n + a in main area\r\n\t\tall projections are of the form n + a + xm, x ∈ ℤ s.t. 0 ≤ n + a + xm ≤ 2n + m -1\r\n\t\t-xm ≤ n + a\r\n\t\t\tsmallest such x < 0 is ceil(-(n+a)/m)\r\n\t\t xm ≤ n + m - 1 -a\r\n\t\t\tlargest such x is floor((n + m - 1 -a) / m)\r\n\r\n\r\n\t\t*/\r\n\r\n\t\tconst m //= options.boardDimensions[0]\r\n\t\t\t= options.boardDimensions[isVertical ? 1 : 0]\r\n\r\n\t\t\t, r = []\r\n\r\n\t\tfor (let i = Math.ceil(-(wraparound + a) / m); i <= (wraparound + m - 1 - a) / m; i++)\r\n\t\t\tr.push(wraparound + a + i * m)\r\n\t\treturn r\r\n\t}\r\n\r\n\t/**\r\n\t * This is the inverse function to the function “projectOnFlat” – at least it is when “multiple” is false.\r\n\t * @param {Array} points The point or array of points projected onto the grid.\r\n\t * @param {Boolean=false} multiple Whether the argument “points” is the image of a single point (“multiple=false”) or of multiple points.\r\n\t * @returns {Array} When the flag “multiple” is flagged, returns an array of points; otherwise returns a single point (i.e. an array of two integers).\r\n\t */\r\n\tfunction inverseProjectOnFlat(points, multiple) {\r\n\t\tif (!Array.isArray(points[0])) points = [points]\r\n\t\tif (!multiple)\r\n\t\t\treturn [modulo(points[0][0] - options.projectionSettings.offset[0] - wraparound, options.boardDimensions[0])\r\n\t\t\t\t, modulo(points[0][1] - options.projectionSettings.offset[1] - wraparound, options.boardDimensions[1])]\r\n\t\treturn _uniqBy(points.map(x => inverseProjectOnFlat([x])), (x) => `${x[0]}_${x[1]}`)\r\n\t}\r\n\t$.inverseProjectOnFlat = inverseProjectOnFlat\r\n\r\n\t/**\r\n\t * Projects a point on the t-Go board to the array of points on the standard grid/board.\r\n\t * @param {Array} p The point in the t-Go board to be projected on to the grid.\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction projectOnFlat(p) {\r\n\t\tconst a = $.projectOnLine(p[0] + options.projectionSettings.offset[0])\r\n\t\t\t, b = $.projectOnLine(p[1] + options.projectionSettings.offset[1])\r\n\t\t\t, r = []\r\n\t\tfor (let i = 0; i < a.length; i++)\r\n\t\t\tfor (let j = 0; j < b.length; j++)\r\n\t\t\t\tr.push([a[i], b[j]])\r\n\t\treturn r\r\n\t}\r\n\t$.projectOnFlat = projectOnFlat\r\n\r\n\t$.modX = (x) => modulo(x, options.boardDimensions[0])\r\n\t$.modY = (y) => modulo(y, options.boardDimensions[1])\r\n\r\n\tlet setUpMarkers = () => {\r\n\t\t$.wraparoundAndCoords = []\r\n\r\n\t\t// $.getMarkersForWraparound = function (){\r\n\t\tif (options.projectionSettings.wraparound > 0) {\r\n\t\t\tconst m = options.boardDimensions[0],\r\n\t\t\t\tn = options.boardDimensions[1]\r\n\r\n\t\t\t/*\r\n\t\t\tm: boardDimensions[0] : 11\r\n\t\t\tw: wraparound : 4\r\n\t\t\tline: 0,...,(m-1)\r\n\t\t\t=>\r\n\t\t\t0,...,(w-1), (start line) w, ... , (w + m - 1) end line, (w+m), ... , (2w + m - 1)\r\n\t\t\t*/\r\n\r\n\t\t\tlet board = []\r\n\t\t\tif ([1, 2, 4].indexOf(options.wraparoundMarkersType) > -1) {\r\n\t\t\t\tlet middles = options.wraparoundMarkersType > 1 ?\r\n\t\t\t\t\t[Math.floor((m - 1) / 2) + 1, Math.ceil((m - 1) / 2) + 1,\r\n\t\t\t\t\tMath.floor((n - 1) / 2) + 1, Math.ceil((n - 1) / 2) + 1]\r\n\t\t\t\t\t: [-1, 99, -1, 99]\r\n\t\t\t\tfor (let i = 1; i <= m; i++) {\r\n\t\t\t\t\tif (i < middles[0] || i > middles[1]) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label = '─'//U+2500 Box Drawings Light Horizontal\r\n\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1 + i) + coordinateLabels(wraparound - 1) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1 + i) + coordinateLabels(wraparound + m) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t\tfor (let i = 1; i <= n; i++) {\r\n\t\t\t\t\tif (i < middles[2] || i > middles[3]) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label = '│'//unicode too\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound - 1 + i) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound + n) + coordinateLabels(wraparound - 1 + i) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ([1, 2, 3].indexOf(options.wraparoundMarkersType) > -1) {\r\n\t\t\t\t//┘  ┌  └ ┐\r\n\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound + n) + \":└\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound + m) + coordinateLabels(wraparound + n) + \":┘\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound - 1) + \":┌\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound + m) + coordinateLabels(wraparound - 1) + \":┐\")\r\n\t\t\t}\r\n\r\n\t\t\tif (options.coordinatesType > 0 && wraparound > 1) {\r\n\t\t\t\tfor (let i = 1; i < 2 * wraparound + m - 1; i++) {\r\n\r\n\t\t\t\t\tlet coordIndex = $.modX(-options.projectionSettings.offset[0] - wraparound + i)\r\n\r\n\t\t\t\t\tif (options.coordinatesType === 2 && coordIndex >= 8) {\r\n\t\t\t\t\t\t//omit the I - historical coordinates for Go...\r\n\t\t\t\t\t\t//I: 9th letter\r\n\t\t\t\t\t\tcoordIndex++\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label =\r\n\t\t\t\t\t\toptions.coordinatesType < 3\r\n\t\t\t\t\t\t\t? coordinateLabels(coordIndex).toUpperCase()\r\n\t\t\t\t\t\t\t: '' + (coordIndex + 1)\r\n\t\t\t\t\tboard.push(coordinateLabels(i) + coordinateLabels(0) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(i) + coordinateLabels(2 * wraparound + n - 1) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t\tlet cjkNumbers = '一二三四五六七八九'\r\n\t\t\t\tfor (let i = 1; i < 2 * wraparound + n - 1; i++) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t0\t\t-w\r\n\t\t\t\t\t...\r\n\t\t\t\t\tw-1\t-1\r\n\t\t\t\t\tw\t\t0\r\n\t\t\t\t\t...\r\n\t\t\t\t\tw + n -1\r\n\t\t\t\t\t\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tlet coordIndex =\r\n\t\t\t\t\t\toptions.coordinatesType < 3\r\n\t\t\t\t\t\t\t? $.modY(n + options.projectionSettings.offset[1] + wraparound - i - 1)\r\n\t\t\t\t\t\t\t: $.modY(i - wraparound - options.projectionSettings.offset[1])\r\n\t\t\t\t\tlet label = ''\r\n\t\t\t\t\tswitch (options.coordinatesType) {\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\tlabel = '' + (coordIndex + 1)\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\tlabel = modulo(coordIndex, 10) === 9 ? '' : cjkNumbers[modulo(coordIndex, 10)]\r\n\r\n\t\t\t\t\t\t\tif (coordIndex > 8) {\r\n\t\t\t\t\t\t\t\tlabel = (coordIndex > 18 ? cjkNumbers[Math.floor((coordIndex + 1) / 10) - 1] : '') + '十' + label\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t\tboard.push(coordinateLabels(0) + coordinateLabels(i) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(2 * wraparound + m - 1) + coordinateLabels(i) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t$.wraparoundAndCoords = board\r\n\t\t}\r\n\t}\r\n\tsetUpMarkers()\r\n\r\n\r\n\t$.coords2String =\r\n\t\t/**\r\n\t\t * converts coordinates to a string\r\n\t\t */\r\n\t\tfunction coords2String(coords) {\r\n\t\t\treturn coordinateLabels(coords[0]) + coordinateLabels(coords[1])\r\n\t\t}\r\n\r\n\tfunction goThroughTree(state) {\r\n\t\tlet { wrappedGame, node, pending, currentPath, tGo } = state\r\n\t\t\t, nbVariations = wrappedGame.variations().length\r\n\t\tif (currentPath.m > 1000) throw new Error('seem to be stuck!');\r\n\t\tstate.hasSiblings = nbVariations > 0\r\n\t\tif (state.hasSiblings) {\r\n\t\t\t// if(currentPath[m] === undefined)\r\n\t\t\t// currentPath[m] = 0\r\n\t\t\t// else\r\n\t\t\t// currentPath[m] += 1\r\n\t\t\t// currentPath.m += 1\r\n\t\t\tfor (let i = nbVariations - 1; i > 0; i--)\r\n\t\t\t//pile up in this order, as it's FILO and we want the last variation, which may contain a mode added by CGoboard to go last\r\n\t\t\t{\r\n\t\t\t\tlet pathForLater = { ...currentPath }//Object.assign({}, currentPath)\r\n\t\t\t\tpathForLater[currentPath.m + 1] = i\r\n\t\t\t\tpathForLater.m += 1\r\n\r\n\t\t\t\tif (tGo !== undefined)\r\n\t\t\t\t\tpending.push({ path: pathForLater, tGoData: tGo.exportData() })\r\n\t\t\t\telse\r\n\t\t\t\t\tpending.push({ path: pathForLater })\r\n\r\n\t\t\t}\r\n\t\t\tstate.node = wrappedGame.next().node()\r\n\t\t\tcurrentPath[currentPath.m + 1] = 0\r\n\t\t\tcurrentPath.m += 1\r\n\t\t\treturn state.node\r\n\t\t}\r\n\r\n\t\tlet nextNode = wrappedGame.next().node()\r\n\t\tif (node === nextNode) {//at a leaf:\r\n\t\t\tif (pending.length === 0) {\r\n\t\t\t\tstate.node = null\r\n\t\t\t\treturn state.node//finished\r\n\t\t\t}\r\n\t\t\tlet fromStack = pending.pop()\r\n\t\t\tstate.hasSiblings = true\r\n\t\t\t// if (fromStack === null) {\r\n\t\t\t// \tnode = null\r\n\t\t\t// \treturn//finished!\r\n\t\t\t// }\r\n\t\t\tif (tGo !== undefined) tGo.loadData(fromStack.tGoData)\r\n\t\t\tstate.node = wrappedGame.goTo(fromStack.path).node()\r\n\t\t\tstate.currentPath = fromStack.path\r\n\t\t\treturn state.node\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcurrentPath.m += 1\r\n\t\t\tstate.node = nextNode\r\n\t\t\treturn state.node\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Apart from a few details, this is an inverse of the transform function.\r\n\t * @param {smartgame|string} wrappedGame\r\n\t * @param {smartgame} smartgame\r\n\t * @public\r\n\t */\r\n\tfunction inverseTransform(\r\n\t\twrappedGame, smartgame) {\r\n\r\n\t\tif (smartgame === undefined) {\r\n\t\t\tsmartgame = require('smartgame')\r\n\t\t}\r\n\r\n\t\tif (typeof wrappedGame === 'string') {\r\n\t\t\tvar smartgamer = require('smartgamer')\r\n\t\t\twrappedGame = smartgamer(smartgame.parse(wrappedGame))\r\n\t\t}\r\n\r\n\t\tlet node = wrappedGame.first().node()\r\n\t\t\t, pending = []\r\n\t\t\t, currentPath = { m: 0 }\r\n\t\t\t, cleanerRegEx = /^[a-zA-Z :0-9\\-(\\r\\n]+GoVariantsTransformer\\)--[\\r\\n]*/\r\n\t\t\t, cleanComments = () => {\r\n\t\t\t\tif (node.C !== undefined) {\r\n\t\t\t\t\tnode.C = node.C.replace(cleanerRegEx, '')\r\n\t\t\t\t}\r\n\t\t\t\tif (node.C === '')\r\n\t\t\t\t\tdelete node.C\r\n\t\t\t}\r\n\t\t\t,\r\n\t\t\t/**\r\n\t\t\t * Function to:\r\n\t\t\t * \t- remove the “border” (unicode symbols added by the transform to indicate where the wraparound area meets the main grid).\r\n\t\t\t * \t- remove CM (colour map) and CT (colour table) which are nonstandard SGF added by CGoboard for background colour (could be interesting to use this feature later on).\r\n\t\t\t */\r\n\t\t\tcleanLabels = () => {\r\n\r\n\t\t\t\tlet labels = []\r\n\t\t\t\tif (node.LB !== undefined) {\r\n\t\t\t\t\tlabels = node.LB\r\n\t\t\t\t\tif (!Array.isArray(labels))\r\n\t\t\t\t\t\tlabels = [labels]\r\n\t\t\t\t\tlabels = labels.filter(i => !$.wraparoundAndCoords.includes(i))\r\n\t\t\t\t\t/* jshint loopfunc: true */\r\n\t\t\t\t\tlabels =\r\n\t\t\t\t\t\t_uniqBy(\r\n\t\t\t\t\t\t\tlabels\r\n\t\t\t\t\t\t\t\t.map(function (x) { return x.split(':', 2) })//assume the label doesn’t contain “:”\r\n\t\t\t\t\t\t\t\t.map((x) => [$.coords2String($.inverseProjectOnFlat(translateCoordinates(x[0]))), x[1]])\r\n\t\t\t\t\t\t\t, (x) => x[0])\r\n\t\t\t\t\t\t\t.map((x) => `${x[0]}:${x[1]}`)\r\n\r\n\r\n\t\t\t\t\t// labels = []\r\n\t\t\t\t\t// for (let i = 0; i < labels2.length; i++)\r\n\t\t\t\t\t// \tlabels = labels.concat(labels2)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.LB = labels\r\n\t\t\t\tif (node.LB.length === 0)\r\n\t\t\t\t\tdelete node.LB\r\n\r\n\t\t\t\tif (node.CM)\r\n\t\t\t\t\tdelete node.CM\r\n\t\t\t\tif (node.CT)\r\n\t\t\t\t\tdelete node.CT\r\n\t\t\t}\r\n\r\n\t\tcleanLabels()\r\n\t\tnode.SZ = options.boardDimensions[0]\r\n\t\tnode.AP = \"go-variants-transformer\"\r\n\r\n\t\tif (node.SO !== undefined) {\r\n\t\t\tlet cleanSourceRegex = new RegExp(` \\\\(${sourceSgfMessage}\\\\)`)\r\n\t\t\tnode.SO = node.SO.replace(cleanSourceRegex, '')\r\n\t\t\t// if (node.SO === '')\r\n\t\t\t// \tdelete node.SO\r\n\t\t}\r\n\r\n\t\tlet state = {\r\n\t\t\twrappedGame, node, pending, currentPath, siblingMoves: {}//, parentsWithChildToDelete: [] \r\n\t\t}\r\n\r\n\t\tnode = goThroughTree(state)\r\n\t\twhile (node !== null) {\r\n\t\t\tcleanLabels()\r\n\t\t\tcleanComments()\r\n\r\n\t\t\tconst\r\n\t\t\t\tisBlack = node.AB !== undefined || node.B !== undefined\r\n\t\t\t\t, addedStones = isBlack ? node.AB : node.AW\r\n\t\t\t\t, playedStone = isBlack ? node.B : node.W\r\n\t\t\t\t, move = addedStones ? addedStones : playedStone\r\n\t\t\t\t, moveAsArray = Array.isArray(move) ? move : [move]\r\n\t\t\t\t, isAPass = isBlack ? node.B === '' : node.W === ''\r\n\t\t\t\t, moveHasCoords = move !== undefined && move !== ''\r\n\t\t\t\t, coords = !moveHasCoords ? undefined : $.coords2String($.inverseProjectOnFlat(moveAsArray.map(translateCoordinates)))\r\n\r\n\t\t\t//alter the node\r\n\r\n\t\t\t/*\r\n\t\t\tlogic removing a node added by CGoboard, if there already is the same move as AB or AW in a prior variation; assuming \r\n\t\t\tthe variation to be removed is the last of the siblings - which does seem to be the way CGoboard behaves when a click \r\n\t\t\tis made on a point where the next node is AB or AW.  \r\n\t\t\t*/\r\n\t\t\tif (state.hasSiblings) {\r\n\t\t\t\tlet pathForParent = { ...wrappedGame.path } //Object.assign({}, wrappedGame.path)\r\n\t\t\t\tpathForParent.m--\r\n\t\t\t\tdelete pathForParent[pathForParent.m]\r\n\t\t\t\tpathForParent = wrappedGame.pathTransform(pathForParent)\r\n\t\t\t\t// wrappedGame.previous()\r\n\t\t\t\tif (state.siblingMoves[pathForParent] === undefined) {\r\n\t\t\t\t\tstate.siblingMoves[pathForParent] = []\r\n\t\t\t\t}\r\n\t\t\t\tif (addedStones) {\r\n\t\t\t\t\tstate.siblingMoves[pathForParent].push(coords)\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tif (playedStone && state.siblingMoves[pathForParent].indexOf(coords) > -1) {\r\n\r\n\t\t\t\t\t\t// state.parentsWithChildToDelete.push(pathForParent)\r\n\t\t\t\t\t\tnode.XX = \"inverseTransformToDelete\"\r\n\t\t\t\t\t}\r\n\t\t\t\t// wrappedGame.goTo(currentPath)\r\n\t\t\t}\r\n\r\n\t\t\tdelete node[isBlack ? 'AB' : 'AW']\r\n\t\t\tdelete node[isBlack ? 'B' : 'W']\r\n\t\t\tdelete node.CR\r\n\t\t\tdelete node.AE\r\n\r\n\t\t\tif (isAPass) {\r\n\t\t\t\tnode[isBlack ? 'B' : 'W'] = ''\r\n\t\t\t}\r\n\r\n\t\t\tif (moveHasCoords) {\r\n\t\t\t\tnode[isBlack ? 'B' : 'W'] = coords\r\n\t\t\t}\r\n\r\n\t\t\t;/*note: this next semicolon is needed! */[// eslint-disable-line no-extra-semi\r\n\t\t\t\t//'CR',todo: add if not marking the move\r\n\t\t\t\t'DD', 'MA', 'SL', 'SQ', 'TR'].forEach(function (sgfProperty) {\r\n\t\t\t\t\t// _.map(['DD','MA','SL','SQ','TR'], function(sgfProperty){\r\n\t\t\t\t\tif (node[sgfProperty] === undefined) return\r\n\t\t\t\t\tlet points = []\r\n\t\t\t\t\tif (Array.isArray(node[sgfProperty])) {\r\n\t\t\t\t\t\tpoints = node[sgfProperty]\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpoints = [node[sgfProperty]]\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpoints =\r\n\t\t\t\t\t\t$.inverseProjectOnFlat(\r\n\t\t\t\t\t\t\tpoints.map(translateCoordinates), true\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t.map($.coords2String)\r\n\t\t\t\t\tnode[sgfProperty] = points\r\n\t\t\t\t})\r\n\t\t\t// move to next node\r\n\t\t\tnode = goThroughTree(state)\r\n\t\t}\r\n\r\n\t\t// state.parentsWithChildToDelete.forEach((path) => {\r\n\t\t// \t//remove the sgf node\r\n\t\t// \twrappedGame.goTo(path)\r\n\t\t// \tlet sequences = wrappedGame.game.sequences\r\n\t\t// \tlet index = _fi(sequences, (seq) => seq.nodes[0].inverseTransformToDelete)\r\n\t\t// \t\t, tmpI = 0\r\n\t\t// \twhile (index > -1) {\r\n\t\t// \t\tsequences.splice(index, 1)\r\n\t\t// \t\tindex = _fi(sequences, (seq) => seq.nodes[0].inverseTransformToDelete)\r\n\t\t// \t\ttmpI++\r\n\t\t// \t\tif (tmpI > 100) throw new Error('seem to be stuck!');\r\n\t\t// \t}\r\n\r\n\t\t// \t// console.log(path)\r\n\t\t// })\r\n\r\n\t\tlet deleteNodes = (sequence) => {\r\n\t\t\tif (sequence.sequences) {\r\n\r\n\t\t\t\tlet\r\n\t\t\t\t\tsequences = sequence.sequences\r\n\t\t\t\t\t, index = _fi(sequences, (seq) => seq.nodes[0].XX === 'inverseTransformToDelete')\r\n\t\t\t\t\t, tmpI = 0, max = sequences.length\r\n\t\t\t\twhile (index > -1) {\r\n\t\t\t\t\tsequences.splice(index, 1)\r\n\t\t\t\t\tindex = _fi(sequences, (seq) => seq.nodes[0].XX === 'inverseTransformToDelete')\r\n\t\t\t\t\ttmpI++\r\n\t\t\t\t\tif (tmpI > max) throw new Error('seem to be stuck!');\r\n\t\t\t\t}\r\n\t\t\t\tfor (let index2 = 0; index2 < sequences.length; index2++) {\r\n\t\t\t\t\t// deleteNodes(sequences[index2].nodes[sequences[index2].nodes.length - 1]);\r\n\t\t\t\t\tdeleteNodes(sequences[index2]);\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (sequence.nodes)\r\n\t\t\t\tdeleteNodes(sequence.nodes[sequence.nodes.length - 1])\r\n\t\t}\r\n\t\tdeleteNodes(wrappedGame.game)\r\n\r\n\t\tif (options.transformToString)\r\n\t\t\treturn smartgame.generate({ gameTrees: [wrappedGame.game] });\r\n\t\telse return wrappedGame\r\n\r\n\t}\r\n\t$.inverseTransform = inverseTransform\r\n\r\n\t/**\r\n\t * Main function; converts SGF for a Go variant (so far, just toroidal Go or t-Go).\r\n\t * @param {string} tSgf\r\n\t * @param {object} tGo Engine for counting liberties in t-Go. An instance of go-variants-engine.\r\n\t * @param {*} smartgame\r\n\t * @param {*} smartgamer\r\n\t * @returns {string|object} SGF that can be viewed in a standard SGF viewer. (See `options.transformToString` for the data type of the value returned.)\r\n\t * @public\r\n\t */\r\n\tfunction transform(\r\n\t\ttSgf //eg 11x11 sgf from LittleGolem\r\n\t\t, tGo //app implementing t-Go\r\n\t\t, smartgame\r\n\t\t, smartgamer) {\r\n\r\n\t\tif (tGo === undefined) {\r\n\t\t\t//  tGo = require('../dist/node_modules/go-variants-engine/src/engine.min.js')({\r\n\t\t\t//  tGo = require('../../engine/dist/engine.min.js')({\r\n\t\t\t\ttGo = require('go-variants-engine')({\r\n\t\t\t\t\t// tGo = require('../node_modules/go-variants-engine/src/engine')({\r\n\t\t\t\t// boardMode:'t',\r\n\t\t\t\tboardDimensions: options.boardDimensions\r\n\t\t\t})\r\n\t\t\t// tGo = require('../node_modules/go-variants-engine')({boardMode:'t', boardDimensions:options.boardDimensions})\r\n\t\t\t// tGo = require('../node_modules/go-variants-engine/src/engine')({boardMode:'t', boardDimensions:options.boardDimensions})\r\n\t\t}\r\n\t\t// else {\r\n\t\t// \ttGo.options.boardDimensions = options.boardDimensions\r\n\t\t// }\r\n\r\n\t\tif (smartgame === undefined) {\r\n\t\t\tsmartgame = require('smartgame')\r\n\t\t}\r\n\t\tif (smartgamer === undefined) {\r\n\t\t\tsmartgamer = require('smartgamer')\r\n\t\t}\r\n\t\t// console.log(tGo)\r\n\t\tlet parsed = smartgame.parse(tSgf)\r\n\t\t\t, wrappedGame = smartgamer(parsed)\r\n\t\t\t, node = wrappedGame.node()\r\n\t\t\t, passes = 0\r\n\t\t\t, pending = []\r\n\t\t\t, currentPath = { m: 0 }\r\n\t\tif (node.SZ !== undefined) {\r\n\t\t\tlet sz = Number(node.SZ)\r\n\t\t\t// sz+= 2*options.projectionSettings.wraparound\r\n\t\t\toptions.boardDimensions = [sz, sz]\r\n\t\t\ttGo.options.boardDimensions = options.boardDimensions\r\n\t\t\tsetUpMarkers()\r\n\t\t}\r\n\t\tif (node.KM !== undefined) {\r\n\t\t\toptions.rules = {komi: parseFloat(node.KM), ... options.rules }\r\n\t\t}\r\n\t\tnode.SZ = \"\" + (options.boardDimensions[0] + 2 * options.projectionSettings.wraparound)//not sure how to make a rectangular goban!\r\n\t\t//offset modulo\r\n\t\toptions.projectionSettings.offset[0] = modulo(options.projectionSettings.offset[0], options.boardDimensions[0])\r\n\t\toptions.projectionSettings.offset[1] = modulo(options.projectionSettings.offset[1], options.boardDimensions[1])\r\n\t\tlet setLabels = () => {\r\n\t\t\t//node.LB = $.wraparoundAndCoords\r\n\t\t\tlet labels = []\r\n\t\t\tif (node.LB !== undefined) {\r\n\t\t\t\tlabels = node.LB\r\n\t\t\t\tif (!Array.isArray(labels))\r\n\t\t\t\t\tlabels = [labels]\r\n\r\n\t\t\t\t/* jshint loopfunc: true */\r\n\t\t\t\tlet labels2 = labels//_.chain(labels)\r\n\t\t\t\t\t.map(function (x) { return x.split(':', 2) })//assume the label doesn’t contain “:”\r\n\t\t\t\t\t.map(function (x) { return [translateCoordinates(x[0]), x[1]] })\r\n\t\t\t\t\t.map(function (x) { return [$.projectOnFlat(x[0]), x[1]] })\r\n\t\t\t\t// .value()\r\n\t\t\t\tlabels = []\r\n\t\t\t\tfor (let i = 0; i < labels2.length; i++)\r\n\t\t\t\t\tlabels = labels.concat(\r\n\t\t\t\t\t\tlabels2[i][0].map(function (x) {\r\n\t\t\t\t\t\t\treturn $.coords2String(x) + \":\" + labels2[i][1]\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t)\r\n\t\t\t}\r\n\r\n\t\t\tnode.LB = $.wraparoundAndCoords.concat(labels)\r\n\t\t\tif (node.LB.length === 0)\r\n\t\t\t\t// delete node['LB']\r\n\t\t\t\tdelete node.LB\r\n\t\t}\r\n\r\n\t\tsetLabels()\r\n\r\n\t\tif (node.SO !== undefined)\r\n\t\t\tnode.SO = wrappedGame.game.nodes[0].SO + ` (${sourceSgfMessage})`\r\n\t\t//else node.SO = sourceSgfMessage//prefer not to add the message when original Sgf has no SO info.\r\n\r\n\t\tnode.AP = \"go-variants-transformer\"\r\n\r\n\r\n\t\tlet state = { wrappedGame, node, pending, currentPath, tGo }\r\n\r\n\t\tfunction comment(isPass, isBlack, score) {\r\n\t\t\tif (!options.addComments && !score)\r\n\t\t\t\treturn\r\n\r\n\t\t\tlet r = !options.addComments ?\r\n\t\t\t\t''\r\n\t\t\t\t: 'move ' + state.currentPath.m + '\\n' + 'White stones captured by Black: ' + tGo.board.captured[1] + '\\nBlack stones captured by White: ' + tGo.board.captured[0]\r\n\t\t\t\t//let r =  'Black captures: ' + tGo.board.captured[1] + '\\r\\nWhite captures: ' + tGo.board.captured[0]\r\n\t\t\t\t+ (!isPass ? '' : '\\n' + (isBlack ? 'Black passes' : 'White passes'))\r\n\t\t\t\t+ (!score ? '' : '\\n' + `result: ${score.displayResult}`)\r\n\r\n\t\t\tr += '\\n--(the content above was generated automatically by GoVariantsTransformer)--'\r\n\t\t\tr += (node.C === undefined ? '' : '\\n' + node.C)\r\n\t\t\tnode.C = r\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tnode = goThroughTree(state)\r\n\t\twhile (node !== null) {\r\n\r\n\r\n\t\t\tlet\r\n\t\t\t\tisBlack = node.B !== undefined\r\n\t\t\t\t, move = isBlack ? node.B : node.W\r\n\t\t\t\t, isPass = move === \"\" || (options.boardDimensions[0] === options.boardDimensions[1]\r\n\t\t\t\t\t&& options.boardDimensions[0] <= 19\r\n\t\t\t\t\t&& move === \"tt\" //weird SGF[3] way to show a pass move!\r\n\t\t\t\t)\r\n\t\t\t\t, stonesMarkedForScoring = []\r\n\r\n\t\t\tif (move === undefined && !isPass) {\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tsetLabels()\r\n\r\n\t\t\tif (isPass) {\r\n\t\t\t\tdelete node[isBlack ? 'B' : 'W']\r\n\t\t\t\tcomment(isPass, isBlack)\r\n\t\t\t\tnode[isBlack ? 'AB' : 'AW'] = []\r\n\t\t\t\t// if (passes === 2) {\r\n\t\t\t\t// \t//wrappedGame.game.nodes.splice(i+1)//get rid of nodes afterwards -- may not work with variations! todo\r\n\t\t\t\t// \tbreak;//stop after 3 successive passes for now\r\n\t\t\t\t// }\r\n\t\t\t\tpasses++\r\n\t\t\t\tif (passes >= 1000)\r\n\t\t\t\t\tbreak//just in case!\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconst coords = translateCoordinates(move)\r\n\t\t\t\tlet playResult = null\r\n\t\t\t\t// run move through tGo and update game accordingly\r\n\t\t\t\ttry {\r\n\t\t\t\t\tplayResult = tGo.play(isBlack ? 'b' : 'w', coords)\r\n\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tif (error.message !== 'point is not empty' /*ignore this - it happens with some sgf from littleGolem. Todo: look into scoring the position here. */)\r\n\t\t\t\t\t\tthrow (error)\r\n\t\t\t\t}\r\n\t\t\t\tconst projectedCoords = $.projectOnFlat(coords)\r\n\t\t\t\tlet toAdd = playResult === null ? [] : projectedCoords.map($.coords2String)\r\n\t\t\t\t\t, toRemove = playResult === null ? [] :\r\n\t\t\t\t\t\t// _.chain(playResult.removed)\r\n\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t// \t.map($.projectOnFlat)\r\n\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t// \t.map($.coords2String)\r\n\t\t\t\t\t\t// \t.value()\r\n\t\t\t\t\t\t_flatten(\r\n\t\t\t\t\t\t\t_flatten(playResult.removed)\r\n\t\t\t\t\t\t\t\t.map($.projectOnFlat))\r\n\t\t\t\t\t\t\t.map($.coords2String)\r\n\r\n\t\t\t\t//alter the node\r\n\t\t\t\tif (options.addPasses)\r\n\t\t\t\t\tnode[isBlack ? 'B' : 'W'] = ''\r\n\t\t\t\telse delete node[isBlack ? 'B' : 'W']\r\n\t\t\t\t// node[isBlack ? 'B' : 'W'] = ''\r\n\t\t\t\tnode[isBlack ? 'AB' : 'AW'] = toAdd\r\n\t\t\t\tif (toAdd.length > 0)\r\n\t\t\t\t\tnode.CR = toAdd\r\n\t\t\t\tif (toRemove.length > 0)\r\n\t\t\t\t\tnode.AE = toRemove\r\n\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\ttodo: other properties with board coordinates\r\n\t\t\t\t\t\tLeave for now:\r\n\t\t\t\t\t\tAR\r\n\t\t\t\t\t\tLN\r\n\t\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t\t;/*note this semicolon is needed! */\r\n\t\t\t\t[\r\n\t\t\t\t\t//'CR',todo: add if not marking the move\r\n\t\t\t\t\t'DD', 'MA', 'SL', 'SQ', 'TR'].forEach(function (sgfProperty) {\r\n\t\t\t\t\t\t// _.map(['DD','MA','SL','SQ','TR'], function(sgfProperty){\r\n\t\t\t\t\t\tif (node[sgfProperty] === undefined) return\r\n\t\t\t\t\t\tlet points = []\r\n\t\t\t\t\t\tif (Array.isArray(node[sgfProperty])) {\r\n\t\t\t\t\t\t\tpoints = node[sgfProperty]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tpoints = [node[sgfProperty]]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (node.SC && sgfProperty === 'MA') {\r\n\t\t\t\t\t\t\tstonesMarkedForScoring = { ...points }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpoints =\r\n\t\t\t\t\t\t\t// _.chain(points)\r\n\t\t\t\t\t\t\t// \t.map(translateCoordinates)\r\n\t\t\t\t\t\t\t// \t.map($.projectOnFlat)\r\n\t\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t\t// \t.map($.coords2String)\r\n\t\t\t\t\t\t\t// \t.value()\r\n\t\t\t\t\t\t\t_flatten(\r\n\t\t\t\t\t\t\t\tpoints\r\n\t\t\t\t\t\t\t\t\t.map(translateCoordinates)\r\n\t\t\t\t\t\t\t\t\t.map($.projectOnFlat)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t.map($.coords2String)\r\n\t\t\t\t\t\tnode[sgfProperty] = points\r\n\t\t\t\t\t})\r\n\t\t\t\tnode.MN = currentPath.m\r\n\r\n\t\t\t\t/*\r\n\t\t\t\tUse a custom, new SGF property, SC, in order to see if the current position should be scored, and if so, what to do with the score.\r\n\t\t\t\tIt’s a bit flag.  \r\n\t\t\t\t1\t⇒ update the comments for the node (succint). When flagged, the next option is not available.\r\n\t\t\t\t2\t⇒ update the comments for the node (verbose)\r\n\t\t\t\t4\t⇒ update the game result (RE) for the root node\r\n\t\t\t\tTypical usage: add “SC[6]” to the last node, and “SC[2]” to score a variation.\r\n\t\t\t\t*/\r\n\t\t\t\tlet updatedComment = false\r\n\t\t\t\tif (node.SC) {\r\n\t\t\t\t\tlet score = engine.score(stonesMarkedForScoring)\r\n\t\t\t\t\tif (node.SC & 1 === 1) {\r\n\t\t\t\t\t\tupdatedComment = true\r\n\t\t\t\t\t\tcomment(isPass, isBlack, score.RE)\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse /*don't want to treat succint and verbose at the same time*/ if (node.SC & 2 === 2) {\r\n\t\t\t\t\t\tupdatedComment = true\r\n\t\t\t\t\t\tcomment(isPass, isBlack,\r\n\t\t\t\t\t\t\t`Black: ${score.totalWhiteDead\r\n\t\t\t\t\t\t\t+ score.totalWhiteCaptured\r\n\t\t\t\t\t\t\t+ score.totalBlackTerritory} = ${score.totalBlackTerritory} territory + ${score.totalWhiteDead + score.totalWhiteCaptured} prisoners\r\nWhite: ${score.totalBlackDead\r\n\t\t\t\t\t\t\t+ score.totalBlackCaptured\r\n\t\t\t\t\t\t\t+ score.totalWhiteTerritory} = ${score.totalWhiteTerritory} territory + ${score.totalBlackDead + score.totalBlackCaptured} prisoners +${engine.rules.komi} komi`)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (node.SC & 4 === 4) {\r\n\t\t\t\t\t\twrappedGame.game.nodes[0].RE = score.RE\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!updatedComment)\r\n\t\t\t\t\tcomment(isPass, isBlack)\r\n\r\n\t\t\t\t// move to next node\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (options.transformToString)\r\n\t\t\treturn smartgame.generate({ gameTrees: [wrappedGame.game] });\r\n\t\telse return wrappedGame\r\n\t}\r\n\t$.transform = transform\r\n\treturn $\r\n\r\n}\r\nmodule.exports = transformer"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FkZE1hcEVudHJ5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19hZGRTZXRFbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbkluLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9zcmMvZW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hTi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmlxLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9ub29wLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91bmlxQnkuanMiLCJub2RlX21vZHVsZXMvc21hcnRnYW1lL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NtYXJ0Z2FtZXIvaW5kZXguanMiLCJzcmMvdHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybWVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0QsTUFBSSxRQUFRLGlCQUFaLEVBQ0MsT0FBTyxVQUFVLFFBQVYsQ0FBbUIsRUFBRSxXQUFXLENBQUMsWUFBWSxJQUFiLENBQWIsRUFBbkIsQ0FBUCxDQURELEtBRUssT0FBTyxXQUFQO0FBQ0w7QUFDRCxHQUFFLFNBQUYsR0FBYyxTQUFkO0FBQ0EsUUFBTyxDQUFQO0FBRUE7QUFDRCxPQUFPLE9BQVAsR0FBaUIsV0FBakIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gcGFpciBUaGUga2V5LXZhbHVlIHBhaXIgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAqL1xuZnVuY3Rpb24gYWRkTWFwRW50cnkobWFwLCBwYWlyKSB7XG4gIC8vIERvbid0IHJldHVybiBgbWFwLnNldGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gIHJldHVybiBtYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkTWFwRW50cnk7XG4iLCIvKipcbiAqIEFkZHMgYHZhbHVlYCB0byBgc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYHNldGAuXG4gKi9cbmZ1bmN0aW9uIGFkZFNldEVudHJ5KHNldCwgdmFsdWUpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBzZXQuYWRkYCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIHJldHVybiBzZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkU2V0RW50cnk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlSZWR1Y2U7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25JbjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ24nKSxcbiAgICBiYXNlQXNzaWduSW4gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduSW4nKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgY29weVN5bWJvbHMgPSByZXF1aXJlKCcuL19jb3B5U3ltYm9scycpLFxuICAgIGNvcHlTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19jb3B5U3ltYm9sc0luJyksXG4gICAgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpbml0Q2xvbmVBcnJheSA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUFycmF5JyksXG4gICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVCeVRhZycpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgYmFzZUNsb25lLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmluZEluZGV4O1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIGVxdWFsQnlUYWcgPSByZXF1aXJlKCcuL19lcXVhbEJ5VGFnJyksXG4gICAgZXF1YWxPYmplY3RzID0gcmVxdWlyZSgnLi9fZXF1YWxPYmplY3RzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG4iLCJ2YXIgYWRkTWFwRW50cnkgPSByZXF1aXJlKCcuL19hZGRNYXBFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgbWFwLlxuICovXG5mdW5jdGlvbiBjbG9uZU1hcChtYXAsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhtYXBUb0FycmF5KG1hcCksIENMT05FX0RFRVBfRkxBRykgOiBtYXBUb0FycmF5KG1hcCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkTWFwRW50cnksIG5ldyBtYXAuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lTWFwO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcbiIsInZhciBhZGRTZXRFbnRyeSA9IHJlcXVpcmUoJy4vX2FkZFNldEVudHJ5JyksXG4gICAgYXJyYXlSZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheVJlZHVjZScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU2V0KHNldCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKHNldFRvQXJyYXkoc2V0KSwgQ0xPTkVfREVFUF9GTEFHKSA6IHNldFRvQXJyYXkoc2V0KTtcbiAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRTZXRFbnRyeSwgbmV3IHNldC5jb25zdHJ1Y3Rvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTZXQ7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwidmFyIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lTWFwID0gcmVxdWlyZSgnLi9fY2xvbmVNYXAnKSxcbiAgICBjbG9uZVJlZ0V4cCA9IHJlcXVpcmUoJy4vX2Nsb25lUmVnRXhwJyksXG4gICAgY2xvbmVTZXQgPSByZXF1aXJlKCcuL19jbG9uZVNldCcpLFxuICAgIGNsb25lU3ltYm9sID0gcmVxdWlyZSgnLi9fY2xvbmVTeW1ib2wnKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBjbG9uZUZ1bmMsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lTWFwKG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVNldChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVCeVRhZztcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlTGVhZGluZ0RvdCA9IC9eXFwuLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAocmVMZWFkaW5nRG90LnRlc3Qoc3RyaW5nKSkge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi9fYmFzZUNsb25lJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZURlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEluZGV4O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRmluaXRlO1xuIiwidmFyIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSW50ZWdlcjtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCIvKiBnbG9iYWxzIG1vZHVsZTogZmFsc2UsIHJlcXVpcmU6IGZhbHNlICovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQndXNlIHN0cmljdCc7XHJcblx0bGV0IF9maSA9IHJlcXVpcmUoJ2xvZGFzaC9maW5kSW5kZXgnKVxyXG5cdFx0Ly8gLCBfaXNlcSA9IHJlcXVpcmUoJ2xvZGFzaC9pc0VxdWFsJylcclxuXHRcdCwgX2Nsb25lID0gcmVxdWlyZSgnbG9kYXNoL2Nsb25lJylcclxuXHRcdC8vdXRpbGl0aWVzXHJcblx0XHQvLyBjb25zdFxyXG5cclxuXHRcdCwgX2lzZXEgPSAoeCwgeSkgPT4ge1xyXG5cclxuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KHgpIHx8ICFBcnJheS5pc0FycmF5KHkpKSB7XHJcblx0XHRcdFx0cmV0dXJuIHggPT0geS8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcblx0XHRcdFx0Ly8gcmV0dXJuIHggPT09IHlcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSByZXR1cm4gZmFsc2VcclxuXHRcdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHgubGVuZ3RoOyBpbmRleCsrKSB7XHJcblx0XHRcdFx0aWYgKCFfaXNlcSh4W2luZGV4XSwgeVtpbmRleF0pKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2VcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWVcclxuXHJcblx0XHR9XHJcblx0XHQsIG15SW5kZXhPZiA9IChhLCBiKSA9PiB7XHJcblx0XHRcdHJldHVybiBfZmkoYSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIF9pc2VxKHgsIGIpIH0pO1xyXG5cdFx0fVxyXG5cdC8vIHRoaXMgdmVyc2lvbiwgd2l0aG91dCB0aGUgX2ZpIGRlcGVuZGVuY3ksIGRvZXNuJ3Qgd29yayF0b2RvXHJcblx0Ly8gICwgbXlJbmRleE9mID0gKGFycmF5LCBpdGVtKSA9PiB7XHJcblx0Ly8gXHRcdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheS5sZW5ndGg7IGluZGV4KyspIHtcclxuXHQvLyBcdFx0XHRpZiAoX2lzZXEoYXJyYXlbaW5kZXhdLCBpdGVtKSkge1xyXG5cdC8vIFx0XHRcdFx0cmV0dXJuIGluZGV4O1xyXG5cclxuXHQvLyBcdFx0XHR9XHJcblx0Ly8gXHRcdFx0cmV0dXJuIC0xO1xyXG5cdC8vIFx0XHR9XHJcblxyXG5cdC8vIFx0fVxyXG5cclxuXHQvLyBcdCwgX2Nsb25lID0gcmVxdWlyZSgnbG9kYXNoL2Nsb25lJylcclxuXHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XHJcblx0Ly8gYm9hcmRNb2RlID0gb3B0aW9ucy5ib2FyZE1vZGUgfHwgJ3QnLyp0OnRvcm9pZDsgYzpjbGFzc2ljIOKApiovXHJcblx0Ly8gLCBib2FyZERpbWVuc2lvbnMgPSBvcHRpb25zLmJvYXJkRGltZW5zaW9ucyB8fCBbMTEsIDExXS8qbW92ZSBsYXRlciovXHJcblx0Ly8gLCBydWxlcyA9IG9wdGlvbnMucnVsZXMgfHwge1xyXG5cdC8vIHN1aWNpZGU6IHRydWUsXHJcblx0Ly8gc3VwZXJrbzogZmFsc2VcclxuXHQvLyB9XHJcblx0bGV0ICQgPSB7fVxyXG5cdC8vLy9wcm9ibGVtIHdpdGggdGhlIG9iamVjdCBzcHJlYWQgb3BlcmF0b3IgYW5kIHRoZSBidWlsZCBzbyB1c2luZyBPYmplY3QuYXNzaWduIGluc3RlYWQuXHJcblx0Ly8gJC5ydWxlcyA9IHtcclxuXHQvLyBcdFx0c3VpY2lkZTogdHJ1ZSxcclxuXHQvLyBcdFx0Ly8gc3VwZXJrbzogZmFsc2UgLyrih5J0b2RvOiBlbmZvcmNlIHdoZW4gdHJ1ZT8qLyxcclxuXHQvLyBcdFx0a29taTogNy41LFxyXG5cdC8vIFx0XHQuLi4gb3B0aW9ucy5ydWxlc1xyXG5cdC8vIFx0fVxyXG5cdCQucnVsZXMgPSBPYmplY3QuYXNzaWduKHt9LCB7XHJcblx0XHRzdWljaWRlOiB0cnVlLFxyXG5cdFx0Ly8gc3VwZXJrbzogZmFsc2UgLyrih5J0b2RvOiBlbmZvcmNlIHdoZW4gdHJ1ZT8qLyxcclxuXHRcdGtvbWk6IDcuNSxcclxuXHR9LCBvcHRpb25zLnJ1bGVzKVxyXG5cclxuXHQvLyAkLm1vdmVzID0gb3B0aW9ucy5tb3ZlcyB8fCBbXVxyXG5cdCQub3B0aW9ucyA9IG9wdGlvbnNcclxuXHRvcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zIHx8IFsxMSwgMTFdXHJcblx0b3B0aW9ucy5ib2FyZE1vZGUgPSBvcHRpb25zLmJvYXJkTW9kZSB8fCAndCcvKnQ6dG9yb2lkOyBjOmNsYXNzaWMg4oCmKi9cclxuXHQkLmJvYXJkID0ge31cclxuXHQkLmJvYXJkLmJsYWNrU3RvbmVzID0gb3B0aW9ucy5ibGFja1N0b25lcyB8fCBbXVxyXG5cdCQuYm9hcmQud2hpdGVTdG9uZXMgPSBvcHRpb25zLndoaXRlU3RvbmVzIHx8IFtdXHJcblxyXG5cdCQuYm9hcmQubmV4dFBsYXllciA9IG9wdGlvbnMubmV4dFBsYXllciB8fCBcImJcIlxyXG5cdCQuYm9hcmQuY2FwdHVyZWQgPSBvcHRpb25zLmNhcHR1cmVkIHx8IFswLCAwXVxyXG5cclxuXHQkLmV4cG9ydERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRibGFja1N0b25lczogJC5ib2FyZC5ibGFja1N0b25lcy5tYXAoX2Nsb25lKSxcclxuXHJcblx0XHRcdHdoaXRlU3RvbmVzOiAkLmJvYXJkLndoaXRlU3RvbmVzLm1hcChfY2xvbmUpLFxyXG5cdFx0XHRjYXB0dXJlZDogX2Nsb25lKCQuYm9hcmQuY2FwdHVyZWQpLFxyXG5cdFx0XHRuZXh0UGxheWVyOiAkLmJvYXJkLm5leHRQbGF5ZXJcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdCQubG9hZERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdFx0JC5ib2FyZC5ibGFja1N0b25lcyA9IGRhdGEuYmxhY2tTdG9uZXNcclxuXHRcdCQuYm9hcmQud2hpdGVTdG9uZXMgPSBkYXRhLndoaXRlU3RvbmVzXHJcblx0XHQkLmJvYXJkLmNhcHR1cmVkID0gZGF0YS5jYXB0dXJlZFxyXG5cdFx0JC5ib2FyZC5uZXh0UGxheWVyID0gZGF0YS5uZXh0UGxheWVyXHJcblx0fVxyXG5cclxuXHQvL3Rvcm9pZFxyXG5cdGlmIChvcHRpb25zLmJvYXJkTW9kZSA9PT0gJ3QnKSAkLmJvYXJkLmdldE5laWdoYm91cnMgPVxyXG5cdFx0ZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRcdGxldCByZXN1bHQgPSBbXVxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG5cdFx0XHRcdGxldCBuZXdQb2ludFxyXG5cdFx0XHRcdHN3aXRjaCAoaSkge1xyXG5cdFx0XHRcdFx0Y2FzZSAwOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSArIDEsIHBvaW50WzFdXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSAtIDEsIHBvaW50WzFdXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSwgcG9pbnRbMV0gKyAxXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAzOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSwgcG9pbnRbMV0gLSAxXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXN1bHQucHVzaChbKG5ld1BvaW50WzBdICsgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0pICUgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0sIChuZXdQb2ludFsxXSArIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdKSAlIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdXSlcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0XHJcblx0XHR9XHJcblx0aWYgKG9wdGlvbnMuYm9hcmRNb2RlID09PSAnYycpICQuYm9hcmQuZ2V0TmVpZ2hib3VycyA9XHJcblx0XHRmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdFx0bGV0IHJlc3VsdCA9IFtdXHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IG5ld1BvaW50XHJcblx0XHRcdFx0c3dpdGNoIChpKSB7XHJcblx0XHRcdFx0XHRjYXNlIDA6XHJcblx0XHRcdFx0XHRcdG5ld1BvaW50ID0gW3BvaW50WzBdICsgMSwgcG9pbnRbMV1dXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHRjYXNlIDE6XHJcblx0XHRcdFx0XHRcdG5ld1BvaW50ID0gW3BvaW50WzBdIC0gMSwgcG9pbnRbMV1dXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHRjYXNlIDI6XHJcblx0XHRcdFx0XHRcdG5ld1BvaW50ID0gW3BvaW50WzBdLCBwb2ludFsxXSArIDFdXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHRjYXNlIDM6XHJcblx0XHRcdFx0XHRcdG5ld1BvaW50ID0gW3BvaW50WzBdLCBwb2ludFsxXSAtIDFdXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChuZXdQb2ludFswXSA+PSAwICYmIG5ld1BvaW50WzBdIDwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF1cclxuXHRcdFx0XHRcdCYmIG5ld1BvaW50WzFdID49IDAgJiYgbmV3UG9pbnRbMV0gPCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXVxyXG5cdFx0XHRcdClcclxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKG5ld1BvaW50KVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiByZXN1bHRcclxuXHRcdH1cclxuXHQvL3RvZG86IGtsZWluLCBwcm9qZWN0aXZlIHBsYW5lLCDigKZcclxuXHJcblx0JC5ib2FyZC5pc0VtcHR5ID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbXlJbmRleE9mKCQuYm9hcmQuYmxhY2tTdG9uZXMsIHBvaW50KSA8IDBcclxuXHRcdFx0JiYgbXlJbmRleE9mKCQuYm9hcmQud2hpdGVTdG9uZXMsIHBvaW50KSA8IDBcclxuXHR9XHJcblx0JC5ib2FyZC5nZXRDb2xvdXIgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdGlmIChteUluZGV4T2YoJC5ib2FyZC5ibGFja1N0b25lcywgcG9pbnQpID49IDApIHJldHVybiAnYidcclxuXHRcdGlmIChteUluZGV4T2YoJC5ib2FyZC53aGl0ZVN0b25lcywgcG9pbnQpID49IDApIHJldHVybiAndydcclxuXHRcdHJldHVybiAnZSdcclxuXHR9XHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lcyBpZiBhIHBvaW50IGlzIHBhcnQgb2YgYSBjaGFpbiB3aXRoIGEgbGliZXJ0eTsgaWYgdGhlcmUgYXJlIG5vIGxpYmVydGllcyB0aGVuIGl0IHJldHVybnMgdGhlIGNoYWluIG9mIHN0b25lcyBvZiB0aGUgc2FtZSBjb2xvdXIgdGhhdCBhcmUgY29ubmVjdGVkIHRvIGBzdGFydFBvaW50YC4gQWxzbyB1c2VkIGZvciBjb3VudGluZyB0byByZXR1cm4gY29ubmVjdGVkIGNvbXBvbmVudHMgb2Ygc2FtZSBjb2xvdXIgKGJsYWNrLCB3aGl0ZSBvciBlbXB0eSkuXHJcblx0ICogQHBhcmFtIHsqfSBzdGFydFBvaW50IFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGNoYWluQ29sb3VyIGluZGljYXRlcyB0aGUgY29sb3VyIG9mIHRoZSBzdGFydGluZyBwb2ludC5cclxuXHQgKiBAcGFyYW0geyp9IFtzdG9wQ29sb3VyPSdlJ10gc3RvcCB3b3JraW5nIGlmIHRoZSBjaGFpbiBtZWV0cyB0aGlzIGNvbG91clxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZXRDb2xvdXI9JC5ib2FyZC5nZXRDb2xvdXJdIEZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBjb2xvdXIgb2YgYSBwb2ludC5cclxuXHQgKiBAcmV0dXJucyB7Ym9vbHxhcnJheX0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRoZSBjb21wb25lbnQgbWVldHMgYHN0b3BDb2xvdXJgLCBhbmQgYW4gYXJyYXkgY29udGFpbmluZyBjb25uZWN0ZWQgY29tcG9uZW50IG9mIHBvaW50cyBsaW5rZWQgdG8gYHN0YXJ0UG9pbnRgIG90aGVyd2lzZS4gXHJcblx0ICovXHRcclxuXHRmdW5jdGlvbiBjaGFpbkhhc0xpYmVydHkgKHN0YXJ0UG9pbnQsIGNoYWluQ29sb3VyLCBzdG9wQ29sb3VyLCBnZXRDb2xvdXIpIHtcclxuXHRcdGlmIChzdG9wQ29sb3VyID09PSB1bmRlZmluZWQpXHJcblx0XHRcdHN0b3BDb2xvdXIgPSAnZScvL2J5IGRlZmF1bHQsIHN0b3AgZ2V0dGluZyB0aGUgY2hhaW4gd2hlbiB0aGVyZSBpcyBhIGxpYmVydHkuXHJcblx0XHRpZiAoZ2V0Q29sb3VyID09PSB1bmRlZmluZWQpXHJcblx0XHRcdGdldENvbG91ciA9ICQuYm9hcmQuZ2V0Q29sb3VyLy9ieSBkZWZhdWx0LCB1c2UgdGhlIHVzdWFsIGJvYXJkIGNvbG91ciBmdW5jdGlvblxyXG5cclxuXHRcdGlmIChjaGFpbkNvbG91ciA9PT0gbnVsbClcclxuXHRcdFx0Y2hhaW5Db2xvdXIgPSBnZXRDb2xvdXIoc3RhcnRQb2ludClcclxuXHRcdGxldFxyXG5cdFx0XHRjaGFpbiA9IFtzdGFydFBvaW50XVxyXG5cdFx0XHQsIHRvRXhwbG9yZSA9IFtdXHJcblx0XHRcdCwgcG9pbnQgPSBzdGFydFBvaW50IC8vYXNzdW1lZCB0byBiZSBvZiBjb2xvdXIgY2hhaW5Db2xvdXJcclxuXHJcblx0XHR3aGlsZSAocG9pbnQgIT09IHVuZGVmaW5lZCkge1xyXG5cclxuXHRcdFx0bGV0IG5laWdoYm91cnMgPSAkLmJvYXJkLmdldE5laWdoYm91cnMocG9pbnQpXHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3Vycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGxldCBuZXdQb2ludCA9IG5laWdoYm91cnNbaV0sXHJcblx0XHRcdFx0XHRuZXdDb2xvdXIgPSBnZXRDb2xvdXIobmV3UG9pbnQpXHJcblx0XHRcdFx0aWYgKG5ld0NvbG91ciA9PT0gc3RvcENvbG91cikgcmV0dXJuIHRydWU7XHJcblx0XHRcdFx0aWYgKG5ld0NvbG91ciA9PT0gY2hhaW5Db2xvdXIpIHtcclxuXHRcdFx0XHRcdGlmIChteUluZGV4T2YoY2hhaW4sIG5ld1BvaW50KSA8IDApIHtcclxuXHRcdFx0XHRcdFx0Y2hhaW4ucHVzaChuZXdQb2ludClcclxuXHRcdFx0XHRcdFx0Ly8gaWYgKG15SW5kZXhPZih0b0V4cGxvcmUsIG5ld1BvaW50KSA8IDApXHJcblx0XHRcdFx0XHRcdHRvRXhwbG9yZS5wdXNoKG5ld1BvaW50KVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRwb2ludCA9IHRvRXhwbG9yZS5wb3AoKVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjaGFpbjtcclxuXHR9XHJcblxyXG5cdCQuYm9hcmQuY2hhaW5IYXNMaWJlcnR5ID0gY2hhaW5IYXNMaWJlcnR5IFxyXG5cclxuXHQkLmJvYXJkLnNjb3JlID0gZnVuY3Rpb24gKGRlYWRTdG9uZXMpIHtcclxuXHRcdC8qXHJcblx0XHRnbyB0aHJvdWdoIHRoZSB3aG9sZSBib2FyZCBcclxuXHRcdCovXHJcblx0XHRpZiAoZGVhZFN0b25lcyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGRlYWRTdG9uZXMgPSBbXVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZXN1bHQgPSB7XHJcblx0XHRcdGJsYWNrRW1wdHk6IFtdXHJcblx0XHRcdCwgd2hpdGVFbXB0eTogW11cclxuXHRcdFx0LCBkYW1lOiBbXVxyXG5cdFx0XHQsIGJsYWNrQWxpdmU6IFtdXHJcblx0XHRcdCwgd2hpdGVBbGl2ZTogW11cclxuXHRcdFx0LCBibGFja0RlYWQ6IFtdXHJcblx0XHRcdCwgd2hpdGVEZWFkOiBbXVxyXG5cdFx0XHQsIHRvdGFsQmxhY2tDYXB0dXJlZDogJC5ib2FyZC5jYXB0dXJlZFswXSAvL25iIEIgc3RvbmVzIHJlbW92ZWQgYnkgVyBkdXJpbmcgdGhlIGdhbWVcclxuXHRcdFx0LCB0b3RhbFdoaXRlQ2FwdHVyZWQ6ICQuYm9hcmQuY2FwdHVyZWRbMV0gLy9uYiBXIHN0b25lcyByZW1vdmVkIGJ5IEIgZHVyaW5nIHRoZSBnYW1lXHJcblx0XHRcdC8vdG9kbzpjb3VsZCByZXBsYWNlIGJ5IGFuIGNsYXNzLiBkYXRhIHN0b3JlZCBpbiBhIGJpZyBhcnJheSBvZiBwYWlycyBbcG9pbnQsIHN0YXR1c11cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZGVhZFN0b25lcy5sZW5ndGg7IGluZGV4KyspIHtcclxuXHRcdFx0Y29uc3QgZGVhZFN0b25lID0gZGVhZFN0b25lc1tpbmRleF07XHJcblx0XHRcdGxldCBkZWFkQ29sb3VyID0gJC5ib2FyZC5nZXRDb2xvdXIoZGVhZFN0b25lKVxyXG5cdFx0XHRpZiAoZGVhZENvbG91ciA9PT0gJ2UnKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWFya2VkIGRlYWQgc3RvbmUnKVxyXG5cdFx0XHRsZXRcclxuXHRcdFx0XHRkZWFkVG9GaWxsID0gZGVhZENvbG91ciA9PT0gJ2InID8gcmVzdWx0LmJsYWNrRGVhZCA6IHJlc3VsdC53aGl0ZURlYWRcclxuXHRcdFx0XHQsIGVtcHR5VG9GaWxsID0gZGVhZENvbG91ciA9PT0gJ2InID8gcmVzdWx0LndoaXRlRW1wdHkgOiByZXN1bHQuYmxhY2tFbXB0eVxyXG5cdFx0XHRcdCwgYWxpdmVUb0ZpbGwgPSBkZWFkQ29sb3VyID09PSAnYicgPyByZXN1bHQud2hpdGVBbGl2ZSA6IHJlc3VsdC5ibGFja0FsaXZlXHJcblx0XHRcdFx0LCBwcm9jZXNzUG9pbnQgPSAocG9pbnQsIGNvbG91cikgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGNvbG91ciA9PT0gZGVhZENvbG91ciAmJiBteUluZGV4T2YoZGVhZFRvRmlsbCwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRkZWFkVG9GaWxsLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHRcdGVtcHR5VG9GaWxsLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoKGNvbG91ciA9PT0gZGVhZENvbG91ciB8fCBjb2xvdXIgPT09ICdlJykgJiYgbXlJbmRleE9mKGVtcHR5VG9GaWxsLCBwb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdGVtcHR5VG9GaWxsLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoY29sb3VyICE9PSBkZWFkQ29sb3VyICYmIGNvbG91ciAhPT0gJ2UnICYmIG15SW5kZXhPZihhbGl2ZVRvRmlsbCwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRhbGl2ZVRvRmlsbC5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQsIGdldENvbG91ckZvckRlYWRDb21wb25lbnQgPSAocG9pbnQpID0+IHtcclxuXHRcdFx0XHRcdGxldCBjb2xvdXIgPSAkLmJvYXJkLmdldENvbG91cihwb2ludClcclxuXHRcdFx0XHRcdHByb2Nlc3NQb2ludChwb2ludCwgY29sb3VyKVxyXG5cdFx0XHRcdFx0cmV0dXJuIGNvbG91ciA9PT0gZGVhZENvbG91ciA/ICdlJyA6IGNvbG91clxyXG5cdFx0XHRcdH1cclxuXHRcdFx0cHJvY2Vzc1BvaW50KGRlYWRTdG9uZSwgZGVhZENvbG91cilcclxuXHRcdFx0JC5ib2FyZC5jaGFpbkhhc0xpYmVydHkoZGVhZFN0b25lLCAnZScsICcnLCBnZXRDb2xvdXJGb3JEZWFkQ29tcG9uZW50KVxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwLGV4aXRMb29wID0gZmFsc2U7IGkgPCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXTsgaSsrKSB7XHJcblx0XHRcdGlmIChleGl0TG9vcCkge1xyXG5cdFx0XHRcdGJyZWFrXHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXTsgaisrKSB7XHJcblx0XHRcdFx0aWYgKHJlc3VsdC5ibGFja0VtcHR5Lmxlbmd0aFxyXG5cdFx0XHRcdFx0KyByZXN1bHQud2hpdGVFbXB0eS5sZW5ndGhcclxuXHRcdFx0XHRcdCsgcmVzdWx0LmRhbWUubGVuZ3RoXHJcblx0XHRcdFx0XHQrIHJlc3VsdC5ibGFja0FsaXZlLmxlbmd0aFxyXG5cdFx0XHRcdFx0KyByZXN1bHQud2hpdGVBbGl2ZS5sZW5ndGhcclxuXHRcdFx0XHRcdC8vICsgcmVzdWx0LmJsYWNrRGVhZC5sZW5ndGhcclxuXHRcdFx0XHRcdC8vICsgcmVzdWx0LndoaXRlRGVhZC5sZW5ndGhcclxuXHRcdFx0XHRcdD09PSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXSAqIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdXHJcblx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRleGl0TG9vcCA9IHRydWVcclxuXHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gW2ksIGpdLCBjb2xvdXIgPSAkLmJvYXJkLmdldENvbG91cihwb2ludClcclxuXHJcblx0XHRcdFx0aWYgKGNvbG91ciA9PT0gJ2InXHJcblx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRpZiAobXlJbmRleE9mKHJlc3VsdC5ibGFja0FsaXZlLCBwb2ludCkgPCAwXHJcblx0XHRcdFx0XHRcdCYmIG15SW5kZXhPZihyZXN1bHQuYmxhY2tEZWFkLCBwb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdC5ibGFja0FsaXZlLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHR9IGVsc2UgY29udGludWVcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGNvbG91ciA9PT0gJ3cnKSB7XHJcblx0XHRcdFx0XHRpZiAobXlJbmRleE9mKHJlc3VsdC53aGl0ZUFsaXZlLCBwb2ludCkgPCAwXHJcblx0XHRcdFx0XHRcdCYmIG15SW5kZXhPZihyZXN1bHQud2hpdGVEZWFkLCBwb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdC53aGl0ZUFsaXZlLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHR9IGVsc2UgY29udGludWVcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjb2xvdXIgPT09ICdlJykge1xyXG5cdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQuYmxhY2tFbXB0eSwgcG9pbnQpID49IDBcclxuXHRcdFx0XHRcdFx0fHwgbXlJbmRleE9mKHJlc3VsdC53aGl0ZUVtcHR5LCBwb2ludCkgPj0gMFxyXG5cdFx0XHRcdFx0XHR8fCBteUluZGV4T2YocmVzdWx0LmRhbWUsIHBvaW50KSA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0XHJcblx0XHRcdFx0XHRcdG1lZXRzQmxhY2sgPSBmYWxzZVxyXG5cdFx0XHRcdFx0XHQsIG1lZXRzV2hpdGUgPSBmYWxzZVxyXG5cdFx0XHRcdFx0XHQsIGlzQmxhY2tUZXJyaXRvcnkgPSBmYWxzZVxyXG5cdFx0XHRcdFx0XHQsIGlzV2hpdGVUZXJyaXRvcnkgPSBmYWxzZVxyXG5cdFx0XHRcdFx0XHQsIGdldENvbG91ckZvclNjb3JpbmcgPSAocG9pbnQpID0+IHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bGV0IGNvbG91ciA9ICQuYm9hcmQuZ2V0Q29sb3VyKHBvaW50KVxyXG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAoY29sb3VyKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdiJzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQuYmxhY2tEZWFkLCBwb2ludCkgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbG91ciA9ICdlJ1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlzV2hpdGVUZXJyaXRvcnkgPSB0cnVlXHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bWVldHNCbGFjayA9IHRydWVcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobXlJbmRleE9mKHJlc3VsdC5ibGFja0FsaXZlLCBwb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQuYmxhY2tBbGl2ZS5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3cnOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAobXlJbmRleE9mKHJlc3VsdC53aGl0ZURlYWQsIHBvaW50KSA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sb3VyID0gJ2UnXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aXNCbGFja1RlcnJpdG9yeSA9IHRydWVcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRtZWV0c1doaXRlID0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChteUluZGV4T2YocmVzdWx0LndoaXRlQWxpdmUsIHBvaW50KSA8IDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC53aGl0ZUFsaXZlLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6Ly9ub3RoaW5nIG5lZWRlZCBmb3IgJ2UnXHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY29sb3VyXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxldCBlbXB0eUNvbXBvbmVudCA9ICQuYm9hcmQuY2hhaW5IYXNMaWJlcnR5KHBvaW50LCAnZScsICcnLCBnZXRDb2xvdXJGb3JTY29yaW5nKVxyXG5cdFx0XHRcdFx0aWYgKCFtZWV0c0JsYWNrICYmICFtZWV0c1doaXRlKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignY291bnRpbmcgYW4gZW1wdHkgYm9hcmQhJylcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChpc0JsYWNrVGVycml0b3J5ICYmIGlzV2hpdGVUZXJyaXRvcnkpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCd0b28gbWFueSBzdG9uZXMgbWFya2VkIGFzIGRlYWQnKVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly9jb3VsZCBzdG9yZSB0aGUgZGlmZmVyZW50IGVtcHR5IGNvbXBvbmVudHM6IFYyIFxyXG5cdFx0XHRcdFx0aWYgKG1lZXRzQmxhY2sgJiYgbWVldHNXaGl0ZSkge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQuZGFtZSA9IHJlc3VsdC5kYW1lLmNvbmNhdChlbXB0eUNvbXBvbmVudClcclxuXHRcdFx0XHRcdFx0Y29udGludWVcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChtZWV0c0JsYWNrKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdC5ibGFja0VtcHR5ID0gcmVzdWx0LmJsYWNrRW1wdHkuY29uY2F0KGVtcHR5Q29tcG9uZW50KVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKG1lZXRzV2hpdGUpIHtcclxuXHRcdFx0XHRcdFx0cmVzdWx0LndoaXRlRW1wdHkgPSByZXN1bHQud2hpdGVFbXB0eS5jb25jYXQoZW1wdHlDb21wb25lbnQpXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvL3RvdGFsc1xyXG5cdFx0cmVzdWx0LnRvdGFsQmxhY2tEZWFkID0gcmVzdWx0LmJsYWNrRGVhZC5sZW5ndGhcclxuXHRcdHJlc3VsdC50b3RhbFdoaXRlRGVhZCA9IHJlc3VsdC53aGl0ZURlYWQubGVuZ3RoXHJcblx0XHRyZXN1bHQudG90YWxCbGFja1RlcnJpdG9yeSA9IHJlc3VsdC5ibGFja0VtcHR5Lmxlbmd0aFxyXG5cdFx0cmVzdWx0LnRvdGFsV2hpdGVUZXJyaXRvcnkgPSByZXN1bHQud2hpdGVFbXB0eS5sZW5ndGhcclxuXHJcblxyXG5cdFx0Ly90b2RvOiBpbXBsZW1lbnQgb3RoZXIgcnVsZXNldHMuIEZvciBub3csIGp1c3QgZG8gdGVycml0b3J5ICsgcHJpc29uZXJzIChKYXBhbmVzZSBzdHlsZSBjb3VudGluZylcclxuXHRcdHJlc3VsdC5ibGFja1Njb3JlID1cclxuXHRcdFx0cmVzdWx0LnRvdGFsV2hpdGVEZWFkXHJcblx0XHRcdCsgcmVzdWx0LnRvdGFsV2hpdGVDYXB0dXJlZFxyXG5cdFx0XHQrIHJlc3VsdC50b3RhbEJsYWNrVGVycml0b3J5XHJcblx0XHRyZXN1bHQud2hpdGVTY29yZSA9XHJcblx0XHRcdHJlc3VsdC50b3RhbEJsYWNrRGVhZFxyXG5cdFx0XHQrIHJlc3VsdC50b3RhbEJsYWNrQ2FwdHVyZWRcclxuXHRcdFx0KyByZXN1bHQudG90YWxXaGl0ZVRlcnJpdG9yeVxyXG5cdFx0XHQrICQucnVsZXMua29taVxyXG5cdFx0bGV0IHIgPSByZXN1bHQuYmxhY2tTY29yZSAtIHJlc3VsdC53aGl0ZVNjb3JlXHJcblx0XHRpZiAociA9PT0gMCkgcmVzdWx0LlJFID0gJzAnXHJcblx0XHRlbHNlIGlmIChyID4gMCkgcmVzdWx0LlJFID0gJ0IrJyArIHJcclxuXHRcdGVsc2UgcmVzdWx0LlJFID0gJ1crJyArICgtcilcclxuXHRcdHJldHVybiByZXN1bHRcclxuXHR9XHJcblxyXG5cdCQuYm9hcmQuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHQkLmJvYXJkLndoaXRlU3RvbmVzID0gW11cclxuXHRcdCQuYm9hcmQuYmxhY2tTdG9uZXMgPSBbXVxyXG5cdFx0JC5ib2FyZC5jYXB0dXJlZCA9IFswLCAwXVxyXG5cclxuXHR9XHJcblxyXG5cdCQucmVtb3ZlQ2hhaW4gPSBmdW5jdGlvbiAoY2hhaW4sIGNvbG91cikge1xyXG5cdFx0bGV0IHRvUmVtb3ZlRnJvbSA9IGNvbG91ciA9PT0gJ3cnID8gJC5ib2FyZC53aGl0ZVN0b25lcyA6ICQuYm9hcmQuYmxhY2tTdG9uZXNcclxuXHRcdGZvciAobGV0IGogPSAwOyBqIDwgY2hhaW4ubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0bGV0IGluZGV4ID0gbXlJbmRleE9mKHRvUmVtb3ZlRnJvbSwgY2hhaW5bal0pXHJcblx0XHRcdHRvUmVtb3ZlRnJvbS5zcGxpY2UoaW5kZXgsIDEpXHJcblx0XHRcdGlmIChjb2xvdXIgPT09ICd3JykgJC5ib2FyZC5jYXB0dXJlZFsxXSA9ICQuYm9hcmQuY2FwdHVyZWRbMV0gKyAxXHJcblx0XHRcdGVsc2UgJC5ib2FyZC5jYXB0dXJlZFswXSA9ICQuYm9hcmQuY2FwdHVyZWRbMF0gKyAxXHJcblx0XHR9XHJcblx0fVxyXG5cdCQucGxheSA9IGZ1bmN0aW9uIChwbGF5ZXJDb2xvdXIsIHBvaW50KSB7XHJcblxyXG5cclxuXHJcblx0XHQvLyBsZXQgcmVzdWx0ID0gXCJva1wiXHJcblx0XHRpZiAoISQuYm9hcmQuaXNFbXB0eShwb2ludCkpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigncG9pbnQgaXMgbm90IGVtcHR5JylcclxuXHRcdC8vIGNvbnNvbGUubG9nKCdwb2ludCBpcyBub3QgZW1wdHknICsgcG9pbnQpXHJcblxyXG5cdFx0aWYgKHBsYXllckNvbG91ciA9PT0gJ2InKSAkLmJvYXJkLmJsYWNrU3RvbmVzLnB1c2gocG9pbnQpXHJcblx0XHRlbHNlICQuYm9hcmQud2hpdGVTdG9uZXMucHVzaChwb2ludClcclxuXHJcblx0XHRsZXQgbmVpZ2hib3VycyA9ICQuYm9hcmQuZ2V0TmVpZ2hib3Vycyhwb2ludClcclxuXHRcdFx0LCByZW1vdmVkID0gW10vL2NoYWlucyByZW1vdmVkXHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuZWlnaGJvdXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBuZWlnaGJvdXIgPSBuZWlnaGJvdXJzW2ldLCBjb2xvdXIgPSAkLmJvYXJkLmdldENvbG91cihuZWlnaGJvdXIpXHJcblx0XHRcdGlmIChjb2xvdXIgPT09IHBsYXllckNvbG91ciB8fCBjb2xvdXIgPT09ICdlJykgY29udGludWVcclxuXHRcdFx0bGV0IG9wcENvbG91ciA9ICQuZ2V0T3Bwb3NpdGVDb2xvdXIocGxheWVyQ29sb3VyKSxcclxuXHRcdFx0XHRyID0gJC5ib2FyZC5jaGFpbkhhc0xpYmVydHkobmVpZ2hib3VyLCBvcHBDb2xvdXIpXHJcblx0XHRcdGlmIChyID09PSB0cnVlKSBjb250aW51ZVxyXG5cdFx0XHQvLy8vcmVtb3ZlIC0gbm8gbGliZXJ0aWVzXHJcblx0XHRcdHJlbW92ZWRbcmVtb3ZlZC5sZW5ndGhdID0gclxyXG5cclxuXHRcdFx0JC5yZW1vdmVDaGFpbihyLCBvcHBDb2xvdXIpXHJcblxyXG5cdFx0XHQvLyBsZXQgY2hhaW5Ub1JlbW92ZSA9IHJbMV0sXHJcblx0XHRcdC8vIHRvUmVtb3ZlRnJvbSA9IHBsYXllckNvbG91ciA9PT0gJ2InID8gJC5ib2FyZC53aGl0ZVN0b25lcyA6ICQuYm9hcmQuYmxhY2tTdG9uZXNcclxuXHRcdFx0Ly8gZm9yIChsZXQgaiA9IDA7IGo8Y2hhaW5Ub1JlbW92ZS5sZW5ndGg7IGorKylcclxuXHRcdFx0Ly8ge1xyXG5cdFx0XHQvLyBsZXQgaW5kZXggPSBteUluZGV4T2YodG9SZW1vdmVGcm9tLGNoYWluVG9SZW1vdmVbal0pXHJcblx0XHRcdC8vIHRvUmVtb3ZlRnJvbS5zcGxpY2UoaW5kZXgsIDEpXHJcblx0XHRcdC8vIGlmIChwbGF5ZXJDb2xvdXIgPT09ICdiJykgJC5ib2FyZC5jYXB0dXJlZFsxXSA9ICQuYm9hcmQuY2FwdHVyZWRbMV0gKyAxXHJcblx0XHRcdC8vIGVsc2UgJC5ib2FyZC5jYXB0dXJlZFswXSA9ICQuYm9hcmQuY2FwdHVyZWRbMF0gKyAxXHJcblx0XHRcdC8vIH1cclxuXHRcdFx0Ly8gcmVtb3ZlZCA9IHRydWVcclxuXHRcdH1cclxuXHRcdGxldCBzdWljaWRlID0gZmFsc2VcclxuXHRcdGlmIChyZW1vdmVkLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRsZXQgcyA9ICQuYm9hcmQuY2hhaW5IYXNMaWJlcnR5KHBvaW50LCBwbGF5ZXJDb2xvdXIpXHJcblx0XHRcdGlmIChzICE9PSB0cnVlKSB7XHJcblx0XHRcdFx0aWYgKCQucnVsZXMuc3VpY2lkZSkge1xyXG5cdFx0XHRcdFx0JC5yZW1vdmVDaGFpbihzLCBwbGF5ZXJDb2xvdXIpXHJcblx0XHRcdFx0XHRzdWljaWRlID0gc1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignc3VpY2lkZScpLy9pc27igJl0IGFsbG93ZWRcclxuXHRcdFx0XHRcdC8vdG9kbzogcmVtb3ZlIHBvaW50IGZyb20gd2hpdGVTdG9uZXMgb3IgYmxhY2tTdG9uZXNcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvKlxyXG5cdFx0XHRzdG9yaW5nIHRoZSBzaXR1YXRpb24gaW4gbWVtb3J5IC0gd291bGQgYmUgdXNlZnVsIHdoZW4gaW1wbGVtZW50aW5nIGdvaW5nIGJhY2sgYSBtb3ZlLCBzdXBlcmtvLCDigKZcclxuXHRcdFx0bm90IG5lZWRlZCBmb3Igbm93XHJcblx0XHQqL1xyXG5cdFx0Ly8kLm1vdmVzLnB1c2goW3BsYXllckNvbG91cixwb2ludCxfLmNsb25lKCQuYm9hcmQud2hpdGVTdG9uZXMpLF8uY2xvbmUoJC5ib2FyZC5ibGFja1N0b25lcyldKVxyXG5cdFx0Ly8gJC5tb3Zlcy5wdXNoKFtwbGF5ZXJDb2xvdXIscG9pbnRdKVxyXG5cclxuXHRcdC8vIGdldE5laWdoYm91cnNbaV0gPSBbZ2V0TmVpZ2hib3Vyc1tpXSwgJC5ib2FyZC5nZXRDb2xvdXJbZ2V0TmVpZ2hib3Vyc1tpXV1cclxuXHRcdC8vIC8v4oCmXHJcblxyXG5cclxuXHRcdHJldHVybiB7IHJlbW92ZWQsIHN1aWNpZGUgfVxyXG5cdH1cclxuXHQkLmdldE9wcG9zaXRlQ29sb3VyID0gZnVuY3Rpb24gKGNvbG91cikge1xyXG5cdFx0c3dpdGNoIChjb2xvdXIpIHtcclxuXHRcdFx0Y2FzZSAnYic6XHJcblx0XHRcdFx0cmV0dXJuICd3J1xyXG5cdFx0XHRjYXNlICd3JzpcclxuXHRcdFx0XHRyZXR1cm4gJ2InXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbFxyXG5cdH1cclxuXHRyZXR1cm4gJFxyXG5cclxufSIsInZhciBiYXNlSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Jhc2VJbmRleE9mJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlcztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXNOYU4gPSByZXF1aXJlKCcuL19iYXNlSXNOYU4nKSxcbiAgICBzdHJpY3RJbmRleE9mID0gcmVxdWlyZSgnLi9fc3RyaWN0SW5kZXhPZicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYU47XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKSxcbiAgICBjcmVhdGVTZXQgPSByZXF1aXJlKCcuL19jcmVhdGVTZXQnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gIH1cbiAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgIH1cbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgfVxuICBlbHNlIHtcbiAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmlxO1xuIiwidmFyIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIG5vb3AgPSByZXF1aXJlKCcuL25vb3AnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNldDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaWN0SW5kZXhPZjtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vb3A7XG4iLCJ2YXIgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZVVuaXEgPSByZXF1aXJlKCcuL19iYXNlVW5pcScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gKiAvLyA9PiBbMi4xLCAxLjJdXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAqL1xuZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxQnk7XG4iLCIvKipcbiAqIENvbnZlcnQgU0dGIGZpbGVzIHRvIGEgSlMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2dmIEEgdmFsaWQgU0dGIGZpbGUuXG4gKiBAc2VlIGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWxcbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIFNHRiBmaWxlIHJlcHJlc2VudGVkIGFzIGEgSlMgb2JqZWN0XG4gKi9cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc2dmKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgcGFyc2U7XG5cdHZhciBwYXJzZXI7XG5cdHZhciBjb2xsZWN0aW9uID0ge307XG5cblx0Ly8gdHJhY2tzIHRoZSBjdXJyZW50IHNlcXVlbmNlXG5cdHZhciBzZXF1ZW5jZTtcblxuXHQvLyB0cmFja3MgdGhlIGN1cnJlbnQgbm9kZVxuXHR2YXIgbm9kZTtcblxuXHQvLyB0cmFja3MgdGhlIGxhc3QgUHJvcElkZW50XG5cdHZhciBsYXN0UHJvcElkZW50O1xuXG5cdC8vIEEgbWFwIG9mIGZ1bmN0aW9ucyB0byBwYXJzZSB0aGUgZGlmZmVyZW50IGNvbXBvbmVudHMgb2YgYW4gU0dGIGZpbGVcblx0cGFyc2VyID0ge1xuXG5cdFx0YmVnaW5TZXF1ZW5jZTogZnVuY3Rpb24gKHNnZikge1xuXHRcdFx0dmFyIGtleSA9ICdzZXF1ZW5jZXMnO1xuXG5cdFx0XHQvLyBUb3AtbGV2ZWwgc2VxdWVuY2VzIGFyZSBnYW1lVHJlZXNcblx0XHRcdGlmICghc2VxdWVuY2UpIHtcblx0XHRcdFx0c2VxdWVuY2UgPSBjb2xsZWN0aW9uO1xuXHRcdFx0XHRrZXkgPSAnZ2FtZVRyZWVzJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNlcXVlbmNlLmdhbWVUcmVlcykge1xuXHRcdFx0XHRrZXkgPSAnZ2FtZVRyZWVzJztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG5ld1NlcXVlbmNlID0ge1xuXHRcdFx0XHRwYXJlbnQ6IHNlcXVlbmNlXG5cdFx0XHR9O1xuXG5cdFx0XHRzZXF1ZW5jZVtrZXldID0gc2VxdWVuY2Vba2V5XSB8fCBbXTtcblx0XHRcdHNlcXVlbmNlW2tleV0ucHVzaChuZXdTZXF1ZW5jZSk7XG5cdFx0XHRzZXF1ZW5jZSA9IG5ld1NlcXVlbmNlO1xuXG5cdFx0XHRyZXR1cm4gc2dmLnN1YnN0cmluZygxKTtcblx0XHR9LFxuXG5cdFx0ZW5kU2VxdWVuY2U6IGZ1bmN0aW9uIChzZ2YpIHtcblx0XHRcdGlmIChzZXF1ZW5jZS5wYXJlbnQpIHtcblx0XHRcdFx0c2VxdWVuY2UgPSBzZXF1ZW5jZS5wYXJlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXF1ZW5jZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2dmLnN1YnN0cmluZygxKTtcblx0XHR9LFxuXG5cdFx0bm9kZTogZnVuY3Rpb24gKHNnZikge1xuXHRcdFx0bm9kZSA9IHt9O1xuXHRcdFx0c2VxdWVuY2Uubm9kZXMgPSBzZXF1ZW5jZS5ub2RlcyB8fCBbXTtcblx0XHRcdHNlcXVlbmNlLm5vZGVzLnB1c2gobm9kZSk7XG5cdFx0XHRyZXR1cm4gc2dmLnN1YnN0cmluZygxKTtcblx0XHR9LFxuXG5cdFx0cHJvcGVydHk6IGZ1bmN0aW9uIChzZ2YpIHtcblx0XHRcdHZhciBwcm9wVmFsdWU7XG5cblx0XHRcdC8vIFNlYXJjaCBmb3IgdGhlIGZpcnN0IHVuZXNjYXBlZCBdXG5cdFx0XHR2YXIgZmlyc3RQcm9wRW5kID0gc2dmLm1hdGNoKC8oW15cXFxcXFxdXXxcXFxcKC58XFxufFxccikpKlxcXS8pO1xuXG5cdFx0XHRpZiAoIWZpcnN0UHJvcEVuZC5sZW5ndGgpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgc2dmJyk7XG5cdFx0XHR9XG5cblx0XHRcdGZpcnN0UHJvcEVuZCA9IGZpcnN0UHJvcEVuZFswXS5sZW5ndGg7XG5cblx0XHRcdHZhciBwcm9wZXJ0eSA9IHNnZi5zdWJzdHJpbmcoMCwgZmlyc3RQcm9wRW5kKTtcblx0XHRcdHZhciBwcm9wVmFsdWVCZWdpbiA9IHByb3BlcnR5LmluZGV4T2YoJ1snKTtcblx0XHRcdHZhciBwcm9wSWRlbnQgPSBwcm9wZXJ0eS5zdWJzdHJpbmcoMCwgcHJvcFZhbHVlQmVnaW4pO1xuXG5cdFx0XHQvLyBQb2ludCBsaXN0cyBkb24ndCBkZWNsYXJlIGEgUHJvcElkZW50IGZvciBlYWNoIFByb3BWYWx1ZVxuXHRcdFx0Ly8gSW5zdGVhZCwgdGhleSBzaG91bGQgdXNlIHRoZSBsYXN0IGRlY2xhcmVkIHByb3BlcnR5XG5cdFx0XHQvLyBTZWU6IGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWwjbW92ZS9wb3Ncblx0XHRcdGlmICghcHJvcElkZW50KSB7XG5cdFx0XHRcdHByb3BJZGVudCA9IGxhc3RQcm9wSWRlbnQ7XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgcHJvcGVydHkgaW4gYSBsaXN0IG9mIG11bHRpcGxlXG5cdFx0XHRcdC8vIHByb3BlcnRpZXMsIHdlIG5lZWQgdG8gd3JhcCB0aGUgUHJvcFZhbHVlIGluIGFuIGFycmF5XG5cdFx0XHRcdGlmICghQXJyYXkuaXNBcnJheShub2RlW3Byb3BJZGVudF0pKSB7XG5cdFx0XHRcdFx0bm9kZVtwcm9wSWRlbnRdID0gW25vZGVbcHJvcElkZW50XV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGFzdFByb3BJZGVudCA9IHByb3BJZGVudDtcblxuXHRcdFx0cHJvcFZhbHVlID0gcHJvcGVydHkuc3Vic3RyaW5nKHByb3BWYWx1ZUJlZ2luICsgMSwgcHJvcGVydHkubGVuZ3RoIC0gMSk7XG5cblx0XHRcdC8vIFdlIGhhdmUgbm8gcHJvYmxlbSBwYXJzaW5nIFByb3BJZGVudHMgb2YgYW55IGxlbmd0aCwgYnV0IHRoZSBzcGVjXG5cdFx0XHQvLyBzYXlzIHRoZXkgc2hvdWxkIGJlIG5vIGxvbmdlciB0aGFuIHR3byBjaGFyYWN0ZXJzLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWwjMi4yXG5cdFx0XHRpZiAocHJvcElkZW50Lmxlbmd0aCA+IDIpIHtcblx0XHRcdFx0Ly8gVE9ETzogV2hhdCdzIHRoZSBiZXN0IHdheSB0byBpc3N1ZSBhIHdhcm5pbmc/XG5cdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHQnU0dGIFByb3BJZGVudHMgc2hvdWxkIGJlIG5vIGxvbmdlciB0aGFuIHR3byBjaGFyYWN0ZXJzOicsIHByb3BJZGVudFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShub2RlW3Byb3BJZGVudF0pKSB7XG5cdFx0XHRcdG5vZGVbcHJvcElkZW50XS5wdXNoKHByb3BWYWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlW3Byb3BJZGVudF0gPSBwcm9wVmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZ2Yuc3Vic3RyaW5nKGZpcnN0UHJvcEVuZCk7XG5cdFx0fSxcblxuXHRcdC8vIFdoaXRlc3BhY2UsIHRhYnMsIG9yIGFueXRoaW5nIGVsc2Ugd2UgZG9uJ3QgcmVjb2duaXplXG5cdFx0dW5yZWNvZ25pemVkOiBmdW5jdGlvbiAoc2dmKSB7XG5cblx0XHRcdC8vIE1hcmNoIGFoZWFkIHRvIHRoZSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0cmV0dXJuIHNnZi5zdWJzdHJpbmcoMSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFByb2Nlc3NlcyBhbiBTR0YgZmlsZSBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyXG5cdHBhcnNlID0gZnVuY3Rpb24gKHNnZikge1xuXHRcdHdoaWxlIChzZ2YpIHtcblx0XHRcdHZhciBpbml0aWFsID0gc2dmLnN1YnN0cmluZygwLCAxKTtcblx0XHRcdHZhciB0eXBlO1xuXG5cdFx0XHQvLyBVc2UgdGhlIGluaXRpYWwgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHJlbWFpbmluZyBzZ2YgZmlsZSkgdG9cblx0XHRcdC8vIGRlY2lkZSB3aGljaCBwYXJzZXIgZnVuY3Rpb24gdG8gdXNlXG5cdFx0XHRpZiAoaW5pdGlhbCA9PT0gJygnKSB7XG5cdFx0XHRcdHR5cGUgPSAnYmVnaW5TZXF1ZW5jZSc7XG5cdFx0XHR9IGVsc2UgaWYgKGluaXRpYWwgPT09ICcpJykge1xuXHRcdFx0XHR0eXBlID0gJ2VuZFNlcXVlbmNlJztcblx0XHRcdH0gZWxzZSBpZiAoaW5pdGlhbCA9PT0gJzsnKSB7XG5cdFx0XHRcdHR5cGUgPSAnbm9kZSc7XG5cdFx0XHR9IGVsc2UgaWYgKGluaXRpYWwuc2VhcmNoKC9bQS1aXFxbXS8pICE9PSAtMSkge1xuXHRcdFx0XHR0eXBlID0gJ3Byb3BlcnR5Jztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSAndW5yZWNvZ25pemVkJztcblx0XHRcdH1cblxuXHRcdFx0c2dmID0gcGFyc2VyW3R5cGVdKHNnZik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbGxlY3Rpb247XG5cdH07XG5cblx0Ly8gQmVnaW4gcGFyc2luZyB0aGUgU0dGIGZpbGVcblx0cmV0dXJuIHBhcnNlKHNnZik7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGFuIFNHRiBmaWxlIGZyb20gYSBTbWFydEdhbWUgUmVjb3JkIEphdmFTY3JpcHQgT2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gcmVjb3JkIEEgcmVjb3JkIG9iamVjdC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHJlY29yZCBhcyBhIHN0cmluZyBzdWl0YWJsZSBmb3Igc2F2aW5nIGFzIGFuIFNHRiBmaWxlXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRmdW5jdGlvbiBzdHJpbmdpZnlTZXF1ZW5jZXMoc2VxdWVuY2VzKSB7XG5cdFx0dmFyIGNvbnRlbnRzID0gJyc7XG5cblx0XHRzZXF1ZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoc2VxdWVuY2UpIHtcblx0XHRcdGNvbnRlbnRzICs9ICcoJztcblxuXHRcdFx0Ly8gUGFyc2UgYWxsIG5vZGVzIGluIHRoaXMgc2VxdWVuY2Vcblx0XHRcdGlmIChzZXF1ZW5jZS5ub2Rlcykge1xuXHRcdFx0XHRzZXF1ZW5jZS5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRcdFx0dmFyIG5vZGVTdHJpbmcgPSAnOyc7XG5cdFx0XHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gbm9kZSkge1xuXHRcdFx0XHRcdFx0aWYgKG5vZGUuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBwcm9wID0gbm9kZVtwcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHByb3ApKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvcCA9IHByb3Auam9pbignXVsnKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRub2RlU3RyaW5nICs9IHByb3BlcnR5ICsgJ1snICsgcHJvcCArICddJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGVudHMgKz0gbm9kZVN0cmluZztcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgdGhlIGZ1bmN0aW9uIHdlJ3JlIGluIHJlY3Vyc2l2ZWx5IGZvciBhbnkgY2hpbGQgc2VxdWVuY2VzXG5cdFx0XHRpZiAoc2VxdWVuY2Uuc2VxdWVuY2VzKSB7XG5cdFx0XHRcdGNvbnRlbnRzICs9IHN0cmluZ2lmeVNlcXVlbmNlcyhzZXF1ZW5jZS5zZXF1ZW5jZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250ZW50cyArPSAnKSc7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY29udGVudHM7XG5cdH1cblxuXHRyZXR1cm4gc3RyaW5naWZ5U2VxdWVuY2VzKHJlY29yZC5nYW1lVHJlZXMpO1xufTtcblxuIiwiLyoqXG4gKiBJbnRlcmFjdCB3aXRoIHNtYXJ0Z2FtZSBvYmplY3RzLlxuICogQHBhcmFtIHtvYmplY3R9IHNtYXJ0Z2FtZSBBIEpTIE9iamVjdCByZXByZXNlbnRpbmcgYSBzbWFydGdhbWVcbiAqIEBzZWUgaHR0cDovL3d3dy5yZWQtYmVhbi5jb20vc2dmL3NnZjQuaHRtbFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBuYXZpZ2F0aW5nIGFuZCBtYW5pcHVsYXRpbmcgYVxuICogc21hcnRnYW1lXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNtYXJ0Z2FtZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHNlcXVlbmNlO1xuXHR2YXIgbm9kZTtcblxuXHR2YXIgU21hcnRnYW1lciA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmluaXQoKTtcblx0fTtcblxuXHRTbWFydGdhbWVyLnByb3RvdHlwZSA9IHtcblx0XHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoc21hcnRnYW1lKSB7XG5cdFx0XHRcdHRoaXMuZ2FtZSA9IHNtYXJ0Z2FtZS5nYW1lVHJlZXNbMF07XG5cdFx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gTG9hZCBhIHNtYXJ0Z2FtZSB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIGxvYWQgbmV3IGdhbWVzIG9yIGFkZCBvbmUgYWZ0ZXJcblx0XHQvLyBpbml0aWFsaXphdGlvbiwgaWYgZGVzaXJlZFxuXHRcdGxvYWQ6IGZ1bmN0aW9uIChuZXdTbWFydGdhbWUpIHtcblx0XHRcdHNtYXJ0Z2FtZSA9IG5ld1NtYXJ0Z2FtZTtcblx0XHRcdHRoaXMuaW5pdCgpO1xuXHRcdH0sXG5cblx0XHQvLyBIYXZpbmcgbXVsdGlwbGUgZ2FtZXMgaW4gYSBjb2xsZWN0aW9uIGlzIG5vdCBjb21tb24sIGJ1dCBpdCdzIHBhcnQgb2Zcblx0XHQvLyB0aGUgc3BlY1xuXHRcdGdhbWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gc21hcnRnYW1lLmdhbWVUcmVlcztcblx0XHR9LFxuXG5cdFx0c2VsZWN0R2FtZTogZnVuY3Rpb24gKGkpIHtcblx0XHRcdGlmIChpIDwgc21hcnRnYW1lLmdhbWVUcmVlcy5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5nYW1lID0gc21hcnRnYW1lLmdhbWVUcmVlc1tpXTtcblx0XHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCd0aGUgY29sbGVjdGlvbiBkb2VzblxcJ3QgY29udGFpbiB0aGF0IG1hbnkgZ2FtZXMnKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZXF1ZW5jZSA9IHRoaXMuZ2FtZTtcblx0XHRcdG5vZGUgPSBzZXF1ZW5jZS5ub2Rlc1swXTtcblx0XHRcdHRoaXMucGF0aCA9IHsgbTogMCB9O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Z2V0U21hcnRnYW1lOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gc21hcnRnYW1lO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYW55IHZhcmlhdGlvbnMgYXZhaWxhYmxlIGF0IHRoZSBjdXJyZW50IG1vdmVcblx0XHQgKiovXG5cdFx0dmFyaWF0aW9uczogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHNlcXVlbmNlKSB7XG5cdFx0XHRcdHZhciBsb2NhbE5vZGVzID0gc2VxdWVuY2Uubm9kZXM7XG5cdFx0XHRcdHZhciBsb2NhbEluZGV4ID0gKGxvY2FsTm9kZXMpID8gbG9jYWxOb2Rlcy5pbmRleE9mKG5vZGUpIDogbnVsbDtcblxuXHRcdFx0XHRpZiAobG9jYWxOb2Rlcykge1xuXHRcdFx0XHRcdGlmIChsb2NhbEluZGV4ID09PSAobG9jYWxOb2Rlcy5sZW5ndGggLSAxKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNlcXVlbmNlLnNlcXVlbmNlcyB8fCBbXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHbyB0byB0aGUgbmV4dCBtb3ZlXG5cdFx0ICoqL1xuXHRcdG5leHQ6IGZ1bmN0aW9uICh2YXJpYXRpb24pIHtcblx0XHRcdHZhcmlhdGlvbiA9IHZhcmlhdGlvbiB8fCAwO1xuXG5cdFx0XHR2YXIgbG9jYWxOb2RlcyA9IHNlcXVlbmNlLm5vZGVzO1xuXHRcdFx0dmFyIGxvY2FsSW5kZXggPSAobG9jYWxOb2RlcykgPyBsb2NhbE5vZGVzLmluZGV4T2Yobm9kZSkgOiBudWxsO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gYWRkaXRpb25hbCBub2RlcyBpbiB0aGlzIHNlcXVlbmNlLFxuXHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBvbmVcblx0XHRcdGlmIChsb2NhbEluZGV4ID09PSBudWxsIHx8IGxvY2FsSW5kZXggPj0gKGxvY2FsTm9kZXMubGVuZ3RoIC0gMSkpIHtcblx0XHRcdFx0aWYgKHNlcXVlbmNlLnNlcXVlbmNlcykge1xuXHRcdFx0XHRcdGlmIChzZXF1ZW5jZS5zZXF1ZW5jZXNbdmFyaWF0aW9uXSkge1xuXHRcdFx0XHRcdFx0c2VxdWVuY2UgPSBzZXF1ZW5jZS5zZXF1ZW5jZXNbdmFyaWF0aW9uXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VxdWVuY2UgPSBzZXF1ZW5jZS5zZXF1ZW5jZXNbMF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bm9kZSA9IHNlcXVlbmNlLm5vZGVzWzBdO1xuXG5cdFx0XHRcdFx0Ly8gTm90ZSB0aGUgZm9yayBjaG9zZW4gZm9yIHRoaXMgdmFyaWF0aW9uIGluIHRoZSBwYXRoXG5cdFx0XHRcdFx0dGhpcy5wYXRoW3RoaXMucGF0aC5tXSA9IHZhcmlhdGlvbjtcblx0XHRcdFx0XHR0aGlzLnBhdGgubSArPSAxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEVuZCBvZiBzZXF1ZW5jZSAvIGdhbWVcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZSA9IGxvY2FsTm9kZXNbbG9jYWxJbmRleCArIDFdO1xuXHRcdFx0XHR0aGlzLnBhdGgubSArPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR28gdG8gdGhlIHByZXZpb3VzIG1vdmVcblx0XHQgKiovXG5cdFx0cHJldmlvdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBsb2NhbE5vZGVzID0gc2VxdWVuY2Uubm9kZXM7XG5cdFx0XHR2YXIgbG9jYWxJbmRleCA9IChsb2NhbE5vZGVzKSA/IGxvY2FsTm9kZXMuaW5kZXhPZihub2RlKSA6IG51bGw7XG5cblx0XHRcdC8vIERlbGV0ZSBhbnkgdmFyaWF0aW9uIGZvcmtzIGF0IHRoaXMgcG9pbnRcblx0XHRcdC8vIFRPRE86IE1ha2UgdGhpcyBjb25maWd1cmFibGUuLi4gd2Ugc2hvdWxkIGtlZXAgdGhpcyBpZiB3ZSdyZVxuXHRcdFx0Ly8gcmVtZW1iZXJpbmcgY2hvc2VuIHBhdGhzXG5cdFx0XHRkZWxldGUgdGhpcy5wYXRoW3RoaXMucGF0aC5tXTtcblxuXHRcdFx0aWYgKCFsb2NhbEluZGV4IHx8IGxvY2FsSW5kZXggPT09IDApIHtcblx0XHRcdFx0aWYgKHNlcXVlbmNlLnBhcmVudCAmJiAhc2VxdWVuY2UucGFyZW50LmdhbWVUcmVlcykge1xuXHRcdFx0XHRcdHNlcXVlbmNlID0gc2VxdWVuY2UucGFyZW50O1xuXHRcdFx0XHRcdGlmIChzZXF1ZW5jZS5ub2Rlcykge1xuXHRcdFx0XHRcdFx0bm9kZSA9IHNlcXVlbmNlLm5vZGVzW3NlcXVlbmNlLm5vZGVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdFx0dGhpcy5wYXRoLm0gLT0gMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bm9kZSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEFscmVhZHkgYXQgdGhlIGJlZ2lubmluZ1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlID0gbG9jYWxOb2Rlc1tsb2NhbEluZGV4IC0gMV07XG5cdFx0XHRcdHRoaXMucGF0aC5tIC09IDE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvLyBHbyB0byB0aGUgbGFzdCBtb3ZlIG9mIHRoZSBnYW1lXG5cdFx0bGFzdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHRvdGFsTW92ZXMgPSB0aGlzLnRvdGFsTW92ZXMoKTtcblxuXHRcdFx0d2hpbGUodGhpcy5wYXRoLm0gPCB0b3RhbE1vdmVzKSB7XG5cdFx0XHRcdHRoaXMubmV4dCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly8gR28gdG8gdGhlIGZpcnN0IG1vdmUgb2YgdGhlIGdhbWVcblx0XHRmaXJzdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdvIHRvIGEgcGFydGljdWxhciBtb3ZlLCBzcGVjaWZpZWQgYXMgYVxuXHRcdCAqIGEpIG51bWJlclxuXHRcdCAqIGIpIHBhdGggc3RyaW5nXG5cdFx0ICogYykgcGF0aCBvYmplY3Rcblx0XHQgKiovXG5cdFx0Z29UbzogZnVuY3Rpb24gKHBhdGgpIHtcblx0XHRcdGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cGF0aCA9IHRoaXMucGF0aFRyYW5zZm9ybShwYXRoLCAnb2JqZWN0Jyk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRwYXRoID0geyBtOiBwYXRoIH07XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucmVzZXQoKTtcblxuXHRcdFx0dmFyIG4gPSBub2RlO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubSAmJiBuOyBpICs9IDEpIHtcblx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGEgdmFyaWF0aW9uIGluIHRoZSBwYXRoIGZvciB0aGUgdXBjb21pbmcgbW92ZVxuXHRcdFx0XHR2YXIgdmFyaWF0aW9uID0gcGF0aFtpICsgMV0gfHwgMDtcblx0XHRcdFx0biA9IHRoaXMubmV4dCh2YXJpYXRpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Z2V0R2FtZUluZm86IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdhbWUubm9kZXNbMF07XG5cdFx0fSxcblxuXHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgbm9kZVxuXHRcdG5vZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH0sXG5cblx0XHQvLyBHZXQgdGhlIHRvdGFsIG51bWJlciBvZiBtb3ZlcyBpbiBhIGdhbWVcblx0XHR0b3RhbE1vdmVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbG9jYWxTZXF1ZW5jZSA9IHRoaXMuZ2FtZTtcblx0XHRcdHZhciBtb3ZlcyA9IDA7XG5cdFx0XHR3aGlsZShsb2NhbFNlcXVlbmNlKSB7XG5cdFx0XHRcdG1vdmVzICs9IGxvY2FsU2VxdWVuY2Uubm9kZXMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmIChsb2NhbFNlcXVlbmNlLnNlcXVlbmNlcykge1xuXHRcdFx0XHRcdGxvY2FsU2VxdWVuY2UgPSBsb2NhbFNlcXVlbmNlLnNlcXVlbmNlc1swXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2NhbFNlcXVlbmNlID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUT0RPOiBSaWdodCBub3cgd2UncmUgKmFzc3VtaW5nKiB0aGF0IHRoZSByb290IG5vZGUgZG9lc24ndCBoYXZlIGFcblx0XHRcdC8vIG1vdmUgaW4gaXQsIHdoaWNoIGlzICpyZWNvbW1lbmRlZCogYnV0IG5vdCByZXF1aXJlZCBwcmFjdGljZS5cblx0XHRcdC8vIEBzZWUgaHR0cDovL3d3dy5yZWQtYmVhbi5jb20vc2dmL3NnZjQuaHRtbFxuXHRcdFx0Ly8gXCJOb3RlOiBpdCdzIGJhZCBzdHlsZSB0byBoYXZlIG1vdmUgcHJvcGVydGllcyBpbiByb290IG5vZGVzLlxuXHRcdFx0Ly8gKGl0IGlzbid0IGZvcmJpZGRlbiB0aG91Z2gpXCJcblx0XHRcdHJldHVybiBtb3ZlcyAtIDE7XG5cdFx0fSxcblxuXHRcdC8vIEdldCBvciBzZXQgYSBjb21tZW50IG9uIHRoZSBjdXJyZW50IG5vZGVcblx0XHQvLyBAc2VlIGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWwjdGV4dFxuXHRcdGNvbW1lbnQ6IGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHRpZiAodHlwZW9mIHRleHQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdC8vIFVuZXNjYXBlIGNoYXJhY3RlcnNcblx0XHRcdFx0aWYgKG5vZGUuQykge1xuXHRcdFx0XHRcdHJldHVybiBub2RlLkMucmVwbGFjZSgvXFxcXChbXFxcXDpcXF1dKS9nLCAnJDEnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEVzY2FwZSBjaGFyYWN0ZXJzXG5cdFx0XHRcdG5vZGUuQyA9IHRleHQucmVwbGFjZSgvW1xcXFw6XFxdXS9nLCAnXFxcXCQmJyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zbGF0ZSBhbHBoYSBjb29yZGluYXRlcyBpbnRvIGFuIGFycmF5XG5cdFx0ICogQHBhcmFtIHN0cmluZyBhbHBoYUNvb3JkaW5hdGVzXG5cdFx0ICogQHJldHVybiBhcnJheSBbeCwgeV1cblx0XHQgKiovXG5cdFx0dHJhbnNsYXRlQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uIChhbHBoYUNvb3JkaW5hdGVzKSB7XG5cdFx0XHR2YXIgY29vcmRpbmF0ZUxhYmVscyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG5cdFx0XHR2YXIgaW50ZXJzZWN0aW9uID0gW107XG5cblx0XHRcdGludGVyc2VjdGlvblswXSA9IGNvb3JkaW5hdGVMYWJlbHMuaW5kZXhPZihhbHBoYUNvb3JkaW5hdGVzLnN1YnN0cmluZygwLCAxKSk7XG5cdFx0XHRpbnRlcnNlY3Rpb25bMV0gPSBjb29yZGluYXRlTGFiZWxzLmluZGV4T2YoYWxwaGFDb29yZGluYXRlcy5zdWJzdHJpbmcoMSwgMikpO1xuXG5cdFx0XHRyZXR1cm4gaW50ZXJzZWN0aW9uO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDb252ZXJ0IHBhdGggb2JqZWN0cyB0byBzdHJpbmdzIGFuZCBwYXRoIHN0cmluZ3MgdG8gb2JqZWN0c1xuXHRcdCAqKi9cblx0XHRwYXRoVHJhbnNmb3JtOiBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dFR5cGUsIHZlcmJvc2UpIHtcblx0XHRcdHZhciBvdXRwdXQ7XG5cblx0XHRcdC8vIElmIG5vIG91dHB1dCB0eXBlIGhhcyBiZWVuIHNwZWNpZmllZCwgdHJ5IHRvIHNldCBpdCB0byB0aGVcblx0XHRcdC8vIG9wcG9zaXRlIG9mIHRoZSBpbnB1dFxuXHRcdFx0aWYgKHR5cGVvZiBvdXRwdXRUeXBlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRvdXRwdXRUeXBlID0gKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpID8gJ29iamVjdCcgOiAnc3RyaW5nJztcblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUdXJuIGEgcGF0aCBvYmplY3QgaW50byBhIHN0cmluZy5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gc3RyaW5naWZ5KGlucHV0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGlucHV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFpbnB1dCkge1xuXHRcdFx0XHRcdHJldHVybiAnJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dCA9IGlucHV0Lm07XG5cblx0XHRcdFx0dmFyIHZhcmlhdGlvbnMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGlucHV0KSB7XG5cdFx0XHRcdFx0aWYgKGlucHV0Lmhhc093blByb3BlcnR5KGtleSkgJiYga2V5ICE9PSAnbScpIHtcblx0XHRcdFx0XHRcdC8vIE9ubHkgc2hvdyB2YXJpYXRpb25zIHRoYXQgYXJlIG5vdCB0aGUgcHJpbWFyeSBvbmUsIHNpbmNlXG5cdFx0XHRcdFx0XHQvLyBwcmltYXJ5IHZhcmlhdGlvbnMgYXJlIGNob3NlbiBieSBkZWZhdWx0XG5cdFx0XHRcdFx0XHRpZiAoaW5wdXRba2V5XSA+IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZlcmJvc2UpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXJpYXRpb25zLnB1c2goJywgdmFyaWF0aW9uICcgKyBpbnB1dFtrZXldICsgJyBhdCBtb3ZlICcgKyBrZXkpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHZhcmlhdGlvbnMucHVzaCgnLScgKyBrZXkgKyAnOicgKyBpbnB1dFtrZXldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dCArPSB2YXJpYXRpb25zLmpvaW4oJycpO1xuXHRcdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFR1cm4gYSBwYXRoIHN0cmluZyBpbnRvIGFuIG9iamVjdC5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRpbnB1dCA9IHN0cmluZ2lmeShpbnB1dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWlucHV0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbTogMCB9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHBhdGggPSBpbnB1dC5zcGxpdCgnLScpO1xuXHRcdFx0XHRvdXRwdXQgPSB7XG5cdFx0XHRcdFx0bTogTnVtYmVyKHBhdGguc2hpZnQoKSlcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAocGF0aC5sZW5ndGgpIHtcblx0XHRcdFx0XHRwYXRoLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhdGlvbiwgaSkge1xuXHRcdFx0XHRcdFx0dmFyaWF0aW9uID0gdmFyaWF0aW9uLnNwbGl0KCc6Jyk7XG5cdFx0XHRcdFx0XHRvdXRwdXRbTnVtYmVyKHZhcmlhdGlvblswXSldID0gcGFyc2VJbnQodmFyaWF0aW9uWzFdLCAxMCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3V0cHV0VHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0b3V0cHV0ID0gc3RyaW5naWZ5KGlucHV0KTtcblx0XHRcdH0gZWxzZSBpZiAob3V0cHV0VHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0b3V0cHV0ID0gcGFyc2UoaW5wdXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0ID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gbmV3IFNtYXJ0Z2FtZXIoKTtcbn07XG4iLCIvKiBnbG9iYWxzIG1vZHVsZTogZmFsc2UsIHJlcXVpcmU6IGZhbHNlXHJcblxyXG4qL1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKHZhcmlhbnRTZ2YsIG9wdGlvbnMpID0+IHtcclxuICAndXNlIHN0cmljdCcgXHJcbiAgbGV0IHRyYW5zZm9ybWVyID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1lcicpXHJcblx0LCAgc21hcnRnYW1lID0gcmVxdWlyZSgnc21hcnRnYW1lJylcclxuXHQsICBzbWFydGdhbWVyID0gcmVxdWlyZSgnc21hcnRnYW1lcicpXHJcblx0LCAgdEdvID0gcmVxdWlyZSgnZ28tdmFyaWFudHMtZW5naW5lJykoKVxyXG4gICAgcmV0dXJuICh0cmFuc2Zvcm1lcihvcHRpb25zKSkudHJhbnNmb3JtKFxyXG4gIFxyXG4gICAgdmFyaWFudFNnZlxyXG4gICAgLCB0R29cclxuICAgICwgc21hcnRnYW1lXHJcbiAgICAsIHNtYXJ0Z2FtZXJcclxuICAgIClcclxuICB9Iiwi77u/LyogZ2xvYmFscyBtb2R1bGU6IGZhbHNlLCByZXF1aXJlOiBmYWxzZVxyXG5cclxuKi9cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGEgZnVuY3Rpb24gZm9yIHRyYW5zZm9ybWluZyBTR0YgZm9yIGEgR28gdmFyaWFudCB0byBTR0YgZm9yIGEgc3RhbmRhcmQgR28gdmlld2VyOyBhbHNvIHByb3ZpZGVzIGEgZnVuY3Rpb24gZm9yIHRoZSBpbnZlcnNlIHRyYW5zZm9ybWF0aW9uLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9XSBEZWZpbmVzIHZhcmlvdXMgb3B0aW9ucyBmb3IgdGhlIG91dHB1dCBTR0YuIE1heSBiZSBvbWl0dGVkLCBpbiB3aGljaCBjYXNlIHRoZSBkZWZhdWx0IG9wdGlvbnMgKHNlZSBiZWxvdykgYXJlIHVzZWQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWRkQ29tbWVudHMgPSBmYWxzZV0gV2hlbiBmbGFnZ2VkLCBjb21tZW50cyBhcmUgYWRkZWQgdG8gZWFjaCBub2RlIGdpdmluZyB0aGUgbW92ZSBudW1iZXIgYW5kIHRoZSBudW1iZXIgb2Ygc3RvbmVzIGNhcHR1cmVkIGJ5IEJsYWNrIGFuZCBXaGl0ZS5cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hZGRQYXNzZXMgPSB0cnVlXSBXaGVuIGZsYWdnZWQsIGEgcGFzcyBpcyBhZGRlZCB0byBlYWNoIG5vZGUgY29ycmVzcG9uZGluZyB0byBhIG1vdmUgYnkgYSBwbGF5ZXIuIFRoaXMgY2FuIG1ha2UgdGhlIG91dHB1dCBtb3JlIGVhc3kgdG8gbmF2aWdhdGUgaW4gc29tZSB2aWV3ZXJzLlxyXG4gKiBAcGFyYW0ge2FycmF5fSBbb3B0aW9ucy5ib2FyZERpbWVuc2lvbnMgPSBbMTEsIDExXV0gTWF5IGJlIHVzZWQgZm9yIHJlY3Rhbmd1bGFyIHQtR28uIFNob3VsZCBiZSBvbW1pdHRlZCBmb3IgW24sIG5dIHQtR28sIHdoZXJlIG4gaXMgc3BlY2lmaWVkIGluIHRoZSBpbnB1dCBTR0YgKEBwYXJhbSB2YXJpYW50U2dmKS5cclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvb3JkaW5hdGVzVHlwZSA9IDBdIDA6IG5vbmU7XHJcbiAqIDE6ICjihpLihpE7QXwxLUt8MTEpOiBXZXN0ZXJuO1xyXG4gKiAyOiAo4oaS4oaRO0F8MS1MfDExKTogV2VzdGVybiwgbm8g4oCcSeKAnTtcclxuICogMzogKOKGkuKGkzsxfDEtMTF8MTEpOiBMYXRpbi9MYXRpbiwgdG9wIHRvIGJvdHRvbTtcclxuICogNDogKOKGkuKGkzsxfDEtMTF85Y2B5LiAKTogTGF0aW4vQ2hpbmVzZSwgdG9wIHRvIGJvdHRvbTtcclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndyYXBhcm91bmRNYXJrZXJzVHlwZSA9IDFdIDA6IG5vbmU7XHJcbiAqIDE6IEZ1bGwgb3V0bGluZSwgdXNpbmcgdW5pY29kZSBCb3ggRHJhd2luZyBzeW1ib2xzO1xyXG4gKiAyOiBjb3JuZXJzIGFuZCBtaWRkbGVzLCB1c2luZyB1bmljb2RlIEJveCBEcmF3aW5nIHN5bWJvbHM7XHJcbiAqIDM6IGp1c3QgY29ybmVycywgdXNpbmcgdW5pY29kZSBCb3ggRHJhd2luZyBzeW1ib2xzO1xyXG4gKiA0OiBqdXN0IG1pZGRsZXMsIHVzaW5nIHVuaWNvZGUgQm94IERyYXdpbmcgc3ltYm9scztcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncz1dIEZ1cnRoZXIgb3B0aW9uYWwgc2V0dGluZ3MgZm9yIGhvdyB0aGUgKHRvcm9pZGFsLCBvciBvdGhlciBzb3J0IG9mKSBib2FyZCBpcyBwcm9qZWN0ZWQgdG8gYSBmbGF0IGdyaWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mud3JhcGFyb3VuZCA9IDRdICBOdW1iZXIgb2YgbGluZXMgdG8gYWRkIGZvciB0aGUg4oCcd3JhcGFyb3VuZOKAnS5cclxuICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldCA9IFswLDBdXSAgVHJhbnNsYXRpb24gdG8gYXBwbHkgdG8gYWxsIG1vdmVzLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYW5zZm9ybVRvU3RyaW5nPXRydWVdIFdoZW4gc2V0IHRvIGZhbHNlLCB0aGUgb3V0cHV0IGlzIGFuIG9iamVjdCAoYW4gaW5zdGFuY2Ugb2YgYSBTbWFydGdhbWUpLlxyXG4gKiBAcHVibGljXHJcbiAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IGV4cG9zaW5nIGZ1bmN0aW9ucyBmb3IgZ29pbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiBTR0YgZm9yIGEgc3RhbmRhcmQgdmlld2VyLCBhbmQgU0dGIGZvciBhIGdhbWUgb2YgdG9yb2lkYWwgR29cclxuICovLyp0b2Rvczpcclxub3B0aW9ucy5tYXJrTGFzdE1vdmUgRGVmYXVsdCB2YWx1ZTogJ0NSJ1xyXG5vcGlvbnMucGxhY2VzVG9Db3VudCBEZWZhdWx0OiB1bmRlZmluZWQuIE1heSBiZTogJ2xhc3QnfFtjb3VudEluZm8xLCAuLiBjb3VudEluZm8xXS4gY291bnRJbmZvIGlzIGEgcGF0aCBwbHVzIGFuIGFycmF5IHdpdGggYSBwb2ludCBmb3IgZWFjaCBjaGFpbiB0byBiZSBjb25zaWRlcmVkIGFzIGRlYWQuIHtwYXRoLCBkZWFkQ2hhaW5zOiBbLi4uXX1cclxub3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mucm90YXRpb24ge2ludGVnZXJ9IERlZmF1bHQgdmFsdWU6IDAuIEFsbG93ZWQgdmFsdWVzOiAwIC4uIDNcclxub3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mubm9ybWFsaXplUGxhY2UgYXJyYXksIG9yIG9uZSBvZjogQywgVEwgVFIgQkwgQlIgKGNlbnRyZSwgdG9wIGxlZnQsIHRvcCByaWdodCwgYm90dG9tIGxlZnQsIGJvdHRvbSByaWdodClcclxub3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mubm9ybWFsaXplIHtib29sZWFufSBcclxuXHJcbiovXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKG9wdGlvbnNcclxuKSB7XHJcblx0J3VzZSBzdHJpY3QnO1xyXG5cdGNvbnN0XHJcblx0XHRfZmxhdHRlbiA9IHJlcXVpcmUoJ2xvZGFzaC9mbGF0dGVuJylcclxuXHRcdCwgX3VuaXFCeSA9IHJlcXVpcmUoJ2xvZGFzaC91bmlxQnknKVxyXG5cdFx0LCBfZmkgPSByZXF1aXJlKCdsb2Rhc2gvZmluZEluZGV4JylcclxuXHRcdCwgbW9kdWxvID0gKHgsIHkpID0+ICh4ICUgeSArIHkpICUgeVxyXG5cdFx0LCBzb3VyY2VTZ2ZNZXNzYWdlID0gJ3NvdXJjZSBzZ2YgZm9yIHRvcm9pZGFsIEdvIGhhcyBiZWVuIGFkYXB0ZWQgYnkgZ28tdmFyaWFudHMtdHJhbnNmb3JtZXIgc28gYXMgdG8gYmUgcmVuZGVyZWQgYnkgYW55IHN0YW5kYXJkIEdvIGFwcGxpY2F0aW9uJ1xyXG5cdG9wdGlvbnMgPSB7XHJcblx0XHRhZGRQYXNzZXM6IHRydWVcclxuXHRcdCwgYm9hcmREaW1lbnNpb25zOiBbMTEsIDExXVxyXG5cdFx0LCB0cmFuc2Zvcm1Ub1N0cmluZzogdHJ1ZVxyXG5cdFx0LCBhZGRDb21tZW50czogdHJ1ZVxyXG5cdFx0LCBjb29yZGluYXRlc1R5cGU6IDBcclxuXHRcdCwgd3JhcGFyb3VuZE1hcmtlcnNUeXBlOiAxXHJcblx0XHQvL2Fib3ZlIGFyZSB0aGUgZGVmYXVsdHNcclxuXHRcdCwgLi4ub3B0aW9uc1xyXG5cdH1cclxuXHRvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncyA9XHJcblx0XHR7XHJcblx0XHRcdHdyYXBhcm91bmQ6IDQsXHJcblx0XHRcdG9mZnNldDogWzAsIDBdLFxyXG5cdFx0XHQuLi5vcHRpb25zLnByb2plY3Rpb25TZXR0aW5nc1xyXG5cdFx0fVxyXG5cclxuXHRpZiAob3B0aW9ucy5hZGRQYXNzZXMgPT09IHVuZGVmaW5lZClcclxuXHRcdG9wdGlvbnMuYWRkUGFzc2VzID0gdHJ1ZTtcclxuXHJcblx0b3B0aW9ucy5ib2FyZERpbWVuc2lvbnMgPSBvcHRpb25zLmJvYXJkRGltZW5zaW9ucyB8fCBbMTEsIDExXVxyXG5cclxuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm1Ub1N0cmluZyA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0b3B0aW9ucy50cmFuc2Zvcm1Ub1N0cmluZyA9IHRydWU7XHJcblxyXG5cdGlmIChvcHRpb25zLmFkZENvbW1lbnRzID09PSB1bmRlZmluZWQpXHJcblx0XHRvcHRpb25zLmFkZENvbW1lbnRzID0gdHJ1ZTtcclxuXHQvLyBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncyA9IFxyXG5cclxuXHRsZXQgd3JhcGFyb3VuZCA9IG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLndyYXBhcm91bmRcclxuXHJcblx0bGV0ICQgPSB7fVxyXG5cdFx0Ly8gLCBfbWFya2Vyc0ZvcldyYXBhcm91bmQgPSBudWxsXHJcblx0XHQsIGNvb3JkaW5hdGVMYWJlbHMgPSBmdW5jdGlvbiAoaSkge1xyXG5cdFx0XHQvLyA5Ny4uMTIyIGFuZCA2NS4uOTBcclxuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaSA8IDI2ID8gaSArIDk3IDogaSArIDM5KVxyXG5cdFx0XHQvLzY1IC0gMjYgPVxyXG5cdFx0fVxyXG5cdFx0LFxyXG5cdFx0dHJhbnNsYXRlQ29vcmRpbmF0ZSA9IChjKSA9PiB7XHJcblx0XHRcdGxldCByID0gYy5jaGFyQ29kZUF0KDApXHJcblx0XHRcdHJldHVybiByID49IDk3ID8gciAtIDk3IDogciAtIDI2XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUcmFuc2xhdGUgYWxwaGEgY29vcmRpbmF0ZXMgaW50byBhbiBhcnJheVxyXG5cdFx0ICogQHBhcmFtIHN0cmluZyBhbHBoYUNvb3JkaW5hdGVzXHJcblx0XHQgKiBAcmV0dXJuIGFycmF5IFt4LCB5XVxyXG5cdFx0ICoqL1xyXG5cdFx0dHJhbnNsYXRlQ29vcmRpbmF0ZXMgPSAoYWxwaGFDb29yZGluYXRlcykgPT4ge1xyXG5cdFx0XHRyZXR1cm4gW3RyYW5zbGF0ZUNvb3JkaW5hdGUoYWxwaGFDb29yZGluYXRlcy5zdWJzdHJpbmcoMCwgMSkpXHJcblx0XHRcdFx0LCB0cmFuc2xhdGVDb29yZGluYXRlKGFscGhhQ29vcmRpbmF0ZXMuc3Vic3RyaW5nKDEsIDIpKV1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHQkLmNvb3JkaW5hdGVMYWJlbHMgPSBjb29yZGluYXRlTGFiZWxzXHJcblx0JC50cmFuc2xhdGVDb29yZGluYXRlcyA9IHRyYW5zbGF0ZUNvb3JkaW5hdGVzXHJcblx0LyoqXHJcblx0ICogQHB1YmxpY1xyXG5cdCAqL1xyXG5cdCQub3B0aW9ucyA9IG9wdGlvbnNcclxuXHJcblx0JC5wcm9qZWN0T25MaW5lID0gZnVuY3Rpb24gKGEsIGlzVmVydGljYWwpIHtcclxuXHRcdC8qXHJcblx0XHRtOiBib2FyZERpbWVuc2lvbnNbMF0gOiAxMVxyXG5cdFx0bjogd3JhcGFyb3VuZCA6IDRcclxuXHRcdGxpbmU6IDAsLi4uLChtLTEpXHJcblx0XHQ9PlxyXG5cdFx0MCwuLi4sKG4tMSksIChzdGFydCBsaW5lKSBuLCAuLi4gLCAobiArIG0gLSAxKSBlbmQgbGluZSwgIChuK20pLCAuLi4gLCAoMm4gKyBtIC0gMSlcclxuXHJcblx0XHRjb29yZGluYXRlIGEg4oiIIHswIC4uIG0tMX0gcHJvamVjdHMgdG8gbiArIGEgaW4gbWFpbiBhcmVhXHJcblx0XHRhbGwgcHJvamVjdGlvbnMgYXJlIG9mIHRoZSBmb3JtIG4gKyBhICsgeG0sIHgg4oiIIOKEpCBzLnQuIDAg4omkIG4gKyBhICsgeG0g4omkIDJuICsgbSAtMVxyXG5cdFx0LXhtIOKJpCBuICsgYVxyXG5cdFx0XHRzbWFsbGVzdCBzdWNoIHggPCAwIGlzIGNlaWwoLShuK2EpL20pXHJcblx0XHQgeG0g4omkIG4gKyBtIC0gMSAtYVxyXG5cdFx0XHRsYXJnZXN0IHN1Y2ggeCBpcyBmbG9vcigobiArIG0gLSAxIC1hKSAvIG0pXHJcblxyXG5cclxuXHRcdCovXHJcblxyXG5cdFx0Y29uc3QgbSAvLz0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF1cclxuXHRcdFx0PSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1tpc1ZlcnRpY2FsID8gMSA6IDBdXHJcblxyXG5cdFx0XHQsIHIgPSBbXVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSBNYXRoLmNlaWwoLSh3cmFwYXJvdW5kICsgYSkgLyBtKTsgaSA8PSAod3JhcGFyb3VuZCArIG0gLSAxIC0gYSkgLyBtOyBpKyspXHJcblx0XHRcdHIucHVzaCh3cmFwYXJvdW5kICsgYSArIGkgKiBtKVxyXG5cdFx0cmV0dXJuIHJcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgaXMgdGhlIGludmVyc2UgZnVuY3Rpb24gdG8gdGhlIGZ1bmN0aW9uIOKAnHByb2plY3RPbkZsYXTigJ0g4oCTIGF0IGxlYXN0IGl0IGlzIHdoZW4g4oCcbXVsdGlwbGXigJ0gaXMgZmFsc2UuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIFRoZSBwb2ludCBvciBhcnJheSBvZiBwb2ludHMgcHJvamVjdGVkIG9udG8gdGhlIGdyaWQuXHJcblx0ICogQHBhcmFtIHtCb29sZWFuPWZhbHNlfSBtdWx0aXBsZSBXaGV0aGVyIHRoZSBhcmd1bWVudCDigJxwb2ludHPigJ0gaXMgdGhlIGltYWdlIG9mIGEgc2luZ2xlIHBvaW50ICjigJxtdWx0aXBsZT1mYWxzZeKAnSkgb3Igb2YgbXVsdGlwbGUgcG9pbnRzLlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gV2hlbiB0aGUgZmxhZyDigJxtdWx0aXBsZeKAnSBpcyBmbGFnZ2VkLCByZXR1cm5zIGFuIGFycmF5IG9mIHBvaW50czsgb3RoZXJ3aXNlIHJldHVybnMgYSBzaW5nbGUgcG9pbnQgKGkuZS4gYW4gYXJyYXkgb2YgdHdvIGludGVnZXJzKS5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiBpbnZlcnNlUHJvamVjdE9uRmxhdChwb2ludHMsIG11bHRpcGxlKSB7XHJcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzWzBdKSkgcG9pbnRzID0gW3BvaW50c11cclxuXHRcdGlmICghbXVsdGlwbGUpXHJcblx0XHRcdHJldHVybiBbbW9kdWxvKHBvaW50c1swXVswXSAtIG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFswXSAtIHdyYXBhcm91bmQsIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdKVxyXG5cdFx0XHRcdCwgbW9kdWxvKHBvaW50c1swXVsxXSAtIG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFsxXSAtIHdyYXBhcm91bmQsIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdKV1cclxuXHRcdHJldHVybiBfdW5pcUJ5KHBvaW50cy5tYXAoeCA9PiBpbnZlcnNlUHJvamVjdE9uRmxhdChbeF0pKSwgKHgpID0+IGAke3hbMF19XyR7eFsxXX1gKVxyXG5cdH1cclxuXHQkLmludmVyc2VQcm9qZWN0T25GbGF0ID0gaW52ZXJzZVByb2plY3RPbkZsYXRcclxuXHJcblx0LyoqXHJcblx0ICogUHJvamVjdHMgYSBwb2ludCBvbiB0aGUgdC1HbyBib2FyZCB0byB0aGUgYXJyYXkgb2YgcG9pbnRzIG9uIHRoZSBzdGFuZGFyZCBncmlkL2JvYXJkLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHAgVGhlIHBvaW50IGluIHRoZSB0LUdvIGJvYXJkIHRvIGJlIHByb2plY3RlZCBvbiB0byB0aGUgZ3JpZC5cclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gcHJvamVjdE9uRmxhdChwKSB7XHJcblx0XHRjb25zdCBhID0gJC5wcm9qZWN0T25MaW5lKHBbMF0gKyBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMF0pXHJcblx0XHRcdCwgYiA9ICQucHJvamVjdE9uTGluZShwWzFdICsgb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzFdKVxyXG5cdFx0XHQsIHIgPSBbXVxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0ci5wdXNoKFthW2ldLCBiW2pdXSlcclxuXHRcdHJldHVybiByXHJcblx0fVxyXG5cdCQucHJvamVjdE9uRmxhdCA9IHByb2plY3RPbkZsYXRcclxuXHJcblx0JC5tb2RYID0gKHgpID0+IG1vZHVsbyh4LCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXSlcclxuXHQkLm1vZFkgPSAoeSkgPT4gbW9kdWxvKHksIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdKVxyXG5cclxuXHRsZXQgc2V0VXBNYXJrZXJzID0gKCkgPT4ge1xyXG5cdFx0JC53cmFwYXJvdW5kQW5kQ29vcmRzID0gW11cclxuXHJcblx0XHQvLyAkLmdldE1hcmtlcnNGb3JXcmFwYXJvdW5kID0gZnVuY3Rpb24gKCl7XHJcblx0XHRpZiAob3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mud3JhcGFyb3VuZCA+IDApIHtcclxuXHRcdFx0Y29uc3QgbSA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdLFxyXG5cdFx0XHRcdG4gPSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXVxyXG5cclxuXHRcdFx0LypcclxuXHRcdFx0bTogYm9hcmREaW1lbnNpb25zWzBdIDogMTFcclxuXHRcdFx0dzogd3JhcGFyb3VuZCA6IDRcclxuXHRcdFx0bGluZTogMCwuLi4sKG0tMSlcclxuXHRcdFx0PT5cclxuXHRcdFx0MCwuLi4sKHctMSksIChzdGFydCBsaW5lKSB3LCAuLi4gLCAodyArIG0gLSAxKSBlbmQgbGluZSwgKHcrbSksIC4uLiAsICgydyArIG0gLSAxKVxyXG5cdFx0XHQqL1xyXG5cclxuXHRcdFx0bGV0IGJvYXJkID0gW11cclxuXHRcdFx0aWYgKFsxLCAyLCA0XS5pbmRleE9mKG9wdGlvbnMud3JhcGFyb3VuZE1hcmtlcnNUeXBlKSA+IC0xKSB7XHJcblx0XHRcdFx0bGV0IG1pZGRsZXMgPSBvcHRpb25zLndyYXBhcm91bmRNYXJrZXJzVHlwZSA+IDEgP1xyXG5cdFx0XHRcdFx0W01hdGguZmxvb3IoKG0gLSAxKSAvIDIpICsgMSwgTWF0aC5jZWlsKChtIC0gMSkgLyAyKSArIDEsXHJcblx0XHRcdFx0XHRNYXRoLmZsb29yKChuIC0gMSkgLyAyKSArIDEsIE1hdGguY2VpbCgobiAtIDEpIC8gMikgKyAxXVxyXG5cdFx0XHRcdFx0OiBbLTEsIDk5LCAtMSwgOTldXHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPD0gbTsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAoaSA8IG1pZGRsZXNbMF0gfHwgaSA+IG1pZGRsZXNbMV0pIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWVcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxldCBsYWJlbCA9ICfilIAnLy9VKzI1MDAgQm94IERyYXdpbmdzIExpZ2h0IEhvcml6b250YWxcclxuXHJcblx0XHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEgKyBpKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEpICsgXCI6XCIgKyBsYWJlbClcclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSArIGkpICsgY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kICsgbSkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8PSBuOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChpIDwgbWlkZGxlc1syXSB8fCBpID4gbWlkZGxlc1szXSkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGV0IGxhYmVsID0gJ+KUgicvL3VuaWNvZGUgdG9vXHJcblx0XHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEpICsgY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSArIGkpICsgXCI6XCIgKyBsYWJlbClcclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kICsgbikgKyBjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxICsgaSkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoWzEsIDIsIDNdLmluZGV4T2Yob3B0aW9ucy53cmFwYXJvdW5kTWFya2Vyc1R5cGUpID4gLTEpIHtcclxuXHRcdFx0XHQvL+KUmCAg4pSMICDilJQg4pSQXHJcblx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCArIG4pICsgXCI64pSUXCIpXHJcblx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgKyBtKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCArIG4pICsgXCI64pSYXCIpXHJcblx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEpICsgXCI64pSMXCIpXHJcblx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgKyBtKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEpICsgXCI64pSQXCIpXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmNvb3JkaW5hdGVzVHlwZSA+IDAgJiYgd3JhcGFyb3VuZCA+IDEpIHtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IDIgKiB3cmFwYXJvdW5kICsgbSAtIDE7IGkrKykge1xyXG5cclxuXHRcdFx0XHRcdGxldCBjb29yZEluZGV4ID0gJC5tb2RYKC1vcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMF0gLSB3cmFwYXJvdW5kICsgaSlcclxuXHJcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5jb29yZGluYXRlc1R5cGUgPT09IDIgJiYgY29vcmRJbmRleCA+PSA4KSB7XHJcblx0XHRcdFx0XHRcdC8vb21pdCB0aGUgSSAtIGhpc3RvcmljYWwgY29vcmRpbmF0ZXMgZm9yIEdvLi4uXHJcblx0XHRcdFx0XHRcdC8vSTogOXRoIGxldHRlclxyXG5cdFx0XHRcdFx0XHRjb29yZEluZGV4KytcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxldCBsYWJlbCA9XHJcblx0XHRcdFx0XHRcdG9wdGlvbnMuY29vcmRpbmF0ZXNUeXBlIDwgM1xyXG5cdFx0XHRcdFx0XHRcdD8gY29vcmRpbmF0ZUxhYmVscyhjb29yZEluZGV4KS50b1VwcGVyQ2FzZSgpXHJcblx0XHRcdFx0XHRcdFx0OiAnJyArIChjb29yZEluZGV4ICsgMSlcclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyhpKSArIGNvb3JkaW5hdGVMYWJlbHMoMCkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKGkpICsgY29vcmRpbmF0ZUxhYmVscygyICogd3JhcGFyb3VuZCArIG4gLSAxKSArIFwiOlwiICsgbGFiZWwpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxldCBjamtOdW1iZXJzID0gJ+S4gOS6jOS4ieWbm+S6lOWFreS4g+WFq+S5nSdcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IDIgKiB3cmFwYXJvdW5kICsgbiAtIDE7IGkrKykge1xyXG5cdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdDBcdFx0LXdcclxuXHRcdFx0XHRcdC4uLlxyXG5cdFx0XHRcdFx0dy0xXHQtMVxyXG5cdFx0XHRcdFx0d1x0XHQwXHJcblx0XHRcdFx0XHQuLi5cclxuXHRcdFx0XHRcdHcgKyBuIC0xXHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHRcdCovXHJcblx0XHRcdFx0XHRsZXQgY29vcmRJbmRleCA9XHJcblx0XHRcdFx0XHRcdG9wdGlvbnMuY29vcmRpbmF0ZXNUeXBlIDwgM1xyXG5cdFx0XHRcdFx0XHRcdD8gJC5tb2RZKG4gKyBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMV0gKyB3cmFwYXJvdW5kIC0gaSAtIDEpXHJcblx0XHRcdFx0XHRcdFx0OiAkLm1vZFkoaSAtIHdyYXBhcm91bmQgLSBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMV0pXHJcblx0XHRcdFx0XHRsZXQgbGFiZWwgPSAnJ1xyXG5cdFx0XHRcdFx0c3dpdGNoIChvcHRpb25zLmNvb3JkaW5hdGVzVHlwZSkge1xyXG5cdFx0XHRcdFx0XHRjYXNlIDE6XHJcblx0XHRcdFx0XHRcdGNhc2UgMjpcclxuXHRcdFx0XHRcdFx0Y2FzZSAzOlxyXG5cdFx0XHRcdFx0XHRcdGxhYmVsID0gJycgKyAoY29vcmRJbmRleCArIDEpXHJcblx0XHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdFx0Y2FzZSA0OlxyXG5cdFx0XHRcdFx0XHRcdGxhYmVsID0gbW9kdWxvKGNvb3JkSW5kZXgsIDEwKSA9PT0gOSA/ICcnIDogY2prTnVtYmVyc1ttb2R1bG8oY29vcmRJbmRleCwgMTApXVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoY29vcmRJbmRleCA+IDgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGxhYmVsID0gKGNvb3JkSW5kZXggPiAxOCA/IGNqa051bWJlcnNbTWF0aC5mbG9vcigoY29vcmRJbmRleCArIDEpIC8gMTApIC0gMV0gOiAnJykgKyAn5Y2BJyArIGxhYmVsXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMoMCkgKyBjb29yZGluYXRlTGFiZWxzKGkpICsgXCI6XCIgKyBsYWJlbClcclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscygyICogd3JhcGFyb3VuZCArIG0gLSAxKSArIGNvb3JkaW5hdGVMYWJlbHMoaSkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0JC53cmFwYXJvdW5kQW5kQ29vcmRzID0gYm9hcmRcclxuXHRcdH1cclxuXHR9XHJcblx0c2V0VXBNYXJrZXJzKClcclxuXHJcblxyXG5cdCQuY29vcmRzMlN0cmluZyA9XHJcblx0XHQvKipcclxuXHRcdCAqIGNvbnZlcnRzIGNvb3JkaW5hdGVzIHRvIGEgc3RyaW5nXHJcblx0XHQgKi9cclxuXHRcdGZ1bmN0aW9uIGNvb3JkczJTdHJpbmcoY29vcmRzKSB7XHJcblx0XHRcdHJldHVybiBjb29yZGluYXRlTGFiZWxzKGNvb3Jkc1swXSkgKyBjb29yZGluYXRlTGFiZWxzKGNvb3Jkc1sxXSlcclxuXHRcdH1cclxuXHJcblx0ZnVuY3Rpb24gZ29UaHJvdWdoVHJlZShzdGF0ZSkge1xyXG5cdFx0bGV0IHsgd3JhcHBlZEdhbWUsIG5vZGUsIHBlbmRpbmcsIGN1cnJlbnRQYXRoLCB0R28gfSA9IHN0YXRlXHJcblx0XHRcdCwgbmJWYXJpYXRpb25zID0gd3JhcHBlZEdhbWUudmFyaWF0aW9ucygpLmxlbmd0aFxyXG5cdFx0aWYgKGN1cnJlbnRQYXRoLm0gPiAxMDAwKSB0aHJvdyBuZXcgRXJyb3IoJ3NlZW0gdG8gYmUgc3R1Y2shJyk7XHJcblx0XHRzdGF0ZS5oYXNTaWJsaW5ncyA9IG5iVmFyaWF0aW9ucyA+IDBcclxuXHRcdGlmIChzdGF0ZS5oYXNTaWJsaW5ncykge1xyXG5cdFx0XHQvLyBpZihjdXJyZW50UGF0aFttXSA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHQvLyBjdXJyZW50UGF0aFttXSA9IDBcclxuXHRcdFx0Ly8gZWxzZVxyXG5cdFx0XHQvLyBjdXJyZW50UGF0aFttXSArPSAxXHJcblx0XHRcdC8vIGN1cnJlbnRQYXRoLm0gKz0gMVxyXG5cdFx0XHRmb3IgKGxldCBpID0gbmJWYXJpYXRpb25zIC0gMTsgaSA+IDA7IGktLSlcclxuXHRcdFx0Ly9waWxlIHVwIGluIHRoaXMgb3JkZXIsIGFzIGl0J3MgRklMTyBhbmQgd2Ugd2FudCB0aGUgbGFzdCB2YXJpYXRpb24sIHdoaWNoIG1heSBjb250YWluIGEgbW9kZSBhZGRlZCBieSBDR29ib2FyZCB0byBnbyBsYXN0XHJcblx0XHRcdHtcclxuXHRcdFx0XHRsZXQgcGF0aEZvckxhdGVyID0geyAuLi5jdXJyZW50UGF0aCB9Ly9PYmplY3QuYXNzaWduKHt9LCBjdXJyZW50UGF0aClcclxuXHRcdFx0XHRwYXRoRm9yTGF0ZXJbY3VycmVudFBhdGgubSArIDFdID0gaVxyXG5cdFx0XHRcdHBhdGhGb3JMYXRlci5tICs9IDFcclxuXHJcblx0XHRcdFx0aWYgKHRHbyAhPT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdFx0cGVuZGluZy5wdXNoKHsgcGF0aDogcGF0aEZvckxhdGVyLCB0R29EYXRhOiB0R28uZXhwb3J0RGF0YSgpIH0pXHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0cGVuZGluZy5wdXNoKHsgcGF0aDogcGF0aEZvckxhdGVyIH0pXHJcblxyXG5cdFx0XHR9XHJcblx0XHRcdHN0YXRlLm5vZGUgPSB3cmFwcGVkR2FtZS5uZXh0KCkubm9kZSgpXHJcblx0XHRcdGN1cnJlbnRQYXRoW2N1cnJlbnRQYXRoLm0gKyAxXSA9IDBcclxuXHRcdFx0Y3VycmVudFBhdGgubSArPSAxXHJcblx0XHRcdHJldHVybiBzdGF0ZS5ub2RlXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG5leHROb2RlID0gd3JhcHBlZEdhbWUubmV4dCgpLm5vZGUoKVxyXG5cdFx0aWYgKG5vZGUgPT09IG5leHROb2RlKSB7Ly9hdCBhIGxlYWY6XHJcblx0XHRcdGlmIChwZW5kaW5nLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdHN0YXRlLm5vZGUgPSBudWxsXHJcblx0XHRcdFx0cmV0dXJuIHN0YXRlLm5vZGUvL2ZpbmlzaGVkXHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGZyb21TdGFjayA9IHBlbmRpbmcucG9wKClcclxuXHRcdFx0c3RhdGUuaGFzU2libGluZ3MgPSB0cnVlXHJcblx0XHRcdC8vIGlmIChmcm9tU3RhY2sgPT09IG51bGwpIHtcclxuXHRcdFx0Ly8gXHRub2RlID0gbnVsbFxyXG5cdFx0XHQvLyBcdHJldHVybi8vZmluaXNoZWQhXHJcblx0XHRcdC8vIH1cclxuXHRcdFx0aWYgKHRHbyAhPT0gdW5kZWZpbmVkKSB0R28ubG9hZERhdGEoZnJvbVN0YWNrLnRHb0RhdGEpXHJcblx0XHRcdHN0YXRlLm5vZGUgPSB3cmFwcGVkR2FtZS5nb1RvKGZyb21TdGFjay5wYXRoKS5ub2RlKClcclxuXHRcdFx0c3RhdGUuY3VycmVudFBhdGggPSBmcm9tU3RhY2sucGF0aFxyXG5cdFx0XHRyZXR1cm4gc3RhdGUubm9kZVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdGN1cnJlbnRQYXRoLm0gKz0gMVxyXG5cdFx0XHRzdGF0ZS5ub2RlID0gbmV4dE5vZGVcclxuXHRcdFx0cmV0dXJuIHN0YXRlLm5vZGVcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFwYXJ0IGZyb20gYSBmZXcgZGV0YWlscywgdGhpcyBpcyBhbiBpbnZlcnNlIG9mIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24uXHJcblx0ICogQHBhcmFtIHtzbWFydGdhbWV8c3RyaW5nfSB3cmFwcGVkR2FtZVxyXG5cdCAqIEBwYXJhbSB7c21hcnRnYW1lfSBzbWFydGdhbWVcclxuXHQgKiBAcHVibGljXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gaW52ZXJzZVRyYW5zZm9ybShcclxuXHRcdHdyYXBwZWRHYW1lLCBzbWFydGdhbWUpIHtcclxuXHJcblx0XHRpZiAoc21hcnRnYW1lID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c21hcnRnYW1lID0gcmVxdWlyZSgnc21hcnRnYW1lJylcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIHdyYXBwZWRHYW1lID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR2YXIgc21hcnRnYW1lciA9IHJlcXVpcmUoJ3NtYXJ0Z2FtZXInKVxyXG5cdFx0XHR3cmFwcGVkR2FtZSA9IHNtYXJ0Z2FtZXIoc21hcnRnYW1lLnBhcnNlKHdyYXBwZWRHYW1lKSlcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgbm9kZSA9IHdyYXBwZWRHYW1lLmZpcnN0KCkubm9kZSgpXHJcblx0XHRcdCwgcGVuZGluZyA9IFtdXHJcblx0XHRcdCwgY3VycmVudFBhdGggPSB7IG06IDAgfVxyXG5cdFx0XHQsIGNsZWFuZXJSZWdFeCA9IC9eW2EtekEtWiA6MC05XFwtKFxcclxcbl0rR29WYXJpYW50c1RyYW5zZm9ybWVyXFwpLS1bXFxyXFxuXSovXHJcblx0XHRcdCwgY2xlYW5Db21tZW50cyA9ICgpID0+IHtcclxuXHRcdFx0XHRpZiAobm9kZS5DICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdG5vZGUuQyA9IG5vZGUuQy5yZXBsYWNlKGNsZWFuZXJSZWdFeCwgJycpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChub2RlLkMgPT09ICcnKVxyXG5cdFx0XHRcdFx0ZGVsZXRlIG5vZGUuQ1xyXG5cdFx0XHR9XHJcblx0XHRcdCxcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIEZ1bmN0aW9uIHRvOlxyXG5cdFx0XHQgKiBcdC0gcmVtb3ZlIHRoZSDigJxib3JkZXLigJ0gKHVuaWNvZGUgc3ltYm9scyBhZGRlZCBieSB0aGUgdHJhbnNmb3JtIHRvIGluZGljYXRlIHdoZXJlIHRoZSB3cmFwYXJvdW5kIGFyZWEgbWVldHMgdGhlIG1haW4gZ3JpZCkuXHJcblx0XHRcdCAqIFx0LSByZW1vdmUgQ00gKGNvbG91ciBtYXApIGFuZCBDVCAoY29sb3VyIHRhYmxlKSB3aGljaCBhcmUgbm9uc3RhbmRhcmQgU0dGIGFkZGVkIGJ5IENHb2JvYXJkIGZvciBiYWNrZ3JvdW5kIGNvbG91ciAoY291bGQgYmUgaW50ZXJlc3RpbmcgdG8gdXNlIHRoaXMgZmVhdHVyZSBsYXRlciBvbikuXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRjbGVhbkxhYmVscyA9ICgpID0+IHtcclxuXHJcblx0XHRcdFx0bGV0IGxhYmVscyA9IFtdXHJcblx0XHRcdFx0aWYgKG5vZGUuTEIgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0bGFiZWxzID0gbm9kZS5MQlxyXG5cdFx0XHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpXHJcblx0XHRcdFx0XHRcdGxhYmVscyA9IFtsYWJlbHNdXHJcblx0XHRcdFx0XHRsYWJlbHMgPSBsYWJlbHMuZmlsdGVyKGkgPT4gISQud3JhcGFyb3VuZEFuZENvb3Jkcy5pbmNsdWRlcyhpKSlcclxuXHRcdFx0XHRcdC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xyXG5cdFx0XHRcdFx0bGFiZWxzID1cclxuXHRcdFx0XHRcdFx0X3VuaXFCeShcclxuXHRcdFx0XHRcdFx0XHRsYWJlbHNcclxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc3BsaXQoJzonLCAyKSB9KS8vYXNzdW1lIHRoZSBsYWJlbCBkb2VzbuKAmXQgY29udGFpbiDigJw64oCdXHJcblx0XHRcdFx0XHRcdFx0XHQubWFwKCh4KSA9PiBbJC5jb29yZHMyU3RyaW5nKCQuaW52ZXJzZVByb2plY3RPbkZsYXQodHJhbnNsYXRlQ29vcmRpbmF0ZXMoeFswXSkpKSwgeFsxXV0pXHJcblx0XHRcdFx0XHRcdFx0LCAoeCkgPT4geFswXSlcclxuXHRcdFx0XHRcdFx0XHQubWFwKCh4KSA9PiBgJHt4WzBdfToke3hbMV19YClcclxuXHJcblxyXG5cdFx0XHRcdFx0Ly8gbGFiZWxzID0gW11cclxuXHRcdFx0XHRcdC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbGFiZWxzMi5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHRcdC8vIFx0bGFiZWxzID0gbGFiZWxzLmNvbmNhdChsYWJlbHMyKVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bm9kZS5MQiA9IGxhYmVsc1xyXG5cdFx0XHRcdGlmIChub2RlLkxCLmxlbmd0aCA9PT0gMClcclxuXHRcdFx0XHRcdGRlbGV0ZSBub2RlLkxCXHJcblxyXG5cdFx0XHRcdGlmIChub2RlLkNNKVxyXG5cdFx0XHRcdFx0ZGVsZXRlIG5vZGUuQ01cclxuXHRcdFx0XHRpZiAobm9kZS5DVClcclxuXHRcdFx0XHRcdGRlbGV0ZSBub2RlLkNUXHJcblx0XHRcdH1cclxuXHJcblx0XHRjbGVhbkxhYmVscygpXHJcblx0XHRub2RlLlNaID0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF1cclxuXHRcdG5vZGUuQVAgPSBcImdvLXZhcmlhbnRzLXRyYW5zZm9ybWVyXCJcclxuXHJcblx0XHRpZiAobm9kZS5TTyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGxldCBjbGVhblNvdXJjZVJlZ2V4ID0gbmV3IFJlZ0V4cChgIFxcXFwoJHtzb3VyY2VTZ2ZNZXNzYWdlfVxcXFwpYClcclxuXHRcdFx0bm9kZS5TTyA9IG5vZGUuU08ucmVwbGFjZShjbGVhblNvdXJjZVJlZ2V4LCAnJylcclxuXHRcdFx0Ly8gaWYgKG5vZGUuU08gPT09ICcnKVxyXG5cdFx0XHQvLyBcdGRlbGV0ZSBub2RlLlNPXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHN0YXRlID0ge1xyXG5cdFx0XHR3cmFwcGVkR2FtZSwgbm9kZSwgcGVuZGluZywgY3VycmVudFBhdGgsIHNpYmxpbmdNb3Zlczoge30vLywgcGFyZW50c1dpdGhDaGlsZFRvRGVsZXRlOiBbXSBcclxuXHRcdH1cclxuXHJcblx0XHRub2RlID0gZ29UaHJvdWdoVHJlZShzdGF0ZSlcclxuXHRcdHdoaWxlIChub2RlICE9PSBudWxsKSB7XHJcblx0XHRcdGNsZWFuTGFiZWxzKClcclxuXHRcdFx0Y2xlYW5Db21tZW50cygpXHJcblxyXG5cdFx0XHRjb25zdFxyXG5cdFx0XHRcdGlzQmxhY2sgPSBub2RlLkFCICE9PSB1bmRlZmluZWQgfHwgbm9kZS5CICE9PSB1bmRlZmluZWRcclxuXHRcdFx0XHQsIGFkZGVkU3RvbmVzID0gaXNCbGFjayA/IG5vZGUuQUIgOiBub2RlLkFXXHJcblx0XHRcdFx0LCBwbGF5ZWRTdG9uZSA9IGlzQmxhY2sgPyBub2RlLkIgOiBub2RlLldcclxuXHRcdFx0XHQsIG1vdmUgPSBhZGRlZFN0b25lcyA/IGFkZGVkU3RvbmVzIDogcGxheWVkU3RvbmVcclxuXHRcdFx0XHQsIG1vdmVBc0FycmF5ID0gQXJyYXkuaXNBcnJheShtb3ZlKSA/IG1vdmUgOiBbbW92ZV1cclxuXHRcdFx0XHQsIGlzQVBhc3MgPSBpc0JsYWNrID8gbm9kZS5CID09PSAnJyA6IG5vZGUuVyA9PT0gJydcclxuXHRcdFx0XHQsIG1vdmVIYXNDb29yZHMgPSBtb3ZlICE9PSB1bmRlZmluZWQgJiYgbW92ZSAhPT0gJydcclxuXHRcdFx0XHQsIGNvb3JkcyA9ICFtb3ZlSGFzQ29vcmRzID8gdW5kZWZpbmVkIDogJC5jb29yZHMyU3RyaW5nKCQuaW52ZXJzZVByb2plY3RPbkZsYXQobW92ZUFzQXJyYXkubWFwKHRyYW5zbGF0ZUNvb3JkaW5hdGVzKSkpXHJcblxyXG5cdFx0XHQvL2FsdGVyIHRoZSBub2RlXHJcblxyXG5cdFx0XHQvKlxyXG5cdFx0XHRsb2dpYyByZW1vdmluZyBhIG5vZGUgYWRkZWQgYnkgQ0dvYm9hcmQsIGlmIHRoZXJlIGFscmVhZHkgaXMgdGhlIHNhbWUgbW92ZSBhcyBBQiBvciBBVyBpbiBhIHByaW9yIHZhcmlhdGlvbjsgYXNzdW1pbmcgXHJcblx0XHRcdHRoZSB2YXJpYXRpb24gdG8gYmUgcmVtb3ZlZCBpcyB0aGUgbGFzdCBvZiB0aGUgc2libGluZ3MgLSB3aGljaCBkb2VzIHNlZW0gdG8gYmUgdGhlIHdheSBDR29ib2FyZCBiZWhhdmVzIHdoZW4gYSBjbGljayBcclxuXHRcdFx0aXMgbWFkZSBvbiBhIHBvaW50IHdoZXJlIHRoZSBuZXh0IG5vZGUgaXMgQUIgb3IgQVcuICBcclxuXHRcdFx0Ki9cclxuXHRcdFx0aWYgKHN0YXRlLmhhc1NpYmxpbmdzKSB7XHJcblx0XHRcdFx0bGV0IHBhdGhGb3JQYXJlbnQgPSB7IC4uLndyYXBwZWRHYW1lLnBhdGggfSAvL09iamVjdC5hc3NpZ24oe30sIHdyYXBwZWRHYW1lLnBhdGgpXHJcblx0XHRcdFx0cGF0aEZvclBhcmVudC5tLS1cclxuXHRcdFx0XHRkZWxldGUgcGF0aEZvclBhcmVudFtwYXRoRm9yUGFyZW50Lm1dXHJcblx0XHRcdFx0cGF0aEZvclBhcmVudCA9IHdyYXBwZWRHYW1lLnBhdGhUcmFuc2Zvcm0ocGF0aEZvclBhcmVudClcclxuXHRcdFx0XHQvLyB3cmFwcGVkR2FtZS5wcmV2aW91cygpXHJcblx0XHRcdFx0aWYgKHN0YXRlLnNpYmxpbmdNb3Zlc1twYXRoRm9yUGFyZW50XSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRzdGF0ZS5zaWJsaW5nTW92ZXNbcGF0aEZvclBhcmVudF0gPSBbXVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAoYWRkZWRTdG9uZXMpIHtcclxuXHRcdFx0XHRcdHN0YXRlLnNpYmxpbmdNb3Zlc1twYXRoRm9yUGFyZW50XS5wdXNoKGNvb3JkcylcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0aWYgKHBsYXllZFN0b25lICYmIHN0YXRlLnNpYmxpbmdNb3Zlc1twYXRoRm9yUGFyZW50XS5pbmRleE9mKGNvb3JkcykgPiAtMSkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUucGFyZW50c1dpdGhDaGlsZFRvRGVsZXRlLnB1c2gocGF0aEZvclBhcmVudClcclxuXHRcdFx0XHRcdFx0bm9kZS5YWCA9IFwiaW52ZXJzZVRyYW5zZm9ybVRvRGVsZXRlXCJcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQvLyB3cmFwcGVkR2FtZS5nb1RvKGN1cnJlbnRQYXRoKVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkZWxldGUgbm9kZVtpc0JsYWNrID8gJ0FCJyA6ICdBVyddXHJcblx0XHRcdGRlbGV0ZSBub2RlW2lzQmxhY2sgPyAnQicgOiAnVyddXHJcblx0XHRcdGRlbGV0ZSBub2RlLkNSXHJcblx0XHRcdGRlbGV0ZSBub2RlLkFFXHJcblxyXG5cdFx0XHRpZiAoaXNBUGFzcykge1xyXG5cdFx0XHRcdG5vZGVbaXNCbGFjayA/ICdCJyA6ICdXJ10gPSAnJ1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAobW92ZUhhc0Nvb3Jkcykge1xyXG5cdFx0XHRcdG5vZGVbaXNCbGFjayA/ICdCJyA6ICdXJ10gPSBjb29yZHNcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Oy8qbm90ZTogdGhpcyBuZXh0IHNlbWljb2xvbiBpcyBuZWVkZWQhICovWy8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtc2VtaVxyXG5cdFx0XHRcdC8vJ0NSJyx0b2RvOiBhZGQgaWYgbm90IG1hcmtpbmcgdGhlIG1vdmVcclxuXHRcdFx0XHQnREQnLCAnTUEnLCAnU0wnLCAnU1EnLCAnVFInXS5mb3JFYWNoKGZ1bmN0aW9uIChzZ2ZQcm9wZXJ0eSkge1xyXG5cdFx0XHRcdFx0Ly8gXy5tYXAoWydERCcsJ01BJywnU0wnLCdTUScsJ1RSJ10sIGZ1bmN0aW9uKHNnZlByb3BlcnR5KXtcclxuXHRcdFx0XHRcdGlmIChub2RlW3NnZlByb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cclxuXHRcdFx0XHRcdGxldCBwb2ludHMgPSBbXVxyXG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobm9kZVtzZ2ZQcm9wZXJ0eV0pKSB7XHJcblx0XHRcdFx0XHRcdHBvaW50cyA9IG5vZGVbc2dmUHJvcGVydHldXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0cG9pbnRzID0gW25vZGVbc2dmUHJvcGVydHldXVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cG9pbnRzID1cclxuXHRcdFx0XHRcdFx0JC5pbnZlcnNlUHJvamVjdE9uRmxhdChcclxuXHRcdFx0XHRcdFx0XHRwb2ludHMubWFwKHRyYW5zbGF0ZUNvb3JkaW5hdGVzKSwgdHJ1ZVxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHRcdFx0Lm1hcCgkLmNvb3JkczJTdHJpbmcpXHJcblx0XHRcdFx0XHRub2RlW3NnZlByb3BlcnR5XSA9IHBvaW50c1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdC8vIG1vdmUgdG8gbmV4dCBub2RlXHJcblx0XHRcdG5vZGUgPSBnb1Rocm91Z2hUcmVlKHN0YXRlKVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHN0YXRlLnBhcmVudHNXaXRoQ2hpbGRUb0RlbGV0ZS5mb3JFYWNoKChwYXRoKSA9PiB7XHJcblx0XHQvLyBcdC8vcmVtb3ZlIHRoZSBzZ2Ygbm9kZVxyXG5cdFx0Ly8gXHR3cmFwcGVkR2FtZS5nb1RvKHBhdGgpXHJcblx0XHQvLyBcdGxldCBzZXF1ZW5jZXMgPSB3cmFwcGVkR2FtZS5nYW1lLnNlcXVlbmNlc1xyXG5cdFx0Ly8gXHRsZXQgaW5kZXggPSBfZmkoc2VxdWVuY2VzLCAoc2VxKSA9PiBzZXEubm9kZXNbMF0uaW52ZXJzZVRyYW5zZm9ybVRvRGVsZXRlKVxyXG5cdFx0Ly8gXHRcdCwgdG1wSSA9IDBcclxuXHRcdC8vIFx0d2hpbGUgKGluZGV4ID4gLTEpIHtcclxuXHRcdC8vIFx0XHRzZXF1ZW5jZXMuc3BsaWNlKGluZGV4LCAxKVxyXG5cdFx0Ly8gXHRcdGluZGV4ID0gX2ZpKHNlcXVlbmNlcywgKHNlcSkgPT4gc2VxLm5vZGVzWzBdLmludmVyc2VUcmFuc2Zvcm1Ub0RlbGV0ZSlcclxuXHRcdC8vIFx0XHR0bXBJKytcclxuXHRcdC8vIFx0XHRpZiAodG1wSSA+IDEwMCkgdGhyb3cgbmV3IEVycm9yKCdzZWVtIHRvIGJlIHN0dWNrIScpO1xyXG5cdFx0Ly8gXHR9XHJcblxyXG5cdFx0Ly8gXHQvLyBjb25zb2xlLmxvZyhwYXRoKVxyXG5cdFx0Ly8gfSlcclxuXHJcblx0XHRsZXQgZGVsZXRlTm9kZXMgPSAoc2VxdWVuY2UpID0+IHtcclxuXHRcdFx0aWYgKHNlcXVlbmNlLnNlcXVlbmNlcykge1xyXG5cclxuXHRcdFx0XHRsZXRcclxuXHRcdFx0XHRcdHNlcXVlbmNlcyA9IHNlcXVlbmNlLnNlcXVlbmNlc1xyXG5cdFx0XHRcdFx0LCBpbmRleCA9IF9maShzZXF1ZW5jZXMsIChzZXEpID0+IHNlcS5ub2Rlc1swXS5YWCA9PT0gJ2ludmVyc2VUcmFuc2Zvcm1Ub0RlbGV0ZScpXHJcblx0XHRcdFx0XHQsIHRtcEkgPSAwLCBtYXggPSBzZXF1ZW5jZXMubGVuZ3RoXHJcblx0XHRcdFx0d2hpbGUgKGluZGV4ID4gLTEpIHtcclxuXHRcdFx0XHRcdHNlcXVlbmNlcy5zcGxpY2UoaW5kZXgsIDEpXHJcblx0XHRcdFx0XHRpbmRleCA9IF9maShzZXF1ZW5jZXMsIChzZXEpID0+IHNlcS5ub2Rlc1swXS5YWCA9PT0gJ2ludmVyc2VUcmFuc2Zvcm1Ub0RlbGV0ZScpXHJcblx0XHRcdFx0XHR0bXBJKytcclxuXHRcdFx0XHRcdGlmICh0bXBJID4gbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ3NlZW0gdG8gYmUgc3R1Y2shJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZvciAobGV0IGluZGV4MiA9IDA7IGluZGV4MiA8IHNlcXVlbmNlcy5sZW5ndGg7IGluZGV4MisrKSB7XHJcblx0XHRcdFx0XHQvLyBkZWxldGVOb2RlcyhzZXF1ZW5jZXNbaW5kZXgyXS5ub2Rlc1tzZXF1ZW5jZXNbaW5kZXgyXS5ub2Rlcy5sZW5ndGggLSAxXSk7XHJcblx0XHRcdFx0XHRkZWxldGVOb2RlcyhzZXF1ZW5jZXNbaW5kZXgyXSk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmIChzZXF1ZW5jZS5ub2RlcylcclxuXHRcdFx0XHRkZWxldGVOb2RlcyhzZXF1ZW5jZS5ub2Rlc1tzZXF1ZW5jZS5ub2Rlcy5sZW5ndGggLSAxXSlcclxuXHRcdH1cclxuXHRcdGRlbGV0ZU5vZGVzKHdyYXBwZWRHYW1lLmdhbWUpXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMudHJhbnNmb3JtVG9TdHJpbmcpXHJcblx0XHRcdHJldHVybiBzbWFydGdhbWUuZ2VuZXJhdGUoeyBnYW1lVHJlZXM6IFt3cmFwcGVkR2FtZS5nYW1lXSB9KTtcclxuXHRcdGVsc2UgcmV0dXJuIHdyYXBwZWRHYW1lXHJcblxyXG5cdH1cclxuXHQkLmludmVyc2VUcmFuc2Zvcm0gPSBpbnZlcnNlVHJhbnNmb3JtXHJcblxyXG5cdC8qKlxyXG5cdCAqIE1haW4gZnVuY3Rpb247IGNvbnZlcnRzIFNHRiBmb3IgYSBHbyB2YXJpYW50IChzbyBmYXIsIGp1c3QgdG9yb2lkYWwgR28gb3IgdC1HbykuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRTZ2ZcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdEdvIEVuZ2luZSBmb3IgY291bnRpbmcgbGliZXJ0aWVzIGluIHQtR28uIEFuIGluc3RhbmNlIG9mIGdvLXZhcmlhbnRzLWVuZ2luZS5cclxuXHQgKiBAcGFyYW0geyp9IHNtYXJ0Z2FtZVxyXG5cdCAqIEBwYXJhbSB7Kn0gc21hcnRnYW1lclxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd8b2JqZWN0fSBTR0YgdGhhdCBjYW4gYmUgdmlld2VkIGluIGEgc3RhbmRhcmQgU0dGIHZpZXdlci4gKFNlZSBgb3B0aW9ucy50cmFuc2Zvcm1Ub1N0cmluZ2AgZm9yIHRoZSBkYXRhIHR5cGUgb2YgdGhlIHZhbHVlIHJldHVybmVkLilcclxuXHQgKiBAcHVibGljXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdHJhbnNmb3JtKFxyXG5cdFx0dFNnZiAvL2VnIDExeDExIHNnZiBmcm9tIExpdHRsZUdvbGVtXHJcblx0XHQsIHRHbyAvL2FwcCBpbXBsZW1lbnRpbmcgdC1Hb1xyXG5cdFx0LCBzbWFydGdhbWVcclxuXHRcdCwgc21hcnRnYW1lcikge1xyXG5cclxuXHRcdGlmICh0R28gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHQvLyAgdEdvID0gcmVxdWlyZSgnLi4vZGlzdC9ub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL3NyYy9lbmdpbmUubWluLmpzJykoe1xyXG5cdFx0XHQvLyAgdEdvID0gcmVxdWlyZSgnLi4vLi4vZW5naW5lL2Rpc3QvZW5naW5lLm1pbi5qcycpKHtcclxuXHRcdFx0XHR0R28gPSByZXF1aXJlKCdnby12YXJpYW50cy1lbmdpbmUnKSh7XHJcblx0XHRcdFx0XHQvLyB0R28gPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL3NyYy9lbmdpbmUnKSh7XHJcblx0XHRcdFx0Ly8gYm9hcmRNb2RlOid0JyxcclxuXHRcdFx0XHRib2FyZERpbWVuc2lvbnM6IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zXHJcblx0XHRcdH0pXHJcblx0XHRcdC8vIHRHbyA9IHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUnKSh7Ym9hcmRNb2RlOid0JywgYm9hcmREaW1lbnNpb25zOm9wdGlvbnMuYm9hcmREaW1lbnNpb25zfSlcclxuXHRcdFx0Ly8gdEdvID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9zcmMvZW5naW5lJykoe2JvYXJkTW9kZTondCcsIGJvYXJkRGltZW5zaW9uczpvcHRpb25zLmJvYXJkRGltZW5zaW9uc30pXHJcblx0XHR9XHJcblx0XHQvLyBlbHNlIHtcclxuXHRcdC8vIFx0dEdvLm9wdGlvbnMuYm9hcmREaW1lbnNpb25zID0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNcclxuXHRcdC8vIH1cclxuXHJcblx0XHRpZiAoc21hcnRnYW1lID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c21hcnRnYW1lID0gcmVxdWlyZSgnc21hcnRnYW1lJylcclxuXHRcdH1cclxuXHRcdGlmIChzbWFydGdhbWVyID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c21hcnRnYW1lciA9IHJlcXVpcmUoJ3NtYXJ0Z2FtZXInKVxyXG5cdFx0fVxyXG5cdFx0Ly8gY29uc29sZS5sb2codEdvKVxyXG5cdFx0bGV0IHBhcnNlZCA9IHNtYXJ0Z2FtZS5wYXJzZSh0U2dmKVxyXG5cdFx0XHQsIHdyYXBwZWRHYW1lID0gc21hcnRnYW1lcihwYXJzZWQpXHJcblx0XHRcdCwgbm9kZSA9IHdyYXBwZWRHYW1lLm5vZGUoKVxyXG5cdFx0XHQsIHBhc3NlcyA9IDBcclxuXHRcdFx0LCBwZW5kaW5nID0gW11cclxuXHRcdFx0LCBjdXJyZW50UGF0aCA9IHsgbTogMCB9XHJcblx0XHRpZiAobm9kZS5TWiAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGxldCBzeiA9IE51bWJlcihub2RlLlNaKVxyXG5cdFx0XHQvLyBzeis9IDIqb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mud3JhcGFyb3VuZFxyXG5cdFx0XHRvcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IFtzeiwgc3pdXHJcblx0XHRcdHRHby5vcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zXHJcblx0XHRcdHNldFVwTWFya2VycygpXHJcblx0XHR9XHJcblx0XHRpZiAobm9kZS5LTSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG9wdGlvbnMucnVsZXMgPSB7a29taTogcGFyc2VGbG9hdChub2RlLktNKSwgLi4uIG9wdGlvbnMucnVsZXMgfVxyXG5cdFx0fVxyXG5cdFx0bm9kZS5TWiA9IFwiXCIgKyAob3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0gKyAyICogb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mud3JhcGFyb3VuZCkvL25vdCBzdXJlIGhvdyB0byBtYWtlIGEgcmVjdGFuZ3VsYXIgZ29iYW4hXHJcblx0XHQvL29mZnNldCBtb2R1bG9cclxuXHRcdG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFswXSA9IG1vZHVsbyhvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMF0sIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdKVxyXG5cdFx0b3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzFdID0gbW9kdWxvKG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFsxXSwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV0pXHJcblx0XHRsZXQgc2V0TGFiZWxzID0gKCkgPT4ge1xyXG5cdFx0XHQvL25vZGUuTEIgPSAkLndyYXBhcm91bmRBbmRDb29yZHNcclxuXHRcdFx0bGV0IGxhYmVscyA9IFtdXHJcblx0XHRcdGlmIChub2RlLkxCICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRsYWJlbHMgPSBub2RlLkxCXHJcblx0XHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpXHJcblx0XHRcdFx0XHRsYWJlbHMgPSBbbGFiZWxzXVxyXG5cclxuXHRcdFx0XHQvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cclxuXHRcdFx0XHRsZXQgbGFiZWxzMiA9IGxhYmVscy8vXy5jaGFpbihsYWJlbHMpXHJcblx0XHRcdFx0XHQubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNwbGl0KCc6JywgMikgfSkvL2Fzc3VtZSB0aGUgbGFiZWwgZG9lc27igJl0IGNvbnRhaW4g4oCcOuKAnVxyXG5cdFx0XHRcdFx0Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gW3RyYW5zbGF0ZUNvb3JkaW5hdGVzKHhbMF0pLCB4WzFdXSB9KVxyXG5cdFx0XHRcdFx0Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gWyQucHJvamVjdE9uRmxhdCh4WzBdKSwgeFsxXV0gfSlcclxuXHRcdFx0XHQvLyAudmFsdWUoKVxyXG5cdFx0XHRcdGxhYmVscyA9IFtdXHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsYWJlbHMyLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdFx0bGFiZWxzID0gbGFiZWxzLmNvbmNhdChcclxuXHRcdFx0XHRcdFx0bGFiZWxzMltpXVswXS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJC5jb29yZHMyU3RyaW5nKHgpICsgXCI6XCIgKyBsYWJlbHMyW2ldWzFdXHJcblx0XHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQpXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG5vZGUuTEIgPSAkLndyYXBhcm91bmRBbmRDb29yZHMuY29uY2F0KGxhYmVscylcclxuXHRcdFx0aWYgKG5vZGUuTEIubGVuZ3RoID09PSAwKVxyXG5cdFx0XHRcdC8vIGRlbGV0ZSBub2RlWydMQiddXHJcblx0XHRcdFx0ZGVsZXRlIG5vZGUuTEJcclxuXHRcdH1cclxuXHJcblx0XHRzZXRMYWJlbHMoKVxyXG5cclxuXHRcdGlmIChub2RlLlNPICE9PSB1bmRlZmluZWQpXHJcblx0XHRcdG5vZGUuU08gPSB3cmFwcGVkR2FtZS5nYW1lLm5vZGVzWzBdLlNPICsgYCAoJHtzb3VyY2VTZ2ZNZXNzYWdlfSlgXHJcblx0XHQvL2Vsc2Ugbm9kZS5TTyA9IHNvdXJjZVNnZk1lc3NhZ2UvL3ByZWZlciBub3QgdG8gYWRkIHRoZSBtZXNzYWdlIHdoZW4gb3JpZ2luYWwgU2dmIGhhcyBubyBTTyBpbmZvLlxyXG5cclxuXHRcdG5vZGUuQVAgPSBcImdvLXZhcmlhbnRzLXRyYW5zZm9ybWVyXCJcclxuXHJcblxyXG5cdFx0bGV0IHN0YXRlID0geyB3cmFwcGVkR2FtZSwgbm9kZSwgcGVuZGluZywgY3VycmVudFBhdGgsIHRHbyB9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY29tbWVudChpc1Bhc3MsIGlzQmxhY2ssIHNjb3JlKSB7XHJcblx0XHRcdGlmICghb3B0aW9ucy5hZGRDb21tZW50cyAmJiAhc2NvcmUpXHJcblx0XHRcdFx0cmV0dXJuXHJcblxyXG5cdFx0XHRsZXQgciA9ICFvcHRpb25zLmFkZENvbW1lbnRzID9cclxuXHRcdFx0XHQnJ1xyXG5cdFx0XHRcdDogJ21vdmUgJyArIHN0YXRlLmN1cnJlbnRQYXRoLm0gKyAnXFxuJyArICdXaGl0ZSBzdG9uZXMgY2FwdHVyZWQgYnkgQmxhY2s6ICcgKyB0R28uYm9hcmQuY2FwdHVyZWRbMV0gKyAnXFxuQmxhY2sgc3RvbmVzIGNhcHR1cmVkIGJ5IFdoaXRlOiAnICsgdEdvLmJvYXJkLmNhcHR1cmVkWzBdXHJcblx0XHRcdFx0Ly9sZXQgciA9ICAnQmxhY2sgY2FwdHVyZXM6ICcgKyB0R28uYm9hcmQuY2FwdHVyZWRbMV0gKyAnXFxyXFxuV2hpdGUgY2FwdHVyZXM6ICcgKyB0R28uYm9hcmQuY2FwdHVyZWRbMF1cclxuXHRcdFx0XHQrICghaXNQYXNzID8gJycgOiAnXFxuJyArIChpc0JsYWNrID8gJ0JsYWNrIHBhc3NlcycgOiAnV2hpdGUgcGFzc2VzJykpXHJcblx0XHRcdFx0KyAoIXNjb3JlID8gJycgOiAnXFxuJyArIGByZXN1bHQ6ICR7c2NvcmUuZGlzcGxheVJlc3VsdH1gKVxyXG5cclxuXHRcdFx0ciArPSAnXFxuLS0odGhlIGNvbnRlbnQgYWJvdmUgd2FzIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGJ5IEdvVmFyaWFudHNUcmFuc2Zvcm1lciktLSdcclxuXHRcdFx0ciArPSAobm9kZS5DID09PSB1bmRlZmluZWQgPyAnJyA6ICdcXG4nICsgbm9kZS5DKVxyXG5cdFx0XHRub2RlLkMgPSByXHJcblx0XHRcdHJldHVyblxyXG5cdFx0fVxyXG5cclxuXHRcdG5vZGUgPSBnb1Rocm91Z2hUcmVlKHN0YXRlKVxyXG5cdFx0d2hpbGUgKG5vZGUgIT09IG51bGwpIHtcclxuXHJcblxyXG5cdFx0XHRsZXRcclxuXHRcdFx0XHRpc0JsYWNrID0gbm9kZS5CICE9PSB1bmRlZmluZWRcclxuXHRcdFx0XHQsIG1vdmUgPSBpc0JsYWNrID8gbm9kZS5CIDogbm9kZS5XXHJcblx0XHRcdFx0LCBpc1Bhc3MgPSBtb3ZlID09PSBcIlwiIHx8IChvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXSA9PT0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV1cclxuXHRcdFx0XHRcdCYmIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdIDw9IDE5XHJcblx0XHRcdFx0XHQmJiBtb3ZlID09PSBcInR0XCIgLy93ZWlyZCBTR0ZbM10gd2F5IHRvIHNob3cgYSBwYXNzIG1vdmUhXHJcblx0XHRcdFx0KVxyXG5cdFx0XHRcdCwgc3RvbmVzTWFya2VkRm9yU2NvcmluZyA9IFtdXHJcblxyXG5cdFx0XHRpZiAobW92ZSA9PT0gdW5kZWZpbmVkICYmICFpc1Bhc3MpIHtcclxuXHRcdFx0XHRub2RlID0gZ29UaHJvdWdoVHJlZShzdGF0ZSlcclxuXHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHR9XHJcblx0XHRcdHNldExhYmVscygpXHJcblxyXG5cdFx0XHRpZiAoaXNQYXNzKSB7XHJcblx0XHRcdFx0ZGVsZXRlIG5vZGVbaXNCbGFjayA/ICdCJyA6ICdXJ11cclxuXHRcdFx0XHRjb21tZW50KGlzUGFzcywgaXNCbGFjaylcclxuXHRcdFx0XHRub2RlW2lzQmxhY2sgPyAnQUInIDogJ0FXJ10gPSBbXVxyXG5cdFx0XHRcdC8vIGlmIChwYXNzZXMgPT09IDIpIHtcclxuXHRcdFx0XHQvLyBcdC8vd3JhcHBlZEdhbWUuZ2FtZS5ub2Rlcy5zcGxpY2UoaSsxKS8vZ2V0IHJpZCBvZiBub2RlcyBhZnRlcndhcmRzIC0tIG1heSBub3Qgd29yayB3aXRoIHZhcmlhdGlvbnMhIHRvZG9cclxuXHRcdFx0XHQvLyBcdGJyZWFrOy8vc3RvcCBhZnRlciAzIHN1Y2Nlc3NpdmUgcGFzc2VzIGZvciBub3dcclxuXHRcdFx0XHQvLyB9XHJcblx0XHRcdFx0cGFzc2VzKytcclxuXHRcdFx0XHRpZiAocGFzc2VzID49IDEwMDApXHJcblx0XHRcdFx0XHRicmVhay8vanVzdCBpbiBjYXNlIVxyXG5cdFx0XHRcdG5vZGUgPSBnb1Rocm91Z2hUcmVlKHN0YXRlKVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGNvbnN0IGNvb3JkcyA9IHRyYW5zbGF0ZUNvb3JkaW5hdGVzKG1vdmUpXHJcblx0XHRcdFx0bGV0IHBsYXlSZXN1bHQgPSBudWxsXHJcblx0XHRcdFx0Ly8gcnVuIG1vdmUgdGhyb3VnaCB0R28gYW5kIHVwZGF0ZSBnYW1lIGFjY29yZGluZ2x5XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHBsYXlSZXN1bHQgPSB0R28ucGxheShpc0JsYWNrID8gJ2InIDogJ3cnLCBjb29yZHMpXHJcblxyXG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XHJcblx0XHRcdFx0XHRpZiAoZXJyb3IubWVzc2FnZSAhPT0gJ3BvaW50IGlzIG5vdCBlbXB0eScgLyppZ25vcmUgdGhpcyAtIGl0IGhhcHBlbnMgd2l0aCBzb21lIHNnZiBmcm9tIGxpdHRsZUdvbGVtLiBUb2RvOiBsb29rIGludG8gc2NvcmluZyB0aGUgcG9zaXRpb24gaGVyZS4gKi8pXHJcblx0XHRcdFx0XHRcdHRocm93IChlcnJvcilcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y29uc3QgcHJvamVjdGVkQ29vcmRzID0gJC5wcm9qZWN0T25GbGF0KGNvb3JkcylcclxuXHRcdFx0XHRsZXQgdG9BZGQgPSBwbGF5UmVzdWx0ID09PSBudWxsID8gW10gOiBwcm9qZWN0ZWRDb29yZHMubWFwKCQuY29vcmRzMlN0cmluZylcclxuXHRcdFx0XHRcdCwgdG9SZW1vdmUgPSBwbGF5UmVzdWx0ID09PSBudWxsID8gW10gOlxyXG5cdFx0XHRcdFx0XHQvLyBfLmNoYWluKHBsYXlSZXN1bHQucmVtb3ZlZClcclxuXHRcdFx0XHRcdFx0Ly8gXHQuZmxhdHRlbih0cnVlKVxyXG5cdFx0XHRcdFx0XHQvLyBcdC5tYXAoJC5wcm9qZWN0T25GbGF0KVxyXG5cdFx0XHRcdFx0XHQvLyBcdC5mbGF0dGVuKHRydWUpXHJcblx0XHRcdFx0XHRcdC8vIFx0Lm1hcCgkLmNvb3JkczJTdHJpbmcpXHJcblx0XHRcdFx0XHRcdC8vIFx0LnZhbHVlKClcclxuXHRcdFx0XHRcdFx0X2ZsYXR0ZW4oXHJcblx0XHRcdFx0XHRcdFx0X2ZsYXR0ZW4ocGxheVJlc3VsdC5yZW1vdmVkKVxyXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcCgkLnByb2plY3RPbkZsYXQpKVxyXG5cdFx0XHRcdFx0XHRcdC5tYXAoJC5jb29yZHMyU3RyaW5nKVxyXG5cclxuXHRcdFx0XHQvL2FsdGVyIHRoZSBub2RlXHJcblx0XHRcdFx0aWYgKG9wdGlvbnMuYWRkUGFzc2VzKVxyXG5cdFx0XHRcdFx0bm9kZVtpc0JsYWNrID8gJ0InIDogJ1cnXSA9ICcnXHJcblx0XHRcdFx0ZWxzZSBkZWxldGUgbm9kZVtpc0JsYWNrID8gJ0InIDogJ1cnXVxyXG5cdFx0XHRcdC8vIG5vZGVbaXNCbGFjayA/ICdCJyA6ICdXJ10gPSAnJ1xyXG5cdFx0XHRcdG5vZGVbaXNCbGFjayA/ICdBQicgOiAnQVcnXSA9IHRvQWRkXHJcblx0XHRcdFx0aWYgKHRvQWRkLmxlbmd0aCA+IDApXHJcblx0XHRcdFx0XHRub2RlLkNSID0gdG9BZGRcclxuXHRcdFx0XHRpZiAodG9SZW1vdmUubGVuZ3RoID4gMClcclxuXHRcdFx0XHRcdG5vZGUuQUUgPSB0b1JlbW92ZVxyXG5cclxuXHRcdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdFx0dG9kbzogb3RoZXIgcHJvcGVydGllcyB3aXRoIGJvYXJkIGNvb3JkaW5hdGVzXHJcblx0XHRcdFx0XHRcdExlYXZlIGZvciBub3c6XHJcblx0XHRcdFx0XHRcdEFSXHJcblx0XHRcdFx0XHRcdExOXHJcblx0XHRcdFx0XHRcdCovXHJcblxyXG5cdFx0XHRcdFx0XHQ7Lypub3RlIHRoaXMgc2VtaWNvbG9uIGlzIG5lZWRlZCEgKi9cclxuXHRcdFx0XHRbXHJcblx0XHRcdFx0XHQvLydDUicsdG9kbzogYWRkIGlmIG5vdCBtYXJraW5nIHRoZSBtb3ZlXHJcblx0XHRcdFx0XHQnREQnLCAnTUEnLCAnU0wnLCAnU1EnLCAnVFInXS5mb3JFYWNoKGZ1bmN0aW9uIChzZ2ZQcm9wZXJ0eSkge1xyXG5cdFx0XHRcdFx0XHQvLyBfLm1hcChbJ0REJywnTUEnLCdTTCcsJ1NRJywnVFInXSwgZnVuY3Rpb24oc2dmUHJvcGVydHkpe1xyXG5cdFx0XHRcdFx0XHRpZiAobm9kZVtzZ2ZQcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkgcmV0dXJuXHJcblx0XHRcdFx0XHRcdGxldCBwb2ludHMgPSBbXVxyXG5cdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShub2RlW3NnZlByb3BlcnR5XSkpIHtcclxuXHRcdFx0XHRcdFx0XHRwb2ludHMgPSBub2RlW3NnZlByb3BlcnR5XVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHBvaW50cyA9IFtub2RlW3NnZlByb3BlcnR5XV1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZiAobm9kZS5TQyAmJiBzZ2ZQcm9wZXJ0eSA9PT0gJ01BJykge1xyXG5cdFx0XHRcdFx0XHRcdHN0b25lc01hcmtlZEZvclNjb3JpbmcgPSB7IC4uLnBvaW50cyB9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cG9pbnRzID1cclxuXHRcdFx0XHRcdFx0XHQvLyBfLmNoYWluKHBvaW50cylcclxuXHRcdFx0XHRcdFx0XHQvLyBcdC5tYXAodHJhbnNsYXRlQ29vcmRpbmF0ZXMpXHJcblx0XHRcdFx0XHRcdFx0Ly8gXHQubWFwKCQucHJvamVjdE9uRmxhdClcclxuXHRcdFx0XHRcdFx0XHQvLyBcdC5mbGF0dGVuKHRydWUpXHJcblx0XHRcdFx0XHRcdFx0Ly8gXHQubWFwKCQuY29vcmRzMlN0cmluZylcclxuXHRcdFx0XHRcdFx0XHQvLyBcdC52YWx1ZSgpXHJcblx0XHRcdFx0XHRcdFx0X2ZsYXR0ZW4oXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludHNcclxuXHRcdFx0XHRcdFx0XHRcdFx0Lm1hcCh0cmFuc2xhdGVDb29yZGluYXRlcylcclxuXHRcdFx0XHRcdFx0XHRcdFx0Lm1hcCgkLnByb2plY3RPbkZsYXQpXHJcblx0XHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcCgkLmNvb3JkczJTdHJpbmcpXHJcblx0XHRcdFx0XHRcdG5vZGVbc2dmUHJvcGVydHldID0gcG9pbnRzXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdG5vZGUuTU4gPSBjdXJyZW50UGF0aC5tXHJcblxyXG5cdFx0XHRcdC8qXHJcblx0XHRcdFx0VXNlIGEgY3VzdG9tLCBuZXcgU0dGIHByb3BlcnR5LCBTQywgaW4gb3JkZXIgdG8gc2VlIGlmIHRoZSBjdXJyZW50IHBvc2l0aW9uIHNob3VsZCBiZSBzY29yZWQsIGFuZCBpZiBzbywgd2hhdCB0byBkbyB3aXRoIHRoZSBzY29yZS5cclxuXHRcdFx0XHRJdOKAmXMgYSBiaXQgZmxhZy4gIFxyXG5cdFx0XHRcdDFcdOKHkiB1cGRhdGUgdGhlIGNvbW1lbnRzIGZvciB0aGUgbm9kZSAoc3VjY2ludCkuIFdoZW4gZmxhZ2dlZCwgdGhlIG5leHQgb3B0aW9uIGlzIG5vdCBhdmFpbGFibGUuXHJcblx0XHRcdFx0Mlx04oeSIHVwZGF0ZSB0aGUgY29tbWVudHMgZm9yIHRoZSBub2RlICh2ZXJib3NlKVxyXG5cdFx0XHRcdDRcdOKHkiB1cGRhdGUgdGhlIGdhbWUgcmVzdWx0IChSRSkgZm9yIHRoZSByb290IG5vZGVcclxuXHRcdFx0XHRUeXBpY2FsIHVzYWdlOiBhZGQg4oCcU0NbNl3igJ0gdG8gdGhlIGxhc3Qgbm9kZSwgYW5kIOKAnFNDWzJd4oCdIHRvIHNjb3JlIGEgdmFyaWF0aW9uLlxyXG5cdFx0XHRcdCovXHJcblx0XHRcdFx0bGV0IHVwZGF0ZWRDb21tZW50ID0gZmFsc2VcclxuXHRcdFx0XHRpZiAobm9kZS5TQykge1xyXG5cdFx0XHRcdFx0bGV0IHNjb3JlID0gZW5naW5lLnNjb3JlKHN0b25lc01hcmtlZEZvclNjb3JpbmcpXHJcblx0XHRcdFx0XHRpZiAobm9kZS5TQyAmIDEgPT09IDEpIHtcclxuXHRcdFx0XHRcdFx0dXBkYXRlZENvbW1lbnQgPSB0cnVlXHJcblx0XHRcdFx0XHRcdGNvbW1lbnQoaXNQYXNzLCBpc0JsYWNrLCBzY29yZS5SRSlcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgLypkb24ndCB3YW50IHRvIHRyZWF0IHN1Y2NpbnQgYW5kIHZlcmJvc2UgYXQgdGhlIHNhbWUgdGltZSovIGlmIChub2RlLlNDICYgMiA9PT0gMikge1xyXG5cdFx0XHRcdFx0XHR1cGRhdGVkQ29tbWVudCA9IHRydWVcclxuXHRcdFx0XHRcdFx0Y29tbWVudChpc1Bhc3MsIGlzQmxhY2ssXHJcblx0XHRcdFx0XHRcdFx0YEJsYWNrOiAke3Njb3JlLnRvdGFsV2hpdGVEZWFkXHJcblx0XHRcdFx0XHRcdFx0KyBzY29yZS50b3RhbFdoaXRlQ2FwdHVyZWRcclxuXHRcdFx0XHRcdFx0XHQrIHNjb3JlLnRvdGFsQmxhY2tUZXJyaXRvcnl9ID0gJHtzY29yZS50b3RhbEJsYWNrVGVycml0b3J5fSB0ZXJyaXRvcnkgKyAke3Njb3JlLnRvdGFsV2hpdGVEZWFkICsgc2NvcmUudG90YWxXaGl0ZUNhcHR1cmVkfSBwcmlzb25lcnNcclxuV2hpdGU6ICR7c2NvcmUudG90YWxCbGFja0RlYWRcclxuXHRcdFx0XHRcdFx0XHQrIHNjb3JlLnRvdGFsQmxhY2tDYXB0dXJlZFxyXG5cdFx0XHRcdFx0XHRcdCsgc2NvcmUudG90YWxXaGl0ZVRlcnJpdG9yeX0gPSAke3Njb3JlLnRvdGFsV2hpdGVUZXJyaXRvcnl9IHRlcnJpdG9yeSArICR7c2NvcmUudG90YWxCbGFja0RlYWQgKyBzY29yZS50b3RhbEJsYWNrQ2FwdHVyZWR9IHByaXNvbmVycyArJHtlbmdpbmUucnVsZXMua29taX0ga29taWApXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobm9kZS5TQyAmIDQgPT09IDQpIHtcclxuXHRcdFx0XHRcdFx0d3JhcHBlZEdhbWUuZ2FtZS5ub2Rlc1swXS5SRSA9IHNjb3JlLlJFXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghdXBkYXRlZENvbW1lbnQpXHJcblx0XHRcdFx0XHRjb21tZW50KGlzUGFzcywgaXNCbGFjaylcclxuXHJcblx0XHRcdFx0Ly8gbW92ZSB0byBuZXh0IG5vZGVcclxuXHRcdFx0XHRub2RlID0gZ29UaHJvdWdoVHJlZShzdGF0ZSlcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKG9wdGlvbnMudHJhbnNmb3JtVG9TdHJpbmcpXHJcblx0XHRcdHJldHVybiBzbWFydGdhbWUuZ2VuZXJhdGUoeyBnYW1lVHJlZXM6IFt3cmFwcGVkR2FtZS5nYW1lXSB9KTtcclxuXHRcdGVsc2UgcmV0dXJuIHdyYXBwZWRHYW1lXHJcblx0fVxyXG5cdCQudHJhbnNmb3JtID0gdHJhbnNmb3JtXHJcblx0cmV0dXJuICRcclxuXHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1lciJdfQ=="}