{"version":3,"sources":["ui/node_modules/browser-pack/_prelude.js","ui/node_modules/go-variants-engine/node_modules/lodash/_DataView.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Hash.js","ui/node_modules/go-variants-engine/node_modules/lodash/_ListCache.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Map.js","ui/node_modules/go-variants-engine/node_modules/lodash/_MapCache.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Promise.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Set.js","ui/node_modules/go-variants-engine/node_modules/lodash/_SetCache.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Stack.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Symbol.js","ui/node_modules/go-variants-engine/node_modules/lodash/_Uint8Array.js","ui/node_modules/go-variants-engine/node_modules/lodash/_WeakMap.js","ui/node_modules/go-variants-engine/node_modules/lodash/_addMapEntry.js","ui/node_modules/go-variants-engine/node_modules/lodash/_addSetEntry.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayEach.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayFilter.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayLikeKeys.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayMap.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayPush.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arrayReduce.js","ui/node_modules/go-variants-engine/node_modules/lodash/_arraySome.js","ui/node_modules/go-variants-engine/node_modules/lodash/_assignValue.js","ui/node_modules/go-variants-engine/node_modules/lodash/_assocIndexOf.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseAssign.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseAssignIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseAssignValue.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseClone.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseCreate.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseFindIndex.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseGet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseGetAllKeys.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseGetTag.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseHasIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsArguments.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsEqual.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsEqualDeep.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsMatch.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsNative.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIsTypedArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseIteratee.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseKeys.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseKeysIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseMatches.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseMatchesProperty.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseProperty.js","ui/node_modules/go-variants-engine/node_modules/lodash/_basePropertyDeep.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseTimes.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseToString.js","ui/node_modules/go-variants-engine/node_modules/lodash/_baseUnary.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cacheHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_castPath.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneArrayBuffer.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneBuffer.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneDataView.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneMap.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneRegExp.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneSet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneSymbol.js","ui/node_modules/go-variants-engine/node_modules/lodash/_cloneTypedArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_copyArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_copyObject.js","ui/node_modules/go-variants-engine/node_modules/lodash/_copySymbols.js","ui/node_modules/go-variants-engine/node_modules/lodash/_copySymbolsIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_coreJsData.js","ui/node_modules/go-variants-engine/node_modules/lodash/_defineProperty.js","ui/node_modules/go-variants-engine/node_modules/lodash/_equalArrays.js","ui/node_modules/go-variants-engine/node_modules/lodash/_equalByTag.js","ui/node_modules/go-variants-engine/node_modules/lodash/_equalObjects.js","ui/node_modules/go-variants-engine/node_modules/lodash/_freeGlobal.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getAllKeys.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getAllKeysIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getMapData.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getMatchData.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getNative.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getPrototype.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getRawTag.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getSymbols.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getSymbolsIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getTag.js","ui/node_modules/go-variants-engine/node_modules/lodash/_getValue.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hasPath.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hashClear.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hashDelete.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hashGet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hashHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_hashSet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_initCloneArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_initCloneByTag.js","ui/node_modules/go-variants-engine/node_modules/lodash/_initCloneObject.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isIndex.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isKey.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isKeyable.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isMasked.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isPrototype.js","ui/node_modules/go-variants-engine/node_modules/lodash/_isStrictComparable.js","ui/node_modules/go-variants-engine/node_modules/lodash/_listCacheClear.js","ui/node_modules/go-variants-engine/node_modules/lodash/_listCacheDelete.js","ui/node_modules/go-variants-engine/node_modules/lodash/_listCacheGet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_listCacheHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_listCacheSet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapCacheClear.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapCacheDelete.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapCacheGet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapCacheHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapCacheSet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_mapToArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_matchesStrictComparable.js","ui/node_modules/go-variants-engine/node_modules/lodash/_memoizeCapped.js","ui/node_modules/go-variants-engine/node_modules/lodash/_nativeCreate.js","ui/node_modules/go-variants-engine/node_modules/lodash/_nativeKeys.js","ui/node_modules/go-variants-engine/node_modules/lodash/_nativeKeysIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/_nodeUtil.js","ui/node_modules/go-variants-engine/node_modules/lodash/_objectToString.js","ui/node_modules/go-variants-engine/node_modules/lodash/_overArg.js","ui/node_modules/go-variants-engine/node_modules/lodash/_root.js","ui/node_modules/go-variants-engine/node_modules/lodash/_setCacheAdd.js","ui/node_modules/go-variants-engine/node_modules/lodash/_setCacheHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_setToArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stackClear.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stackDelete.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stackGet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stackHas.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stackSet.js","ui/node_modules/go-variants-engine/node_modules/lodash/_stringToPath.js","ui/node_modules/go-variants-engine/node_modules/lodash/_toKey.js","ui/node_modules/go-variants-engine/node_modules/lodash/_toSource.js","ui/node_modules/go-variants-engine/node_modules/lodash/clone.js","ui/node_modules/go-variants-engine/node_modules/lodash/eq.js","ui/node_modules/go-variants-engine/node_modules/lodash/findIndex.js","ui/node_modules/go-variants-engine/node_modules/lodash/get.js","ui/node_modules/go-variants-engine/node_modules/lodash/hasIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/identity.js","ui/node_modules/go-variants-engine/node_modules/lodash/isArguments.js","ui/node_modules/go-variants-engine/node_modules/lodash/isArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/isArrayLike.js","ui/node_modules/go-variants-engine/node_modules/lodash/isBuffer.js","ui/node_modules/go-variants-engine/node_modules/lodash/isFunction.js","ui/node_modules/go-variants-engine/node_modules/lodash/isLength.js","ui/node_modules/go-variants-engine/node_modules/lodash/isObject.js","ui/node_modules/go-variants-engine/node_modules/lodash/isObjectLike.js","ui/node_modules/go-variants-engine/node_modules/lodash/isSymbol.js","ui/node_modules/go-variants-engine/node_modules/lodash/isTypedArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/keys.js","ui/node_modules/go-variants-engine/node_modules/lodash/keysIn.js","ui/node_modules/go-variants-engine/node_modules/lodash/memoize.js","ui/node_modules/go-variants-engine/node_modules/lodash/property.js","ui/node_modules/go-variants-engine/node_modules/lodash/stubArray.js","ui/node_modules/go-variants-engine/node_modules/lodash/stubFalse.js","ui/node_modules/go-variants-engine/node_modules/lodash/toFinite.js","ui/node_modules/go-variants-engine/node_modules/lodash/toInteger.js","ui/node_modules/go-variants-engine/node_modules/lodash/toNumber.js","ui/node_modules/go-variants-engine/node_modules/lodash/toString.js","ui/node_modules/go-variants-engine/src/engine.js","ui/node_modules/lodash/_arrayIncludes.js","ui/node_modules/lodash/_arrayIncludesWith.js","ui/node_modules/lodash/_baseFlatten.js","ui/node_modules/lodash/_baseIndexOf.js","ui/node_modules/lodash/_baseIsNaN.js","ui/node_modules/lodash/_baseUniq.js","ui/node_modules/lodash/_createSet.js","ui/node_modules/lodash/_freeGlobal.js","ui/node_modules/lodash/_isFlattenable.js","ui/node_modules/lodash/_strictIndexOf.js","ui/node_modules/lodash/flatten.js","ui/node_modules/lodash/noop.js","ui/node_modules/lodash/uniqBy.js","ui/node_modules/smartgame/index.js","ui/node_modules/smartgamer/index.js","ui/src/transformer.js","ui/ui/editor.js","ui/ui/editor.jsx"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzFA;AACA;AACA;AACA;AACA;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACnVC;;;AAGD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA+CG;;;;;;AAOH,SAAS,WAAT,CAAqB,OAArB,EACE;AACD;;AACA,KACC,WAAW,QAAQ,gBAAR,CADZ;AAAA,KAEG,UAAU,QAAQ,eAAR,CAFb;AAAA,KA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","file":"editor.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\nmodule.exports = addMapEntry;\n","/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\nmodule.exports = addSetEntry;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isObject = require('./isObject'),\n    keys = require('./keys');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n","var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n","var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n","var addMapEntry = require('./_addMapEntry'),\n    arrayReduce = require('./_arrayReduce'),\n    mapToArray = require('./_mapToArray');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1;\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\nmodule.exports = cloneMap;\n","/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n","var addSetEntry = require('./_addSetEntry'),\n    arrayReduce = require('./_arrayReduce'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1;\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\nmodule.exports = cloneSet;\n","var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n","var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneMap = require('./_cloneMap'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSet = require('./_cloneSet'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n","var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var baseClone = require('./_baseClone');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = clone;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","/* globals module: false, require: false */\r\nmodule.exports = function (options) {\r\n\t'use strict';\r\n\tlet _fi = require('lodash/findIndex')\r\n\t\t// , _iseq = require('lodash/isEqual')\r\n\t\t, _clone = require('lodash/clone')\r\n\t\t//utilities\r\n\t\t// const\r\n\r\n\t\t, _iseq = (x, y) => {\r\n\r\n\t\t\tif (!Array.isArray(x) || !Array.isArray(y)) {\r\n\t\t\t\treturn x == y// eslint-disable-line eqeqeq\r\n\t\t\t\t// return x === y\r\n\t\t\t}\r\n\t\t\tif (x.length !== y.length) return false\r\n\t\t\tfor (let index = 0; index < x.length; index++) {\r\n\t\t\t\tif (!_iseq(x[index], y[index])) {\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn true\r\n\r\n\t\t}\r\n\t\t, myIndexOf = (a, b) => {\r\n\t\t\treturn _fi(a, function (x) { return _iseq(x, b) });\r\n\t\t}\r\n\t// this version, without the _fi dependency, doesn't work!todo\r\n\t//  , myIndexOf = (array, item) => {\r\n\t// \t\tfor (let index = 0; index < array.length; index++) {\r\n\t// \t\t\tif (_iseq(array[index], item)) {\r\n\t// \t\t\t\treturn index;\r\n\r\n\t// \t\t\t}\r\n\t// \t\t\treturn -1;\r\n\t// \t\t}\r\n\r\n\t// \t}\r\n\r\n\t// \t, _clone = require('lodash/clone')\r\n\r\n\r\n\toptions = options || {}\r\n\t// boardMode = options.boardMode || 't'/*t:toroid; c:classic …*/\r\n\t// , boardDimensions = options.boardDimensions || [11, 11]/*move later*/\r\n\t// , rules = options.rules || {\r\n\t// suicide: true,\r\n\t// superko: false\r\n\t// }\r\n\tlet $ = {}\r\n\t////problem with the object spread operator and the build so using Object.assign instead.\r\n\t// $.rules = {\r\n\t// \t\tsuicide: true,\r\n\t// \t\t// superko: false /*⇒todo: enforce when true?*/,\r\n\t// \t\tkomi: 7.5,\r\n\t// \t\t... options.rules\r\n\t// \t}\r\n\t$.rules = Object.assign({}, {\r\n\t\tsuicide: true,\r\n\t\t// superko: false /*⇒todo: enforce when true?*/,\r\n\t\tkomi: 7.5,\r\n\t}, options.rules)\r\n\r\n\t// $.moves = options.moves || []\r\n\t$.options = options\r\n\toptions.boardDimensions = options.boardDimensions || [11, 11]\r\n\toptions.boardMode = options.boardMode || 't'/*t:toroid; c:classic …*/\r\n\t$.board = {}\r\n\t$.board.blackStones = options.blackStones || []\r\n\t$.board.whiteStones = options.whiteStones || []\r\n\r\n\t$.board.nextPlayer = options.nextPlayer || \"b\"\r\n\t$.board.captured = options.captured || [0, 0]\r\n\r\n\t$.exportData = function () {\r\n\t\treturn {\r\n\t\t\tblackStones: $.board.blackStones.map(_clone),\r\n\r\n\t\t\twhiteStones: $.board.whiteStones.map(_clone),\r\n\t\t\tcaptured: _clone($.board.captured),\r\n\t\t\tnextPlayer: $.board.nextPlayer\r\n\t\t}\r\n\t}\r\n\r\n\t$.loadData = function (data) {\r\n\t\t$.board.blackStones = data.blackStones\r\n\t\t$.board.whiteStones = data.whiteStones\r\n\t\t$.board.captured = data.captured\r\n\t\t$.board.nextPlayer = data.nextPlayer\r\n\t}\r\n\r\n\t//toroid\r\n\tif (options.boardMode === 't') $.board.getNeighbours =\r\n\t\tfunction (point) {\r\n\t\t\tlet result = []\r\n\t\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\t\tlet newPoint\r\n\t\t\t\tswitch (i) {\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\tnewPoint = [point[0] + 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tnewPoint = [point[0] - 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] + 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] - 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tresult.push([(newPoint[0] + options.boardDimensions[0]) % options.boardDimensions[0], (newPoint[1] + options.boardDimensions[1]) % options.boardDimensions[1]])\r\n\t\t\t}\r\n\t\t\treturn result\r\n\t\t}\r\n\tif (options.boardMode === 'c') $.board.getNeighbours =\r\n\t\tfunction (point) {\r\n\t\t\tlet result = []\r\n\t\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\t\tlet newPoint\r\n\t\t\t\tswitch (i) {\r\n\t\t\t\t\tcase 0:\r\n\t\t\t\t\t\tnewPoint = [point[0] + 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tnewPoint = [point[0] - 1, point[1]]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] + 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tnewPoint = [point[0], point[1] - 1]\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tif (newPoint[0] >= 0 && newPoint[0] < options.boardDimensions[0]\r\n\t\t\t\t\t&& newPoint[1] >= 0 && newPoint[1] < options.boardDimensions[1]\r\n\t\t\t\t)\r\n\t\t\t\t\tresult.push(newPoint)\r\n\t\t\t}\r\n\t\t\treturn result\r\n\t\t}\r\n\t//todo: klein, projective plane, …\r\n\r\n\t$.board.isEmpty = function (point) {\r\n\t\treturn myIndexOf($.board.blackStones, point) < 0\r\n\t\t\t&& myIndexOf($.board.whiteStones, point) < 0\r\n\t}\r\n\t$.board.getColour = function (point) {\r\n\t\tif (myIndexOf($.board.blackStones, point) >= 0) return 'b'\r\n\t\tif (myIndexOf($.board.whiteStones, point) >= 0) return 'w'\r\n\t\treturn 'e'\r\n\t}\r\n\t/**\r\n\t * Determines if a point is part of a chain with a liberty; if there are no liberties then it returns the chain of stones of the same colour that are connected to `startPoint`. Also used for counting to return connected components of same colour (black, white or empty).\r\n\t * @param {*} startPoint \r\n\t * @param {string|null} chainColour indicates the colour of the starting point.\r\n\t * @param {*} [stopColour='e'] stop working if the chain meets this colour\r\n\t * @param {Function} [getColour=$.board.getColour] Function used to determine the colour of a point.\r\n\t * @returns {bool|array} Returns `true` if the the component meets `stopColour`, and an array containing connected component of points linked to `startPoint` otherwise. \r\n\t */\t\r\n\tfunction chainHasLiberty (startPoint, chainColour, stopColour, getColour) {\r\n\t\tif (stopColour === undefined)\r\n\t\t\tstopColour = 'e'//by default, stop getting the chain when there is a liberty.\r\n\t\tif (getColour === undefined)\r\n\t\t\tgetColour = $.board.getColour//by default, use the usual board colour function\r\n\r\n\t\tif (chainColour === null)\r\n\t\t\tchainColour = getColour(startPoint)\r\n\t\tlet\r\n\t\t\tchain = [startPoint]\r\n\t\t\t, toExplore = []\r\n\t\t\t, point = startPoint //assumed to be of colour chainColour\r\n\r\n\t\twhile (point !== undefined) {\r\n\r\n\t\t\tlet neighbours = $.board.getNeighbours(point)\r\n\t\t\tfor (let i = 0; i < neighbours.length; i++) {\r\n\t\t\t\tlet newPoint = neighbours[i],\r\n\t\t\t\t\tnewColour = getColour(newPoint)\r\n\t\t\t\tif (newColour === stopColour) return true;\r\n\t\t\t\tif (newColour === chainColour) {\r\n\t\t\t\t\tif (myIndexOf(chain, newPoint) < 0) {\r\n\t\t\t\t\t\tchain.push(newPoint)\r\n\t\t\t\t\t\t// if (myIndexOf(toExplore, newPoint) < 0)\r\n\t\t\t\t\t\ttoExplore.push(newPoint)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tpoint = toExplore.pop()\r\n\t\t}\r\n\r\n\t\treturn chain;\r\n\t}\r\n\r\n\t$.board.chainHasLiberty = chainHasLiberty \r\n\r\n\t$.board.score = function (deadStones) {\r\n\t\t/*\r\n\t\tgo through the whole board \r\n\t\t*/\r\n\t\tif (deadStones === undefined) {\r\n\t\t\tdeadStones = []\r\n\t\t}\r\n\r\n\t\tlet result = {\r\n\t\t\tblackEmpty: []\r\n\t\t\t, whiteEmpty: []\r\n\t\t\t, dame: []\r\n\t\t\t, blackAlive: []\r\n\t\t\t, whiteAlive: []\r\n\t\t\t, blackDead: []\r\n\t\t\t, whiteDead: []\r\n\t\t\t, totalBlackCaptured: $.board.captured[0] //nb B stones removed by W during the game\r\n\t\t\t, totalWhiteCaptured: $.board.captured[1] //nb W stones removed by B during the game\r\n\t\t\t//todo:could replace by an class. data stored in a big array of pairs [point, status]\r\n\t\t}\r\n\r\n\t\tfor (let index = 0; index < deadStones.length; index++) {\r\n\t\t\tconst deadStone = deadStones[index];\r\n\t\t\tlet deadColour = $.board.getColour(deadStone)\r\n\t\t\tif (deadColour === 'e') throw new Error('invalid marked dead stone')\r\n\t\t\tlet\r\n\t\t\t\tdeadToFill = deadColour === 'b' ? result.blackDead : result.whiteDead\r\n\t\t\t\t, emptyToFill = deadColour === 'b' ? result.whiteEmpty : result.blackEmpty\r\n\t\t\t\t, aliveToFill = deadColour === 'b' ? result.whiteAlive : result.blackAlive\r\n\t\t\t\t, processPoint = (point, colour) => {\r\n\t\t\t\t\tif (colour === deadColour && myIndexOf(deadToFill, point) < 0) {\r\n\t\t\t\t\t\tdeadToFill.push(point)\r\n\t\t\t\t\t\temptyToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ((colour === deadColour || colour === 'e') && myIndexOf(emptyToFill, point) < 0) {\r\n\t\t\t\t\t\temptyToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (colour !== deadColour && colour !== 'e' && myIndexOf(aliveToFill, point) < 0) {\r\n\t\t\t\t\t\taliveToFill.push(point)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t, getColourForDeadComponent = (point) => {\r\n\t\t\t\t\tlet colour = $.board.getColour(point)\r\n\t\t\t\t\tprocessPoint(point, colour)\r\n\t\t\t\t\treturn colour === deadColour ? 'e' : colour\r\n\t\t\t\t}\r\n\t\t\tprocessPoint(deadStone, deadColour)\r\n\t\t\t$.board.chainHasLiberty(deadStone, 'e', '', getColourForDeadComponent)\r\n\t\t}\r\n\r\n\t\tfor (let i = 0,exitLoop = false; i < options.boardDimensions[0]; i++) {\r\n\t\t\tif (exitLoop) {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tfor (let j = 0; j < options.boardDimensions[1]; j++) {\r\n\t\t\t\tif (result.blackEmpty.length\r\n\t\t\t\t\t+ result.whiteEmpty.length\r\n\t\t\t\t\t+ result.dame.length\r\n\t\t\t\t\t+ result.blackAlive.length\r\n\t\t\t\t\t+ result.whiteAlive.length\r\n\t\t\t\t\t// + result.blackDead.length\r\n\t\t\t\t\t// + result.whiteDead.length\r\n\t\t\t\t\t=== options.boardDimensions[0] * options.boardDimensions[1]\r\n\t\t\t\t) {\r\n\t\t\t\t\texitLoop = true\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t\tconst point = [i, j], colour = $.board.getColour(point)\r\n\r\n\t\t\t\tif (colour === 'b'\r\n\t\t\t\t) {\r\n\t\t\t\t\tif (myIndexOf(result.blackAlive, point) < 0\r\n\t\t\t\t\t\t&& myIndexOf(result.blackDead, point) < 0) {\r\n\t\t\t\t\t\tresult.blackAlive.push(point)\r\n\t\t\t\t\t} else continue\r\n\t\t\t\t}\r\n\t\t\t\tif (colour === 'w') {\r\n\t\t\t\t\tif (myIndexOf(result.whiteAlive, point) < 0\r\n\t\t\t\t\t\t&& myIndexOf(result.whiteDead, point) < 0) {\r\n\t\t\t\t\t\tresult.whiteAlive.push(point)\r\n\t\t\t\t\t} else continue\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (colour === 'e') {\r\n\t\t\t\t\tif (myIndexOf(result.blackEmpty, point) >= 0\r\n\t\t\t\t\t\t|| myIndexOf(result.whiteEmpty, point) >= 0\r\n\t\t\t\t\t\t|| myIndexOf(result.dame, point) >= 0) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet\r\n\t\t\t\t\t\tmeetsBlack = false\r\n\t\t\t\t\t\t, meetsWhite = false\r\n\t\t\t\t\t\t, isBlackTerritory = false\r\n\t\t\t\t\t\t, isWhiteTerritory = false\r\n\t\t\t\t\t\t, getColourForScoring = (point) => {\r\n\r\n\t\t\t\t\t\t\tlet colour = $.board.getColour(point)\r\n\t\t\t\t\t\t\tswitch (colour) {\r\n\t\t\t\t\t\t\t\tcase 'b':\r\n\t\t\t\t\t\t\t\t\tif (myIndexOf(result.blackDead, point) >= 0) {\r\n\t\t\t\t\t\t\t\t\t\tcolour = 'e'\r\n\t\t\t\t\t\t\t\t\t\tisWhiteTerritory = true\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tmeetsBlack = true\r\n\t\t\t\t\t\t\t\t\t\tif (myIndexOf(result.blackAlive, point) < 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tresult.blackAlive.push(point)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase 'w':\r\n\t\t\t\t\t\t\t\t\tif (myIndexOf(result.whiteDead, point) >= 0) {\r\n\t\t\t\t\t\t\t\t\t\tcolour = 'e'\r\n\t\t\t\t\t\t\t\t\t\tisBlackTerritory = true\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\tmeetsWhite = true\r\n\t\t\t\t\t\t\t\t\t\tif (myIndexOf(result.whiteAlive, point) < 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tresult.whiteAlive.push(point)\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\tdefault://nothing needed for 'e'\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn colour\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tlet emptyComponent = $.board.chainHasLiberty(point, 'e', '', getColourForScoring)\r\n\t\t\t\t\tif (!meetsBlack && !meetsWhite) {\r\n\t\t\t\t\t\tthrow new Error('counting an empty board!')\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (isBlackTerritory && isWhiteTerritory) {\r\n\t\t\t\t\t\tthrow new Error('too many stones marked as dead')\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//could store the different empty components: V2 \r\n\t\t\t\t\tif (meetsBlack && meetsWhite) {\r\n\t\t\t\t\t\tresult.dame = result.dame.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (meetsBlack) {\r\n\t\t\t\t\t\tresult.blackEmpty = result.blackEmpty.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (meetsWhite) {\r\n\t\t\t\t\t\tresult.whiteEmpty = result.whiteEmpty.concat(emptyComponent)\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//totals\r\n\t\tresult.totalBlackDead = result.blackDead.length\r\n\t\tresult.totalWhiteDead = result.whiteDead.length\r\n\t\tresult.totalBlackTerritory = result.blackEmpty.length\r\n\t\tresult.totalWhiteTerritory = result.whiteEmpty.length\r\n\r\n\r\n\t\t//todo: implement other rulesets. For now, just do territory + prisoners (Japanese style counting)\r\n\t\tresult.blackScore =\r\n\t\t\tresult.totalWhiteDead\r\n\t\t\t+ result.totalWhiteCaptured\r\n\t\t\t+ result.totalBlackTerritory\r\n\t\tresult.whiteScore =\r\n\t\t\tresult.totalBlackDead\r\n\t\t\t+ result.totalBlackCaptured\r\n\t\t\t+ result.totalWhiteTerritory\r\n\t\t\t+ $.rules.komi\r\n\t\tlet r = result.blackScore - result.whiteScore\r\n\t\tif (r === 0) result.RE = '0'\r\n\t\telse if (r > 0) result.RE = 'B+' + r\r\n\t\telse result.RE = 'W+' + (-r)\r\n\t\treturn result\r\n\t}\r\n\r\n\t$.board.empty = function () {\r\n\t\t$.board.whiteStones = []\r\n\t\t$.board.blackStones = []\r\n\t\t$.board.captured = [0, 0]\r\n\r\n\t}\r\n\r\n\t$.removeChain = function (chain, colour) {\r\n\t\tlet toRemoveFrom = colour === 'w' ? $.board.whiteStones : $.board.blackStones\r\n\t\tfor (let j = 0; j < chain.length; j++) {\r\n\t\t\tlet index = myIndexOf(toRemoveFrom, chain[j])\r\n\t\t\ttoRemoveFrom.splice(index, 1)\r\n\t\t\tif (colour === 'w') $.board.captured[1] = $.board.captured[1] + 1\r\n\t\t\telse $.board.captured[0] = $.board.captured[0] + 1\r\n\t\t}\r\n\t}\r\n\t$.play = function (playerColour, point) {\r\n\r\n\r\n\r\n\t\t// let result = \"ok\"\r\n\t\tif (!$.board.isEmpty(point))\r\n\t\t\tthrow new Error('point is not empty')\r\n\t\t// console.log('point is not empty' + point)\r\n\r\n\t\tif (playerColour === 'b') $.board.blackStones.push(point)\r\n\t\telse $.board.whiteStones.push(point)\r\n\r\n\t\tlet neighbours = $.board.getNeighbours(point)\r\n\t\t\t, removed = []//chains removed\r\n\r\n\t\tfor (let i = 0; i < neighbours.length; i++) {\r\n\t\t\tlet neighbour = neighbours[i], colour = $.board.getColour(neighbour)\r\n\t\t\tif (colour === playerColour || colour === 'e') continue\r\n\t\t\tlet oppColour = $.getOppositeColour(playerColour),\r\n\t\t\t\tr = $.board.chainHasLiberty(neighbour, oppColour)\r\n\t\t\tif (r === true) continue\r\n\t\t\t////remove - no liberties\r\n\t\t\tremoved[removed.length] = r\r\n\r\n\t\t\t$.removeChain(r, oppColour)\r\n\r\n\t\t\t// let chainToRemove = r[1],\r\n\t\t\t// toRemoveFrom = playerColour === 'b' ? $.board.whiteStones : $.board.blackStones\r\n\t\t\t// for (let j = 0; j<chainToRemove.length; j++)\r\n\t\t\t// {\r\n\t\t\t// let index = myIndexOf(toRemoveFrom,chainToRemove[j])\r\n\t\t\t// toRemoveFrom.splice(index, 1)\r\n\t\t\t// if (playerColour === 'b') $.board.captured[1] = $.board.captured[1] + 1\r\n\t\t\t// else $.board.captured[0] = $.board.captured[0] + 1\r\n\t\t\t// }\r\n\t\t\t// removed = true\r\n\t\t}\r\n\t\tlet suicide = false\r\n\t\tif (removed.length === 0) {\r\n\t\t\tlet s = $.board.chainHasLiberty(point, playerColour)\r\n\t\t\tif (s !== true) {\r\n\t\t\t\tif ($.rules.suicide) {\r\n\t\t\t\t\t$.removeChain(s, playerColour)\r\n\t\t\t\t\tsuicide = s\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthrow new Error('suicide')//isn’t allowed\r\n\t\t\t\t\t//todo: remove point from whiteStones or blackStones\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t\tstoring the situation in memory - would be useful when implementing going back a move, superko, …\r\n\t\t\tnot needed for now\r\n\t\t*/\r\n\t\t//$.moves.push([playerColour,point,_.clone($.board.whiteStones),_.clone($.board.blackStones)])\r\n\t\t// $.moves.push([playerColour,point])\r\n\r\n\t\t// getNeighbours[i] = [getNeighbours[i], $.board.getColour[getNeighbours[i]]\r\n\t\t// //…\r\n\r\n\r\n\t\treturn { removed, suicide }\r\n\t}\r\n\t$.getOppositeColour = function (colour) {\r\n\t\tswitch (colour) {\r\n\t\t\tcase 'b':\r\n\t\t\t\treturn 'w'\r\n\t\t\tcase 'w':\r\n\t\t\t\treturn 'b'\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\treturn $\r\n\r\n}","var baseIndexOf = require('./_baseIndexOf');\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n","/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIsNaN = require('./_baseIsNaN'),\n    strictIndexOf = require('./_strictIndexOf');\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n","/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    cacheHas = require('./_cacheHas'),\n    createSet = require('./_createSet'),\n    setToArray = require('./_setToArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n","var Set = require('./_Set'),\n    noop = require('./noop'),\n    setToArray = require('./_setToArray');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n","var baseFlatten = require('./_baseFlatten');\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var baseIteratee = require('./_baseIteratee'),\n    baseUniq = require('./_baseUniq');\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }, { 'x': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\n}\n\nmodule.exports = uniqBy;\n","/**\n * Convert SGF files to a JS object\n * @param {string} sgf A valid SGF file.\n * @see http://www.red-bean.com/sgf/sgf4.html\n * @return {object} The SGF file represented as a JS object\n */\nexports.parse = function (sgf) {\n\t'use strict';\n\n\tvar parse;\n\tvar parser;\n\tvar collection = {};\n\n\t// tracks the current sequence\n\tvar sequence;\n\n\t// tracks the current node\n\tvar node;\n\n\t// tracks the last PropIdent\n\tvar lastPropIdent;\n\n\t// A map of functions to parse the different components of an SGF file\n\tparser = {\n\n\t\tbeginSequence: function (sgf) {\n\t\t\tvar key = 'sequences';\n\n\t\t\t// Top-level sequences are gameTrees\n\t\t\tif (!sequence) {\n\t\t\t\tsequence = collection;\n\t\t\t\tkey = 'gameTrees';\n\t\t\t}\n\n\t\t\tif (sequence.gameTrees) {\n\t\t\t\tkey = 'gameTrees';\n\t\t\t}\n\n\t\t\tvar newSequence = {\n\t\t\t\tparent: sequence\n\t\t\t};\n\n\t\t\tsequence[key] = sequence[key] || [];\n\t\t\tsequence[key].push(newSequence);\n\t\t\tsequence = newSequence;\n\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tendSequence: function (sgf) {\n\t\t\tif (sequence.parent) {\n\t\t\t\tsequence = sequence.parent;\n\t\t\t} else {\n\t\t\t\tsequence = null;\n\t\t\t}\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tnode: function (sgf) {\n\t\t\tnode = {};\n\t\t\tsequence.nodes = sequence.nodes || [];\n\t\t\tsequence.nodes.push(node);\n\t\t\treturn sgf.substring(1);\n\t\t},\n\n\t\tproperty: function (sgf) {\n\t\t\tvar propValue;\n\n\t\t\t// Search for the first unescaped ]\n\t\t\tvar firstPropEnd = sgf.match(/([^\\\\\\]]|\\\\(.|\\n|\\r))*\\]/);\n\n\t\t\tif (!firstPropEnd.length) {\n\t\t\t\tthrow new Error('malformed sgf');\n\t\t\t}\n\n\t\t\tfirstPropEnd = firstPropEnd[0].length;\n\n\t\t\tvar property = sgf.substring(0, firstPropEnd);\n\t\t\tvar propValueBegin = property.indexOf('[');\n\t\t\tvar propIdent = property.substring(0, propValueBegin);\n\n\t\t\t// Point lists don't declare a PropIdent for each PropValue\n\t\t\t// Instead, they should use the last declared property\n\t\t\t// See: http://www.red-bean.com/sgf/sgf4.html#move/pos\n\t\t\tif (!propIdent) {\n\t\t\t\tpropIdent = lastPropIdent;\n\n\t\t\t\t// If this is the first property in a list of multiple\n\t\t\t\t// properties, we need to wrap the PropValue in an array\n\t\t\t\tif (!Array.isArray(node[propIdent])) {\n\t\t\t\t\tnode[propIdent] = [node[propIdent]];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlastPropIdent = propIdent;\n\n\t\t\tpropValue = property.substring(propValueBegin + 1, property.length - 1);\n\n\t\t\t// We have no problem parsing PropIdents of any length, but the spec\n\t\t\t// says they should be no longer than two characters.\n\t\t\t//\n\t\t\t// http://www.red-bean.com/sgf/sgf4.html#2.2\n\t\t\tif (propIdent.length > 2) {\n\t\t\t\t// TODO: What's the best way to issue a warning?\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'SGF PropIdents should be no longer than two characters:', propIdent\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (Array.isArray(node[propIdent])) {\n\t\t\t\tnode[propIdent].push(propValue);\n\t\t\t} else {\n\t\t\t\tnode[propIdent] = propValue;\n\t\t\t}\n\n\t\t\treturn sgf.substring(firstPropEnd);\n\t\t},\n\n\t\t// Whitespace, tabs, or anything else we don't recognize\n\t\tunrecognized: function (sgf) {\n\n\t\t\t// March ahead to the next character\n\t\t\treturn sgf.substring(1);\n\t\t}\n\t};\n\n\t// Processes an SGF file character by character\n\tparse = function (sgf) {\n\t\twhile (sgf) {\n\t\t\tvar initial = sgf.substring(0, 1);\n\t\t\tvar type;\n\n\t\t\t// Use the initial (the first character in the remaining sgf file) to\n\t\t\t// decide which parser function to use\n\t\t\tif (initial === '(') {\n\t\t\t\ttype = 'beginSequence';\n\t\t\t} else if (initial === ')') {\n\t\t\t\ttype = 'endSequence';\n\t\t\t} else if (initial === ';') {\n\t\t\t\ttype = 'node';\n\t\t\t} else if (initial.search(/[A-Z\\[]/) !== -1) {\n\t\t\t\ttype = 'property';\n\t\t\t} else {\n\t\t\t\ttype = 'unrecognized';\n\t\t\t}\n\n\t\t\tsgf = parser[type](sgf);\n\t\t}\n\n\t\treturn collection;\n\t};\n\n\t// Begin parsing the SGF file\n\treturn parse(sgf);\n};\n\n/**\n * Generate an SGF file from a SmartGame Record JavaScript Object\n * @param {object} record A record object.\n * @return {string} The record as a string suitable for saving as an SGF file\n */\nexports.generate = function (record) {\n\t'use strict';\n\n\tfunction stringifySequences(sequences) {\n\t\tvar contents = '';\n\n\t\tsequences.forEach(function (sequence) {\n\t\t\tcontents += '(';\n\n\t\t\t// Parse all nodes in this sequence\n\t\t\tif (sequence.nodes) {\n\t\t\t\tsequence.nodes.forEach(function (node) {\n\t\t\t\t\tvar nodeString = ';';\n\t\t\t\t\tfor (var property in node) {\n\t\t\t\t\t\tif (node.hasOwnProperty(property)) {\n\t\t\t\t\t\t\tvar prop = node[property];\n\t\t\t\t\t\t\tif (Array.isArray(prop)) {\n\t\t\t\t\t\t\t\tprop = prop.join('][');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnodeString += property + '[' + prop + ']';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontents += nodeString;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Call the function we're in recursively for any child sequences\n\t\t\tif (sequence.sequences) {\n\t\t\t\tcontents += stringifySequences(sequence.sequences);\n\t\t\t}\n\n\t\t\tcontents += ')';\n\t\t});\n\n\t\treturn contents;\n\t}\n\n\treturn stringifySequences(record.gameTrees);\n};\n\n","/**\n * Interact with smartgame objects.\n * @param {object} smartgame A JS Object representing a smartgame\n * @see http://www.red-bean.com/sgf/sgf4.html\n * @return {object} An object with methods for navigating and manipulating a\n * smartgame\n */\nmodule.exports = function (smartgame) {\n\t'use strict';\n\n\tvar sequence;\n\tvar node;\n\n\tvar Smartgamer = function () {\n\t\tthis.init();\n\t};\n\n\tSmartgamer.prototype = {\n\t\tinit: function () {\n\t\t\tif (smartgame) {\n\t\t\t\tthis.game = smartgame.gameTrees[0];\n\t\t\t\tthis.reset();\n\t\t\t}\n\t\t},\n\n\t\t// Load a smartgame to make it possible to load new games or add one after\n\t\t// initialization, if desired\n\t\tload: function (newSmartgame) {\n\t\t\tsmartgame = newSmartgame;\n\t\t\tthis.init();\n\t\t},\n\n\t\t// Having multiple games in a collection is not common, but it's part of\n\t\t// the spec\n\t\tgames: function () {\n\t\t\treturn smartgame.gameTrees;\n\t\t},\n\n\t\tselectGame: function (i) {\n\t\t\tif (i < smartgame.gameTrees.length) {\n\t\t\t\tthis.game = smartgame.gameTrees[i];\n\t\t\t\tthis.reset();\n\t\t\t} else {\n\t\t\t\tthrow new Error('the collection doesn\\'t contain that many games');\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\treset: function () {\n\t\t\tsequence = this.game;\n\t\t\tnode = sequence.nodes[0];\n\t\t\tthis.path = { m: 0 };\n\n\t\t\treturn this;\n\t\t},\n\n\t\tgetSmartgame: function () {\n\t\t\treturn smartgame;\n\t\t},\n\n\t\t/**\n\t\t * Return any variations available at the current move\n\t\t **/\n\t\tvariations: function () {\n\t\t\tif (sequence) {\n\t\t\t\tvar localNodes = sequence.nodes;\n\t\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t\tif (localNodes) {\n\t\t\t\t\tif (localIndex === (localNodes.length - 1)) {\n\t\t\t\t\t\treturn sequence.sequences || [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Go to the next move\n\t\t **/\n\t\tnext: function (variation) {\n\t\t\tvariation = variation || 0;\n\n\t\t\tvar localNodes = sequence.nodes;\n\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t// If there are no additional nodes in this sequence,\n\t\t\t// advance to the next one\n\t\t\tif (localIndex === null || localIndex >= (localNodes.length - 1)) {\n\t\t\t\tif (sequence.sequences) {\n\t\t\t\t\tif (sequence.sequences[variation]) {\n\t\t\t\t\t\tsequence = sequence.sequences[variation];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsequence = sequence.sequences[0];\n\t\t\t\t\t}\n\n\t\t\t\t\tnode = sequence.nodes[0];\n\n\t\t\t\t\t// Note the fork chosen for this variation in the path\n\t\t\t\t\tthis.path[this.path.m] = variation;\n\t\t\t\t\tthis.path.m += 1;\n\t\t\t\t} else {\n\t\t\t\t\t// End of sequence / game\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = localNodes[localIndex + 1];\n\t\t\t\tthis.path.m += 1;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Go to the previous move\n\t\t **/\n\t\tprevious: function () {\n\t\t\tvar localNodes = sequence.nodes;\n\t\t\tvar localIndex = (localNodes) ? localNodes.indexOf(node) : null;\n\n\t\t\t// Delete any variation forks at this point\n\t\t\t// TODO: Make this configurable... we should keep this if we're\n\t\t\t// remembering chosen paths\n\t\t\tdelete this.path[this.path.m];\n\n\t\t\tif (!localIndex || localIndex === 0) {\n\t\t\t\tif (sequence.parent && !sequence.parent.gameTrees) {\n\t\t\t\t\tsequence = sequence.parent;\n\t\t\t\t\tif (sequence.nodes) {\n\t\t\t\t\t\tnode = sequence.nodes[sequence.nodes.length - 1];\n\t\t\t\t\t\tthis.path.m -= 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode = null;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Already at the beginning\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = localNodes[localIndex - 1];\n\t\t\t\tthis.path.m -= 1;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t// Go to the last move of the game\n\t\tlast: function () {\n\t\t\tvar totalMoves = this.totalMoves();\n\n\t\t\twhile(this.path.m < totalMoves) {\n\t\t\t\tthis.next();\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t// Go to the first move of the game\n\t\tfirst: function () {\n\t\t\tthis.reset();\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n\t\t * Go to a particular move, specified as a\n\t\t * a) number\n\t\t * b) path string\n\t\t * c) path object\n\t\t **/\n\t\tgoTo: function (path) {\n\t\t\tif (typeof path === 'string') {\n\t\t\t\tpath = this.pathTransform(path, 'object');\n\t\t\t} else if (typeof path === 'number') {\n\t\t\t\tpath = { m: path };\n\t\t\t}\n\n\t\t\tthis.reset();\n\n\t\t\tvar n = node;\n\n\t\t\tfor (var i = 0; i < path.m && n; i += 1) {\n\t\t\t\t// Check for a variation in the path for the upcoming move\n\t\t\t\tvar variation = path[i + 1] || 0;\n\t\t\t\tn = this.next(variation);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tgetGameInfo: function () {\n\t\t\treturn this.game.nodes[0];\n\t\t},\n\n\t\t// Provide the current node\n\t\tnode: function () {\n\t\t\treturn node;\n\t\t},\n\n\t\t// Get the total number of moves in a game\n\t\ttotalMoves: function () {\n\t\t\tvar localSequence = this.game;\n\t\t\tvar moves = 0;\n\t\t\twhile(localSequence) {\n\t\t\t\tmoves += localSequence.nodes.length;\n\n\t\t\t\tif (localSequence.sequences) {\n\t\t\t\t\tlocalSequence = localSequence.sequences[0];\n\t\t\t\t} else {\n\t\t\t\t\tlocalSequence = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: Right now we're *assuming* that the root node doesn't have a\n\t\t\t// move in it, which is *recommended* but not required practice.\n\t\t\t// @see http://www.red-bean.com/sgf/sgf4.html\n\t\t\t// \"Note: it's bad style to have move properties in root nodes.\n\t\t\t// (it isn't forbidden though)\"\n\t\t\treturn moves - 1;\n\t\t},\n\n\t\t// Get or set a comment on the current node\n\t\t// @see http://www.red-bean.com/sgf/sgf4.html#text\n\t\tcomment: function (text) {\n\t\t\tif (typeof text === 'undefined') {\n\t\t\t\t// Unescape characters\n\t\t\t\tif (node.C) {\n\t\t\t\t\treturn node.C.replace(/\\\\([\\\\:\\]])/g, '$1');\n\t\t\t\t} else {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Escape characters\n\t\t\t\tnode.C = text.replace(/[\\\\:\\]]/g, '\\\\$&');\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Translate alpha coordinates into an array\n\t\t * @param string alphaCoordinates\n\t\t * @return array [x, y]\n\t\t **/\n\t\ttranslateCoordinates: function (alphaCoordinates) {\n\t\t\tvar coordinateLabels = 'abcdefghijklmnopqrst';\n\t\t\tvar intersection = [];\n\n\t\t\tintersection[0] = coordinateLabels.indexOf(alphaCoordinates.substring(0, 1));\n\t\t\tintersection[1] = coordinateLabels.indexOf(alphaCoordinates.substring(1, 2));\n\n\t\t\treturn intersection;\n\t\t},\n\n\t\t/**\n\t\t * Convert path objects to strings and path strings to objects\n\t\t **/\n\t\tpathTransform: function (input, outputType, verbose) {\n\t\t\tvar output;\n\n\t\t\t// If no output type has been specified, try to set it to the\n\t\t\t// opposite of the input\n\t\t\tif (typeof outputType === 'undefined') {\n\t\t\t\toutputType = (typeof input === 'string') ? 'object' : 'string';\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Turn a path object into a string.\n\t\t\t */\n\t\t\tfunction stringify(input) {\n\t\t\t\tif (typeof input === 'string') {\n\t\t\t\t\treturn input;\n\t\t\t\t}\n\n\t\t\t\tif (!input) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\n\t\t\t\toutput = input.m;\n\n\t\t\t\tvar variations = [];\n\t\t\t\tfor (var key in input) {\n\t\t\t\t\tif (input.hasOwnProperty(key) && key !== 'm') {\n\t\t\t\t\t\t// Only show variations that are not the primary one, since\n\t\t\t\t\t\t// primary variations are chosen by default\n\t\t\t\t\t\tif (input[key] > 0) {\n\t\t\t\t\t\t\tif (verbose) {\n\t\t\t\t\t\t\t\tvariations.push(', variation ' + input[key] + ' at move ' + key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvariations.push('-' + key + ':' + input[key]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\toutput += variations.join('');\n\t\t\t\treturn output;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Turn a path string into an object.\n\t\t\t */\n\t\t\tfunction parse(input) {\n\t\t\t\tif (typeof input === 'object') {\n\t\t\t\t\tinput = stringify(input);\n\t\t\t\t}\n\n\t\t\t\tif (!input) {\n\t\t\t\t\treturn { m: 0 };\n\t\t\t\t}\n\n\t\t\t\tvar path = input.split('-');\n\t\t\t\toutput = {\n\t\t\t\t\tm: Number(path.shift())\n\t\t\t\t};\n\n\t\t\t\tif (path.length) {\n\t\t\t\t\tpath.forEach(function (variation, i) {\n\t\t\t\t\t\tvariation = variation.split(':');\n\t\t\t\t\t\toutput[Number(variation[0])] = parseInt(variation[1], 10);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn output;\n\t\t\t}\n\n\t\t\tif (outputType === 'string') {\n\t\t\t\toutput = stringify(input);\n\t\t\t} else if (outputType === 'object') {\n\t\t\t\toutput = parse(input);\n\t\t\t} else {\n\t\t\t\toutput = undefined;\n\t\t\t}\n\n\t\t\treturn output;\n\t\t}\n\t};\n\n\treturn new Smartgamer();\n};\n","﻿/* globals module: false, require: false\r\n\r\n*/\r\n/**\r\n * Provides a function for transforming SGF for a Go variant to SGF for a standard Go viewer; also provides a function for the inverse transformation.\r\n * @param {object} [options=] Defines various options for the output SGF. May be omitted, in which case the default options (see below) are used.\r\n * @param {boolean} [options.addComments = false] When flagged, comments are added to each node giving the move number and the number of stones captured by Black and White.\r\n * @param {boolean} [options.addMoveNumber = false] When flagged, `MN[<moveNumber>]` is added to each node.\r\n * @param {number} [options.moveType = 2] Controls how moves are represented in the transformed SGF. Examples given for black moves, so with option 2 a white move is represented by `W[point]AW[otherPoints]`. Options: \r\n * \r\n * - 0: `AB[points]`;\r\n * \r\n * - 1: `AB[points]B[]` (same as for `moveType===0` but with the “pass” (“B[]”);\r\n * \r\n * - 2: `B[point]AB[otherPoints]` where `point` is the coordinates of the move in the main board (a single point), and `otherPoints` is an array of the coordinates of the move in the wraparound area.;\r\n * \r\n * - 3: `B[points]`;\r\n * \r\n * @param {string} [options.markLastMove = null] Gives the SGF attribute to be created to mark each move. May be left empty/null/undefined. Or else a value like `\"CR\"`.\r\n * @param {array} [options.boardDimensions = [11, 11]] May be used for rectangular t-Go. Should be ommitted for [n, n] t-Go, where n is specified in the input SGF (@param variantSgf).\r\n * @param {number} [options.coordinatesType = 0] Options: \r\n * \r\n * - 0: none;\r\n * \r\n * - 1: (→↑;A|1-K|11): Western;\r\n * \r\n * - 2: (→↑;A|1-L|11): Western, no “I”;\r\n * \r\n * - 3: (→↓;1|1-11|11): Latin/Latin, top to bottom;\r\n * \r\n * - 4: (→↓;1|1-11|十一): Latin/Chinese, top to bottom;\r\n * \r\n * @param {number} [options.wraparoundMarkersType = 1] Options:\r\n * \r\n * - 0: none;\r\n * \r\n * - 1: Full outline, using unicode Box Drawing symbols;\r\n * \r\n * - 2: corners and middles, using unicode Box Drawing symbols;\r\n * \r\n * - 3: just corners, using unicode Box Drawing symbols;\r\n * \r\n * - 4: just middles, using unicode Box Drawing symbols;\r\n * \r\n * @param {object} [options.projectionSettings=] Further optional settings for how the (toroidal, or other sort of) board is projected to a flat grid.\r\n * @param {number} [options.projectionSettings.wraparound = 4]  Number of lines to add for the “wraparound”.\r\n * @param {array} [options.projectionSettings.offset = [0,0]]  Translation to apply to all moves.\r\n * @param {boolean} [options.transformToString=true] When set to false, the output is an object (an instance of a Smartgame).\r\n * @public\r\n * @return {object} An object exposing functions for going back and forth between SGF for a standard viewer, and SGF for a game of toroidal Go\r\n *//*todos:\r\nopions.placesToCount Default: undefined. May be: 'last'|[countInfo1, .. countInfo1]. countInfo is a path plus an array with a point for each chain to be considered as dead. {path, deadChains: [...]}\r\noptions.projectionSettings.rotation {integer} Default value: 0. Allowed values: 0 .. 3\r\noptions.projectionSettings.normalizePlace array, or one of: C, TL TR BL BR (centre, top left, top right, bottom left, bottom right)\r\noptions.projectionSettings.normalize {boolean} \r\n\r\n*/\r\nfunction transformer(options\r\n) {\r\n\t'use strict';\r\n\tconst\r\n\t\t_flatten = require('lodash/flatten')\r\n\t\t, _uniqBy = require('lodash/uniqBy')\r\n\t\t, _fi = require('lodash/findIndex')\r\n\t\t, modulo = (x, y) => (x % y + y) % y\r\n\t\t, sourceSgfMessage = 'source sgf for toroidal Go has been adapted by go-variants-transformer so as to be rendered by any standard Go application'\r\n\toptions = {\r\n\t\tboardDimensions: [11, 11]\r\n\t\t, transformToString: true\r\n\t\t, addComments: true\r\n\t\t, coordinatesType: 0\r\n\t\t, wraparoundMarkersType: 1\r\n\t\t, moveType: 2\r\n\t\t, markLastMove: null\r\n\t\t//above are the defaults\r\n\t\t, ...options\r\n\t}\r\n\toptions.projectionSettings =\r\n\t\t{\r\n\t\t\twraparound: 4,\r\n\t\t\toffset: [0, 0],\r\n\t\t\t...options.projectionSettings\r\n\t\t}\r\n\r\n\tif (options.addPasses === undefined)\r\n\t\toptions.addPasses = true;\r\n\r\n\toptions.boardDimensions = options.boardDimensions || [11, 11]\r\n\r\n\tif (options.transformToString === undefined)\r\n\t\toptions.transformToString = true;\r\n\r\n\tif (options.addComments === undefined)\r\n\t\toptions.addComments = true;\r\n\t// options.projectionSettings = \r\n\r\n\tlet wraparound = options.projectionSettings.wraparound\r\n\r\n\tlet $ = {}\r\n\t\t// , _markersForWraparound = null\r\n\t\t, coordinateLabels = function (i) {\r\n\t\t\t// 97..122 and 65..90\r\n\t\t\treturn String.fromCharCode(i < 26 ? i + 97 : i + 39)\r\n\t\t\t//65 - 26 =\r\n\t\t}\r\n\t\t,\r\n\t\ttranslateCoordinate = (c) => {\r\n\t\t\tlet r = c.charCodeAt(0)\r\n\t\t\treturn r >= 97 ? r - 97 : r - 26\r\n\t\t},\r\n\t\t/**\r\n\t\t * Translate alpha coordinates into an array\r\n\t\t * @param string alphaCoordinates\r\n\t\t * @return array [x, y]\r\n\t\t **/\r\n\t\ttranslateCoordinates = (alphaCoordinates) => {\r\n\t\t\treturn [translateCoordinate(alphaCoordinates.substring(0, 1))\r\n\t\t\t\t, translateCoordinate(alphaCoordinates.substring(1, 2))]\r\n\r\n\t\t}\r\n\r\n\r\n\t$.coordinateLabels = coordinateLabels\r\n\t$.translateCoordinates = translateCoordinates\r\n\t/**\r\n\t * @public\r\n\t */\r\n\t$.options = options\r\n\r\n\t$.projectOnLine = function (a, isVertical) {\r\n\t\t/*\r\n\t\tm: boardDimensions[0] : 11\r\n\t\tn: wraparound : 4\r\n\t\tline: 0,...,(m-1)\r\n\t\t=>\r\n\t\t0,...,(n-1), (start line) n, ... , (n + m - 1) end line,  (n+m), ... , (2n + m - 1)\r\n\r\n\t\tcoordinate a ∈ {0 .. m-1} projects to n + a in main area\r\n\t\tall projections are of the form n + a + xm, x ∈ ℤ s.t. 0 ≤ n + a + xm ≤ 2n + m -1\r\n\t\t-xm ≤ n + a\r\n\t\t\tsmallest such x < 0 is ceil(-(n+a)/m)\r\n\t\t xm ≤ n + m - 1 -a\r\n\t\t\tlargest such x is floor((n + m - 1 -a) / m)\r\n\r\n\r\n\t\t*/\r\n\r\n\t\tconst m //= options.boardDimensions[0]\r\n\t\t\t= options.boardDimensions[isVertical ? 1 : 0]\r\n\r\n\t\t\t, r = []\r\n\r\n\t\tfor (let i = Math.ceil(-(wraparound + a) / m); i <= (wraparound + m - 1 - a) / m; i++)\r\n\t\t\tr.push(wraparound + a + i * m)\r\n\r\n\t\tif (options.moveType === 2) {//ensure the last item in the result is the one inside the main board area\r\n\t\t\tr.sort((x, y) => {\r\n\t\t\t\tif (x >= wraparound && x < wraparound + m) return 1\r\n\t\t\t\tif (y >= wraparound && y < wraparound + m) return -1\r\n\t\t\t\treturn 0\r\n\t\t\t})\r\n\t\t}\r\n\t\treturn r\r\n\t}\r\n\r\n\t/**\r\n\t * This is the inverse function to the function “projectOnFlat” – at least it is when “multiple” is false.\r\n\t * @param {Array} points The point or array of points projected onto the grid.\r\n\t * @param {Boolean=false} multiple Whether the argument “points” is the image of a single point (“multiple=false”) or of multiple points.\r\n\t * @returns {Array} When the flag “multiple” is flagged, returns an array of points; otherwise returns a single point (i.e. an array of two integers).\r\n\t */\r\n\tfunction inverseProjectOnFlat(points, multiple) {\r\n\t\tif (!Array.isArray(points[0])) points = [points]\r\n\t\tif (!multiple)\r\n\t\t\treturn [modulo(points[0][0] - options.projectionSettings.offset[0] - wraparound, options.boardDimensions[0])\r\n\t\t\t\t, modulo(points[0][1] - options.projectionSettings.offset[1] - wraparound, options.boardDimensions[1])]\r\n\t\treturn _uniqBy(points.map(x => inverseProjectOnFlat([x])), (x) => `${x[0]}_${x[1]}`)\r\n\t}\r\n\t$.inverseProjectOnFlat = inverseProjectOnFlat\r\n\r\n\t/**\r\n\t * Projects a point on the t-Go board to the array of points on the standard grid/board.\r\n\t * @param {Array} p The point in the t-Go board to be projected on to the grid.\r\n\t * @returns {Array}\r\n\t */\r\n\tfunction projectOnFlat(p) {\r\n\t\tconst a = $.projectOnLine(p[0] + options.projectionSettings.offset[0])\r\n\t\t\t, b = $.projectOnLine(p[1] + options.projectionSettings.offset[1], true)\r\n\t\t\t, r = []\r\n\t\tfor (let i = 0; i < a.length; i++)\r\n\t\t\tfor (let j = 0; j < b.length; j++)\r\n\t\t\t\tr.push([a[i], b[j]])\r\n\t\treturn r\r\n\t}\r\n\t$.projectOnFlat = projectOnFlat\r\n\r\n\t$.modX = (x) => modulo(x, options.boardDimensions[0])\r\n\t$.modY = (y) => modulo(y, options.boardDimensions[1])\r\n\r\n\tlet setUpMarkers = () => {\r\n\t\t$.wraparoundAndCoords = []\r\n\r\n\t\t// $.getMarkersForWraparound = function (){\r\n\t\tif (options.projectionSettings.wraparound > 0) {\r\n\t\t\tconst m = options.boardDimensions[0],\r\n\t\t\t\tn = options.boardDimensions[1]\r\n\r\n\t\t\t/*\r\n\t\t\tm: boardDimensions[0] : 11\r\n\t\t\tw: wraparound : 4\r\n\t\t\tline: 0,...,(m-1)\r\n\t\t\t=>\r\n\t\t\t0,...,(w-1), (start line) w, ... , (w + m - 1) end line, (w+m), ... , (2w + m - 1)\r\n\t\t\t*/\r\n\r\n\t\t\tlet board = []\r\n\t\t\tif ([1, 2, 4].indexOf(options.wraparoundMarkersType) > -1) {\r\n\t\t\t\tlet middles = options.wraparoundMarkersType > 1 ?\r\n\t\t\t\t\t[Math.floor((m - 1) / 2) + 1, Math.ceil((m - 1) / 2) + 1,\r\n\t\t\t\t\tMath.floor((n - 1) / 2) + 1, Math.ceil((n - 1) / 2) + 1]\r\n\t\t\t\t\t: [-1, 99, -1, 99]\r\n\t\t\t\tfor (let i = 1; i <= m; i++) {\r\n\t\t\t\t\tif (i < middles[0] || i > middles[1]) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label = '─'//U+2500 Box Drawings Light Horizontal\r\n\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1 + i) + coordinateLabels(wraparound - 1) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1 + i) + coordinateLabels(wraparound + m) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t\tfor (let i = 1; i <= n; i++) {\r\n\t\t\t\t\tif (i < middles[2] || i > middles[3]) {\r\n\t\t\t\t\t\tcontinue\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label = '│'//unicode too\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound - 1 + i) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(wraparound + n) + coordinateLabels(wraparound - 1 + i) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ([1, 2, 3].indexOf(options.wraparoundMarkersType) > -1) {\r\n\t\t\t\t//┘  ┌  └ ┐\r\n\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound + n) + \":└\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound + m) + coordinateLabels(wraparound + n) + \":┘\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound - 1) + coordinateLabels(wraparound - 1) + \":┌\")\r\n\t\t\t\tboard.push(coordinateLabels(wraparound + m) + coordinateLabels(wraparound - 1) + \":┐\")\r\n\t\t\t}\r\n\r\n\t\t\tif (options.coordinatesType > 0 && wraparound > 1) {\r\n\t\t\t\tfor (let i = 1; i < 2 * wraparound + m - 1; i++) {\r\n\r\n\t\t\t\t\tlet coordIndex = $.modX(-options.projectionSettings.offset[0] - wraparound + i)\r\n\r\n\t\t\t\t\tif (options.coordinatesType === 2 && coordIndex >= 8) {\r\n\t\t\t\t\t\t//omit the I - historical coordinates for Go...\r\n\t\t\t\t\t\t//I: 9th letter\r\n\t\t\t\t\t\tcoordIndex++\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet label =\r\n\t\t\t\t\t\toptions.coordinatesType < 3\r\n\t\t\t\t\t\t\t? coordinateLabels(coordIndex).toUpperCase()\r\n\t\t\t\t\t\t\t: '' + (coordIndex + 1)\r\n\t\t\t\t\tboard.push(coordinateLabels(i) + coordinateLabels(0) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(i) + coordinateLabels(2 * wraparound + n - 1) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t\tlet cjkNumbers = '一二三四五六七八九'\r\n\t\t\t\tfor (let i = 1; i < 2 * wraparound + n - 1; i++) {\r\n\t\t\t\t\t/*\r\n\t\t\t\t\t0\t\t-w\r\n\t\t\t\t\t...\r\n\t\t\t\t\tw-1\t-1\r\n\t\t\t\t\tw\t\t0\r\n\t\t\t\t\t...\r\n\t\t\t\t\tw + n -1\r\n\t\t\t\t\t\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tlet coordIndex =\r\n\t\t\t\t\t\toptions.coordinatesType < 3\r\n\t\t\t\t\t\t\t? $.modY(n + options.projectionSettings.offset[1] + wraparound - i - 1)\r\n\t\t\t\t\t\t\t: $.modY(i - wraparound - options.projectionSettings.offset[1])\r\n\t\t\t\t\tlet label = ''\r\n\t\t\t\t\tswitch (options.coordinatesType) {\r\n\t\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\tlabel = '' + (coordIndex + 1)\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\tlabel = modulo(coordIndex, 10) === 9 ? '' : cjkNumbers[modulo(coordIndex, 10)]\r\n\r\n\t\t\t\t\t\t\tif (coordIndex > 8) {\r\n\t\t\t\t\t\t\t\tlabel = (coordIndex > 18 ? cjkNumbers[Math.floor((coordIndex + 1) / 10) - 1] : '') + '十' + label\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\t\tboard.push(coordinateLabels(0) + coordinateLabels(i) + \":\" + label)\r\n\t\t\t\t\tboard.push(coordinateLabels(2 * wraparound + m - 1) + coordinateLabels(i) + \":\" + label)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t$.wraparoundAndCoords = board\r\n\t\t}\r\n\t}\r\n\tsetUpMarkers()\r\n\r\n\r\n\t$.coords2String =\r\n\t\t/**\r\n\t\t * converts coordinates to a string\r\n\t\t */\r\n\t\tfunction coords2String(coords) {\r\n\t\t\treturn coordinateLabels(coords[0]) + coordinateLabels(coords[1])\r\n\t\t}\r\n\r\n\tfunction goThroughTree(state) {\r\n\t\tlet { wrappedGame, node, pending, currentPath, tGo } = state\r\n\t\t\t, nbVariations = wrappedGame.variations().length\r\n\t\tif (currentPath.m > 1000) throw new Error('seem to be stuck!');\r\n\t\tstate.hasSiblings = nbVariations > 0\r\n\t\tif (state.hasSiblings) {\r\n\t\t\t// if(currentPath[m] === undefined)\r\n\t\t\t// currentPath[m] = 0\r\n\t\t\t// else\r\n\t\t\t// currentPath[m] += 1\r\n\t\t\t// currentPath.m += 1\r\n\t\t\tfor (let i = nbVariations - 1; i > 0; i--)\r\n\t\t\t//pile up in this order, as it's FILO and we want the last variation, which may contain a mode added by CGoboard to go last\r\n\t\t\t{\r\n\t\t\t\tlet pathForLater = { ...currentPath }//Object.assign({}, currentPath)\r\n\t\t\t\tpathForLater[currentPath.m + 1] = i\r\n\t\t\t\tpathForLater.m += 1\r\n\r\n\t\t\t\tif (tGo !== undefined)\r\n\t\t\t\t\tpending.push({ path: pathForLater, tGoData: tGo.exportData() })\r\n\t\t\t\telse\r\n\t\t\t\t\tpending.push({ path: pathForLater })\r\n\r\n\t\t\t}\r\n\t\t\tstate.node = wrappedGame.next().node()\r\n\t\t\tcurrentPath[currentPath.m + 1] = 0\r\n\t\t\tcurrentPath.m += 1\r\n\t\t\treturn state.node\r\n\t\t}\r\n\r\n\t\tlet nextNode = wrappedGame.next().node()\r\n\t\tif (node === nextNode) {//at a leaf:\r\n\t\t\tif (pending.length === 0) {\r\n\t\t\t\tstate.node = null\r\n\t\t\t\treturn state.node//finished\r\n\t\t\t}\r\n\t\t\tlet fromStack = pending.pop()\r\n\t\t\tstate.hasSiblings = true\r\n\t\t\t// if (fromStack === null) {\r\n\t\t\t// \tnode = null\r\n\t\t\t// \treturn//finished!\r\n\t\t\t// }\r\n\t\t\tif (tGo !== undefined) tGo.loadData(fromStack.tGoData)\r\n\t\t\tstate.node = wrappedGame.goTo(fromStack.path).node()\r\n\t\t\tstate.currentPath = fromStack.path\r\n\t\t\treturn state.node\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcurrentPath.m += 1\r\n\t\t\tstate.node = nextNode\r\n\t\t\treturn state.node\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Apart from a few details, this is an inverse of the transform function.\r\n\t * @param {smartgame|string} wrappedGame\r\n\t * @param {smartgame} smartgame\r\n\t * @public\r\n\t */\r\n\tfunction inverseTransform(\r\n\t\twrappedGame, smartgame) {\r\n\r\n\t\tif (smartgame === undefined) {\r\n\t\t\tsmartgame = require('smartgame')\r\n\t\t}\r\n\r\n\t\tif (typeof wrappedGame === 'string') {\r\n\t\t\tlet smartgamer = require('smartgamer')\r\n\t\t\twrappedGame = smartgamer(smartgame.parse(wrappedGame))\r\n\t\t}\r\n\r\n\t\tlet node = wrappedGame.first().node()\r\n\t\t\t, pending = []\r\n\t\t\t, currentPath = { m: 0 }\r\n\t\t\t, cleanerRegEx = /^[a-zA-Z :0-9\\-(\\r\\n]+GoVariantsTransformer\\)--[\\r\\n]*/\r\n\t\t\t, cleanComments = () => {\r\n\t\t\t\tif (node.C !== undefined) {\r\n\t\t\t\t\tnode.C = node.C.replace(cleanerRegEx, '')\r\n\t\t\t\t}\r\n\t\t\t\tif (node.C === '')\r\n\t\t\t\t\tdelete node.C\r\n\t\t\t}\r\n\t\t\t,\r\n\t\t\t/**\r\n\t\t\t * Function to:\r\n\t\t\t * \t- remove the “border” (unicode symbols added by the transform to indicate where the wraparound area meets the main grid).\r\n\t\t\t * \t- remove CM (colour map) and CT (colour table) which are nonstandard SGF added by CGoboard for background colour (could be interesting to use this feature later on).\r\n\t\t\t */\r\n\t\t\tcleanLabels = () => {\r\n\r\n\t\t\t\tlet labels = []\r\n\t\t\t\tif (node.LB !== undefined) {\r\n\t\t\t\t\tlabels = node.LB\r\n\t\t\t\t\tif (!Array.isArray(labels))\r\n\t\t\t\t\t\tlabels = [labels]\r\n\t\t\t\t\tlabels = labels.filter(i => !$.wraparoundAndCoords.includes(i))\r\n\t\t\t\t\t/* jshint loopfunc: true */\r\n\t\t\t\t\tlabels =\r\n\t\t\t\t\t\t_uniqBy(\r\n\t\t\t\t\t\t\tlabels\r\n\t\t\t\t\t\t\t\t.map(function (x) { return x.split(':', 2) })//assume the label doesn’t contain “:”\r\n\t\t\t\t\t\t\t\t.map((x) => [$.coords2String($.inverseProjectOnFlat(translateCoordinates(x[0]))), x[1]])\r\n\t\t\t\t\t\t\t, (x) => x[0])\r\n\t\t\t\t\t\t\t.map((x) => `${x[0]}:${x[1]}`)\r\n\r\n\r\n\t\t\t\t\t// labels = []\r\n\t\t\t\t\t// for (let i = 0; i < labels2.length; i++)\r\n\t\t\t\t\t// \tlabels = labels.concat(labels2)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.LB = labels\r\n\t\t\t\tif (node.LB.length === 0)\r\n\t\t\t\t\tdelete node.LB\r\n\r\n\t\t\t\tif (node.CM)\r\n\t\t\t\t\tdelete node.CM\r\n\t\t\t\tif (node.CT)\r\n\t\t\t\t\tdelete node.CT\r\n\t\t\t}\r\n\r\n\t\tcleanLabels()\r\n\t\tnode.SZ = options.boardDimensions[0]\r\n\t\tnode.AP = \"go-variants-transformer\"\r\n\r\n\t\tif (node.SO !== undefined) {\r\n\t\t\tlet cleanSourceRegex = new RegExp(` \\\\(${sourceSgfMessage}\\\\)`)\r\n\t\t\tnode.SO = node.SO.replace(cleanSourceRegex, '')\r\n\t\t\t// if (node.SO === '')\r\n\t\t\t// \tdelete node.SO\r\n\t\t}\r\n\r\n\t\tlet state = {\r\n\t\t\twrappedGame, node, pending, currentPath, siblingMoves: {}//, parentsWithChildToDelete: [] \r\n\t\t}\r\n\r\n\t\tnode = goThroughTree(state)\r\n\t\twhile (node !== null) {\r\n\t\t\tcleanLabels()\r\n\t\t\tcleanComments()\r\n\r\n\t\t\tconst\r\n\t\t\t\tisBlack = node.AB !== undefined || node.B !== undefined\r\n\t\t\t\t, addedStones = isBlack ? node.AB : node.AW\r\n\t\t\t\t, playedStone = isBlack ? node.B : node.W\r\n\t\t\t\t, move = addedStones ? addedStones : playedStone\r\n\t\t\t\t, moveAsArray = Array.isArray(move) ? move : [move]\r\n\t\t\t\t, isAPass = isBlack ? node.B === '' : node.W === ''\r\n\t\t\t\t, moveHasCoords = move !== undefined && move !== ''\r\n\t\t\t\t, coords = !moveHasCoords ? undefined : $.coords2String($.inverseProjectOnFlat(moveAsArray.map(translateCoordinates)))\r\n\r\n\t\t\t//alter the node\r\n\r\n\t\t\t/*\r\n\t\t\tlogic removing a node added by CGoboard, if there already is the same move as AB or AW in a prior variation; assuming \r\n\t\t\tthe variation to be removed is the last of the siblings - which does seem to be the way CGoboard behaves when a click \r\n\t\t\tis made on a point where the next node is AB or AW.  \r\n\t\t\t*/\r\n\t\t\tif (state.hasSiblings) {\r\n\t\t\t\tlet pathForParent = { ...wrappedGame.path } //Object.assign({}, wrappedGame.path)\r\n\t\t\t\tpathForParent.m--\r\n\t\t\t\tdelete pathForParent[pathForParent.m]\r\n\t\t\t\tpathForParent = wrappedGame.pathTransform(pathForParent)\r\n\t\t\t\t// wrappedGame.previous()\r\n\t\t\t\tif (state.siblingMoves[pathForParent] === undefined) {\r\n\t\t\t\t\tstate.siblingMoves[pathForParent] = []\r\n\t\t\t\t}\r\n\t\t\t\tif (addedStones) {\r\n\t\t\t\t\tstate.siblingMoves[pathForParent].push(coords)\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tif (playedStone && state.siblingMoves[pathForParent].indexOf(coords) > -1) {\r\n\r\n\t\t\t\t\t\t// state.parentsWithChildToDelete.push(pathForParent)\r\n\t\t\t\t\t\tnode.XX = \"inverseTransformToDelete\"\r\n\t\t\t\t\t}\r\n\t\t\t\t// wrappedGame.goTo(currentPath)\r\n\t\t\t}\r\n\r\n\t\t\tdelete node[isBlack ? 'AB' : 'AW']\r\n\t\t\tdelete node[isBlack ? 'B' : 'W']\r\n\t\t\tdelete node.CR\r\n\t\t\tdelete node.AE\r\n\r\n\t\t\tif (isAPass) {\r\n\t\t\t\tnode[isBlack ? 'B' : 'W'] = ''\r\n\t\t\t}\r\n\r\n\t\t\tif (moveHasCoords) {\r\n\t\t\t\tnode[isBlack ? 'B' : 'W'] = coords\r\n\t\t\t}\r\n\r\n\t\t\t;/*note: this next semicolon is needed! */[// eslint-disable-line no-extra-semi\r\n\t\t\t\t//'CR',todo: add if not marking the move\r\n\t\t\t\t'DD', 'MA', 'SL', 'SQ', 'TR'].forEach(function (sgfProperty) {\r\n\t\t\t\t\t// _.map(['DD','MA','SL','SQ','TR'], function(sgfProperty){\r\n\t\t\t\t\tif (node[sgfProperty] === undefined) return\r\n\t\t\t\t\tlet points = []\r\n\t\t\t\t\tif (Array.isArray(node[sgfProperty])) {\r\n\t\t\t\t\t\tpoints = node[sgfProperty]\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tpoints = [node[sgfProperty]]\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpoints =\r\n\t\t\t\t\t\t$.inverseProjectOnFlat(\r\n\t\t\t\t\t\t\tpoints.map(translateCoordinates), true\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t.map($.coords2String)\r\n\t\t\t\t\tnode[sgfProperty] = points\r\n\t\t\t\t})\r\n\t\t\t// move to next node\r\n\t\t\tnode = goThroughTree(state)\r\n\t\t}\r\n\r\n\t\t// state.parentsWithChildToDelete.forEach((path) => {\r\n\t\t// \t//remove the sgf node\r\n\t\t// \twrappedGame.goTo(path)\r\n\t\t// \tlet sequences = wrappedGame.game.sequences\r\n\t\t// \tlet index = _fi(sequences, (seq) => seq.nodes[0].inverseTransformToDelete)\r\n\t\t// \t\t, tmpI = 0\r\n\t\t// \twhile (index > -1) {\r\n\t\t// \t\tsequences.splice(index, 1)\r\n\t\t// \t\tindex = _fi(sequences, (seq) => seq.nodes[0].inverseTransformToDelete)\r\n\t\t// \t\ttmpI++\r\n\t\t// \t\tif (tmpI > 100) throw new Error('seem to be stuck!');\r\n\t\t// \t}\r\n\r\n\t\t// \t// console.log(path)\r\n\t\t// })\r\n\r\n\t\tlet deleteNodes = (sequence) => {\r\n\t\t\tif (sequence.sequences) {\r\n\r\n\t\t\t\tlet\r\n\t\t\t\t\tsequences = sequence.sequences\r\n\t\t\t\t\t, index = _fi(sequences, (seq) => seq.nodes[0].XX === 'inverseTransformToDelete')\r\n\t\t\t\t\t, tmpI = 0, max = sequences.length\r\n\t\t\t\twhile (index > -1) {\r\n\t\t\t\t\tsequences.splice(index, 1)\r\n\t\t\t\t\tindex = _fi(sequences, (seq) => seq.nodes[0].XX === 'inverseTransformToDelete')\r\n\t\t\t\t\ttmpI++\r\n\t\t\t\t\tif (tmpI > max) throw new Error('seem to be stuck!');\r\n\t\t\t\t}\r\n\t\t\t\tfor (let index2 = 0; index2 < sequences.length; index2++) {\r\n\t\t\t\t\t// deleteNodes(sequences[index2].nodes[sequences[index2].nodes.length - 1]);\r\n\t\t\t\t\tdeleteNodes(sequences[index2]);\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (sequence.nodes)\r\n\t\t\t\tdeleteNodes(sequence.nodes[sequence.nodes.length - 1])\r\n\t\t}\r\n\t\tdeleteNodes(wrappedGame.game)\r\n\r\n\t\tif (options.transformToString)\r\n\t\t\treturn smartgame.generate({ gameTrees: [wrappedGame.game] });\r\n\t\telse return wrappedGame\r\n\r\n\t}\r\n\t$.inverseTransform = inverseTransform\r\n\r\n\t/**\r\n\t * Main function; converts SGF for a Go variant (so far, just toroidal Go or t-Go).\r\n\t * @param {string} tSgf\r\n\t * @param {object} tGo Engine for counting liberties in t-Go. An instance of go-variants-engine.\r\n\t * @param {*} smartgame\r\n\t * @param {*} smartgamer\r\n\t * @returns {string|object} SGF that can be viewed in a standard SGF viewer. (See `options.transformToString` for the data type of the value returned.)\r\n\t * @public\r\n\t */\r\n\tfunction transform(\r\n\t\ttSgf //eg 11x11 sgf from LittleGolem\r\n\t\t, tGo //app implementing t-Go\r\n\t\t, smartgame\r\n\t\t, smartgamer) {\r\n\r\n\t\tif (tGo === undefined) {\r\n\t\t\t//  tGo = require('../dist/node_modules/go-variants-engine/src/engine.min.js')({\r\n\t\t\t//  tGo = require('../../engine/dist/engine.min.js')({\r\n\t\t\ttGo = require('go-variants-engine')({\r\n\t\t\t\t// tGo = require('../node_modules/go-variants-engine/src/engine')({\r\n\t\t\t\t// boardMode:'t',\r\n\t\t\t\tboardDimensions: options.boardDimensions\r\n\t\t\t})\r\n\t\t\t// tGo = require('../node_modules/go-variants-engine')({boardMode:'t', boardDimensions:options.boardDimensions})\r\n\t\t\t// tGo = require('../node_modules/go-variants-engine/src/engine')({boardMode:'t', boardDimensions:options.boardDimensions})\r\n\t\t}\r\n\t\t// else {\r\n\t\t// \ttGo.options.boardDimensions = options.boardDimensions\r\n\t\t// }\r\n\r\n\t\tif (smartgame === undefined) {\r\n\t\t\tsmartgame = require('smartgame')\r\n\t\t}\r\n\t\tif (smartgamer === undefined) {\r\n\t\t\tsmartgamer = require('smartgamer')\r\n\t\t}\r\n\t\t// console.log(tGo)\r\n\t\tlet parsed = smartgame.parse(tSgf)\r\n\t\t\t, wrappedGame = smartgamer(parsed)\r\n\t\t\t, node = wrappedGame.node()\r\n\t\t\t, passes = 0\r\n\t\t\t, pending = []\r\n\t\t\t, currentPath = { m: 0 }\r\n\t\tif (node.SZ !== undefined) {\r\n\t\t\tlet sz = Number(node.SZ)\r\n\t\t\t// sz+= 2*options.projectionSettings.wraparound\r\n\t\t\toptions.boardDimensions = [sz, sz]\r\n\t\t\ttGo.options.boardDimensions = options.boardDimensions\r\n\t\t\tsetUpMarkers()\r\n\t\t}\r\n\t\tif (node.KM !== undefined) {\r\n\t\t\toptions.rules = { komi: parseFloat(node.KM), ...options.rules }\r\n\t\t}\r\n\t\tnode.SZ = \"\" + (options.boardDimensions[0] + 2 * options.projectionSettings.wraparound)//not sure how to make a rectangular goban!\r\n\t\t//offset modulo\r\n\t\toptions.projectionSettings.offset[0] = modulo(options.projectionSettings.offset[0], options.boardDimensions[0])\r\n\t\toptions.projectionSettings.offset[1] = modulo(options.projectionSettings.offset[1], options.boardDimensions[1])\r\n\t\tlet setLabels = () => {\r\n\t\t\t//node.LB = $.wraparoundAndCoords\r\n\t\t\tlet labels = []\r\n\t\t\tif (node.LB !== undefined) {\r\n\t\t\t\tlabels = node.LB\r\n\t\t\t\tif (!Array.isArray(labels))\r\n\t\t\t\t\tlabels = [labels]\r\n\r\n\t\t\t\t/* jshint loopfunc: true */\r\n\t\t\t\tlet labels2 = labels//_.chain(labels)\r\n\t\t\t\t\t.map(function (x) { return x.split(':', 2) })//assume the label doesn’t contain “:”\r\n\t\t\t\t\t.map(function (x) { return [translateCoordinates(x[0]), x[1]] })\r\n\t\t\t\t\t.map(function (x) { return [$.projectOnFlat(x[0]), x[1]] })\r\n\t\t\t\t// .value()\r\n\t\t\t\tlabels = []\r\n\t\t\t\tfor (let i = 0; i < labels2.length; i++)\r\n\t\t\t\t\tlabels = labels.concat(\r\n\t\t\t\t\t\tlabels2[i][0].map(function (x) {\r\n\t\t\t\t\t\t\treturn $.coords2String(x) + \":\" + labels2[i][1]\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t)\r\n\t\t\t}\r\n\r\n\t\t\tnode.LB = $.wraparoundAndCoords.concat(labels)\r\n\t\t\tif (node.LB.length === 0)\r\n\t\t\t\t// delete node['LB']\r\n\t\t\t\tdelete node.LB\r\n\t\t}\r\n\r\n\t\tsetLabels()\r\n\r\n\t\tif (node.SO !== undefined)\r\n\t\t\tnode.SO = wrappedGame.game.nodes[0].SO + ` (${sourceSgfMessage})`\r\n\t\t//else node.SO = sourceSgfMessage//prefer not to add the message when original Sgf has no SO info.\r\n\r\n\t\tnode.AP = \"go-variants-transformer\"\r\n\r\n\r\n\t\tlet state = { wrappedGame, node, pending, currentPath, tGo }\r\n\r\n\t\tfunction comment(isPass, isBlack, score) {\r\n\t\t\tif (!options.addComments && !score)\r\n\t\t\t\treturn\r\n\r\n\t\t\tlet r = (!options.addComments && !score) ?\r\n\t\t\t\t''\r\n\t\t\t\t: 'move ' + state.currentPath.m + '\\n' + 'White stones captured by Black: ' + tGo.board.captured[1] + '\\nBlack stones captured by White: ' + tGo.board.captured[0]\r\n\t\t\t\t//let r =  'Black captures: ' + tGo.board.captured[1] + '\\r\\nWhite captures: ' + tGo.board.captured[0]\r\n\t\t\t\t+ (!isPass ? '' : '\\n' + (isBlack ? 'Black passes' : 'White passes'))\r\n\t\t\t\t+ (!score ? '' : '\\n' + `result: ${score}`)\r\n\r\n\t\t\tr += '\\n--(the content above was generated automatically by GoVariantsTransformer)--'\r\n\t\t\tr += (node.C === undefined ? '' : '\\n' + node.C)\r\n\t\t\tnode.C = r\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tnode = goThroughTree(state)\r\n\t\twhile (node !== null) {\r\n\r\n\r\n\t\t\tlet\r\n\t\t\t\tisBlack = node.B !== undefined\r\n\t\t\t\t, move = isBlack ? node.B : node.W\r\n\t\t\t\t, isAPass = move === \"\" || (options.boardDimensions[0] === options.boardDimensions[1]\r\n\t\t\t\t\t&& options.boardDimensions[0] <= 19\r\n\t\t\t\t\t&& move === \"tt\" //weird SGF[3] way to show a pass move!\r\n\t\t\t\t)\r\n\t\t\t\t, stonesMarkedForScoring = []\r\n\r\n\t\t\tif (move === undefined && !isAPass) {\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tsetLabels()\r\n\r\n\t\t\tif (isAPass) {\r\n\t\t\t\tdelete node[isBlack ? 'B' : 'W']\r\n\t\t\t\tcomment(isAPass, isBlack)\r\n\t\t\t\tnode[isBlack ? 'AB' : 'AW'] = []\r\n\t\t\t\t// if (passes === 2) {\r\n\t\t\t\t// \t//wrappedGame.game.nodes.splice(i+1)//get rid of nodes afterwards -- may not work with variations! todo\r\n\t\t\t\t// \tbreak;//stop after 3 successive passes for now\r\n\t\t\t\t// }\r\n\t\t\t\tpasses++\r\n\t\t\t\tif (passes >= 1000)\r\n\t\t\t\t\tbreak//just in case!\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconst coords = translateCoordinates(move)\r\n\t\t\t\tlet playResult = null\r\n\t\t\t\t// run move through tGo and update game accordingly\r\n\t\t\t\ttry {\r\n\t\t\t\t\tplayResult = tGo.play(isBlack ? 'b' : 'w', coords)\r\n\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tif (error.message !== 'point is not empty' /*ignore this - it happens with some sgf from littleGolem. Todo: look into scoring the position here. */)\r\n\t\t\t\t\t\tthrow (error)\r\n\t\t\t\t}\r\n\t\t\t\tconst projectedCoords = $.projectOnFlat(coords)\r\n\t\t\t\tlet toAdd = playResult === null ? [] : projectedCoords.map($.coords2String)\r\n\t\t\t\t\t, toRemove = playResult === null ? [] :\r\n\t\t\t\t\t\t// _.chain(playResult.removed)\r\n\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t// \t.map($.projectOnFlat)\r\n\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t// \t.map($.coords2String)\r\n\t\t\t\t\t\t// \t.value()\r\n\t\t\t\t\t\t_flatten(\r\n\t\t\t\t\t\t\t_flatten(playResult.removed)\r\n\t\t\t\t\t\t\t\t.map($.projectOnFlat))\r\n\t\t\t\t\t\t\t.map($.coords2String)\r\n\r\n\t\t\t\t//alter the node\r\n\t\t\t\tif (options.moveType === 2) {\r\n\t\t\t\t\tlet moveMarker = `${isBlack ? 'B' : 'W'}`\r\n\t\t\t\t\tnode[moveMarker] = toAdd.pop()\r\n\t\t\t\t\tif (toAdd.length > 0) {\r\n\t\t\t\t\t\tnode['A' + moveMarker] = toAdd\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet moveMarker = `${options.moveType < 3 ? 'A' : ''}${isBlack ? 'B' : 'W'}`\r\n\r\n\t\t\t\t\tnode[moveMarker] = toAdd\r\n\t\t\t\t\tif (options.markLastMove) {\r\n\t\t\t\t\t\tnode[options.markLastMove] = toAdd\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (options.moveType === 1)\r\n\t\t\t\t\tnode[isBlack ? 'B' : 'W'] = ''\r\n\r\n\r\n\t\t\t\tif (toRemove.length > 0)\r\n\t\t\t\t\tnode.AE = toRemove\r\n\r\n\t\t\t\t\t\t/*\r\n\t\t\t\t\t\ttodo: other properties with board coordinates\r\n\t\t\t\t\t\tLeave for now:\r\n\t\t\t\t\t\tAR\r\n\t\t\t\t\t\tLN\r\n\t\t\t\t\t\t*/\r\n\r\n\t\t\t\t\t\t;/*note this semicolon is needed! */\r\n\t\t\t\t[\r\n\t\t\t\t\t//'CR',todo: add if not marking the move\r\n\t\t\t\t\t'DD', 'MA', 'SL', 'SQ', 'TR'].forEach(function (sgfProperty) {\r\n\t\t\t\t\t\t// _.map(['DD','MA','SL','SQ','TR'], function(sgfProperty){\r\n\t\t\t\t\t\tif (node[sgfProperty] === undefined) return\r\n\t\t\t\t\t\tlet points = []\r\n\t\t\t\t\t\tif (Array.isArray(node[sgfProperty])) {\r\n\t\t\t\t\t\t\tpoints = node[sgfProperty]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tpoints = [node[sgfProperty]]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (node.SC && sgfProperty === 'MA') {\r\n\t\t\t\t\t\t\tstonesMarkedForScoring =\r\n\t\t\t\t\t\t\t\t\tpoints\r\n\t\t\t\t\t\t\t\t\t\t.map(translateCoordinates)\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tpoints =\r\n\t\t\t\t\t\t\t// _.chain(points)\r\n\t\t\t\t\t\t\t// \t.map(translateCoordinates)\r\n\t\t\t\t\t\t\t// \t.map($.projectOnFlat)\r\n\t\t\t\t\t\t\t// \t.flatten(true)\r\n\t\t\t\t\t\t\t// \t.map($.coords2String)\r\n\t\t\t\t\t\t\t// \t.value()\r\n\t\t\t\t\t\t\t_flatten(\r\n\t\t\t\t\t\t\t\tpoints\r\n\t\t\t\t\t\t\t\t\t.map(translateCoordinates)\r\n\t\t\t\t\t\t\t\t\t.map($.projectOnFlat)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t.map($.coords2String)\r\n\t\t\t\t\t\tnode[sgfProperty] = points\r\n\t\t\t\t\t})\r\n\t\t\t\tif (options.addMoveNumber)\r\n\t\t\t\t\tnode.MN = currentPath.m\r\n\r\n\t\t\t\t/*\r\n\t\t\t\tUse a custom, new SGF property, SC, in order to see if the current position should be scored, and if so, what to do with the score.\r\n\t\t\t\tIt’s a bit flag.  \r\n\t\t\t\t1\t⇒ update the comments for the node (succint). When flagged, the next option is not available.\r\n\t\t\t\t2\t⇒ update the comments for the node (verbose)\r\n\t\t\t\t4\t⇒ update the game result (RE) for the root node\r\n\t\t\t\tTypical usage: add “SC[6]” to the last node, and “SC[2]” to score a variation.\r\n\t\t\t\t*/\r\n\t\t\t\tlet updatedComment = false\r\n\t\t\t\tif (node.SC) {\r\n\t\t\t\t\ttGo.rules.komi = parseFloat(wrappedGame.game.nodes[0].KM)\r\n\r\n\t\t\t\t\tlet score = tGo.board.score(stonesMarkedForScoring)\r\n\t\t\t\t\t\t, scoreOption = parseInt(node.SC)\r\n\t\t\t\t\tif ((scoreOption & 1) === 1) {\r\n\t\t\t\t\t\tupdatedComment = true\r\n\t\t\t\t\t\tcomment(isAPass, isBlack, score.RE)\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse /*don't want to treat succint and verbose at the same time*/\r\n\t\t\t\t\t\tif ((scoreOption & 2) === 2) {\r\n\t\t\t\t\t\t\tupdatedComment = true\r\n\t\t\t\t\t\t\tcomment(isAPass, isBlack,\r\n\t\t\t\t\t\t\t\t`Black: ${score.blackScore} = ${score.totalBlackTerritory} territory + ${score.totalWhiteDead + score.totalWhiteCaptured} prisoners\r\nWhite: ${score.whiteScore} = ${score.totalWhiteTerritory} territory + ${score.totalBlackDead + score.totalBlackCaptured} prisoners + ${tGo.rules.komi} komi\r\nResult: ${score.RE}`)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\tif ((scoreOption & 4) === 4) {\r\n\t\t\t\t\t\twrappedGame.game.nodes[0].RE = score.RE\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!updatedComment)\r\n\t\t\t\t\tcomment(isAPass, isBlack)\r\n\r\n\t\t\t\t// move to next node\r\n\t\t\t\tnode = goThroughTree(state)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (options.transformToString)\r\n\t\t\treturn smartgame.generate({ gameTrees: [wrappedGame.game] });\r\n\t\telse return wrappedGame\r\n\t}\r\n\t$.transform = transform\r\n\treturn $\r\n\r\n}\r\nmodule.exports = transformer","/* eslint-env browser */\r\n/* global GoBoardApi */\r\n/* eslint no-console: 0 */\r\n/**\r\n * A function for rendering the viewer/editor\r\n * @param {object} [options=]\r\n * @param {boolean} [options.inhibitForRoot = true] When flagged, the function does nothing when the current window's location.path is empty. (Useful for preventing the script from running when several posts are displayed at the home page of the blog.) \r\n*/\r\n\r\nlet goVariantsEditor = function (editorOptions) {\r\n\teditorOptions = { rootId: 'sgfEditor', showExtras: true, inhibitForRoot:true, ...editorOptions }\r\n\tlet { rootId, showExtras } = editorOptions\r\n\t\t, editorTemplate = require('./editor.jsx')\r\n\t\t, go_variants_transformer = require('../src/transformer')\r\n\t\t,  getElementByIdSuffix = (suffix) => document.getElementById(rootId + '_' + suffix)\r\n\t\t,  viewer = {}\r\n\t\r\n\tif (viewer.ran) return\r\n\tviewer.ran = true//just run this function once\r\n\r\n\t//startup\r\n\tlet optionsNode = document.querySelectorAll(\r\n\t\t`#${rootId} .go-variants-options`)\r\n\tif (optionsNode.length > 0) {\r\n\t\tlet options = JSON.parse(optionsNode[0].innerText)\r\n\t\teditorOptions = {... editorOptions, ... options}\r\n\t}\r\n\tif (editorOptions.inhibitForRoot && location.pathname === '') return\r\n\r\n\tdocument.getElementById(rootId).appendChild(editorTemplate(editorOptions))\r\n\r\n\t\r\n\r\n\r\n\tgetElementByIdSuffix('updateButton').addEventListener('click', updateVariantSgf)\r\n\r\n\t\t;[].forEach.call(document.querySelectorAll(`#${rootId}_viewerControls input[type=button]`), function (el) {\r\n\t\t\tel.addEventListener('click', function (e) {\r\n\t\t\t\tlet target = e.target || e.srcElement\r\n\t\t\t\tshowBoard({ panningDirection: target.value })\r\n\t\t\t})\r\n\t\t})\r\n\r\n\tif (showExtras) {\r\n\t\t[].forEach.call(document.querySelectorAll(`#${rootId} .go-variants-extras`), function (el) {\r\n\t\t\tel.style.display = 'inline-block'\r\n\t\t})\r\n\r\n\t\t// ;/*another semicolon that's needed...*/[].forEach.call(document.querySelectorAll(`#${rootId} fieldset.go-variants-extras`), function (el) {\r\n\t\t// \tel.style.display = 'inline-block'\r\n\t\t// })\r\n\r\n\r\n\t\tlet select = getElementByIdSuffix('sizeSelect')\r\n\t\tfor (let index = 4; index < 20; index++) {\r\n\t\t\tconst option = document.createElement('option')\r\n\t\t\toption.value = '' + index\r\n\t\t\toption.appendChild(document.createTextNode(index))\r\n\t\t\tselect.appendChild(option)\r\n\t\t}\r\n\r\n\t} else {\r\n\t\t[].forEach.call(document.querySelectorAll(`#${rootId} .go-variants-extras`), function (el) {\r\n\t\t\t//el.parentNode.removeChild(el)\r\n\t\t\tel.style.display = 'none'\r\n\t\t})\r\n\t}\r\n\r\n\tgetElementByIdSuffix('goButton').addEventListener('click', function () {\r\n\t\tshowBoard()\r\n\t})\r\n\tgetElementByIdSuffix('goLgButton').addEventListener('click', function () {\r\n\t\tgetLittleGolemSgfAndShowBoard()\r\n\t})\r\n\tgetElementByIdSuffix('newButton').addEventListener('click', function () {\r\n\t\tgetElementByIdSuffix(\"sgfIn\").value = `(;GM[1]FF[4]AP[go-variants-transformer]SZ[${getElementByIdSuffix('sizeSelect').value}])`\r\n\t\tshowBoard()\r\n\t})\r\n\r\n\tgetElementByIdSuffix('viewerControls').style.display = \"none\"\r\n\r\n\t//startup\r\n\tlet inputSgfNode = document.querySelectorAll(\r\n\t\t// `#${rootId} .go-variants-data:first-of-type`)\r\n\t\t`#${rootId} .go-variants-data`)\r\n\tif (inputSgfNode.length > 0) {\r\n\t\tgetElementByIdSuffix(\"sgfIn\").value = inputSgfNode[0].innerText\r\n\r\n\t\tshowBoard()\r\n\t}\r\n\telse {\r\n\t\tlet params = new URLSearchParams((new URL(window.location)).search.slice(1))\r\n\t\tif (params.has('sgf')) {\r\n\t\t\tlet sgf = params.get('sgf')\r\n\t\t\tif (looksLikeSgf(sgf)) {\r\n\t\t\t\tgetElementByIdSuffix(\"sgfIn\").value = sgf\r\n\t\t\t\tshowBoard()\r\n\t\t\t}\r\n\t\t} else if (params.has('littlegolemid')) {\r\n\t\t\tlet id = params.get('littlegolemid')\r\n\t\t\tif (/^\\d+$/g.test(id)) {\r\n\t\t\t\tgetElementByIdSuffix('littleGolemId').value = id\r\n\t\t\t\tgetLittleGolemSgfAndShowBoard()\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction showBoard(options) {\r\n\t\tif (options === undefined) options = {}\r\n\t\tlet { tSgf, panningDirection, moveReference, reset } = options\r\n\t\tif (reset || !viewer.offset) viewer.offset = [0, 0]\r\n\t\tif (panningDirection) {\r\n\t\t\tlet right = viewer.offset[0], up = viewer.offset[1]\r\n\t\t\tswitch (panningDirection) {\r\n\r\n\t\t\t\tcase \"↑\":\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tup--\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\tcase \"↓\":\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tup++\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t\tcase \"←\":\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tright--\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\tcase \"→\":\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tright++\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tviewer.offset = [right, up]\r\n\t\t}\r\n\r\n\t\tif (tSgf === undefined || tSgf === null) {\r\n\t\t\ttSgf = getElementByIdSuffix(\"sgfIn\").value\r\n\t\t}\r\n\t\tif (tSgf === '') {\r\n\t\t\tif (!viewer.warnedEmptySgf) {\r\n\t\t\t\talert('No SGF was entered, so showing a simple sample instead.')\r\n\t\t\t\tviewer.warnedEmptySgf = true\r\n\t\t\t}\r\n\t\t\ttSgf = '(;GM[1]FF[4]CA[UTF-8]AP[go-variants-transformer]ST[0]SZ[4]KM[0]HA[0]PB[Black]PW[White]C[Here is a small sample game of Toroidal Go. It ends in a seki.];B[ad];W[bd];B[bc];W[ac];B[bb];W[aa];B[ab];W[dd];B[ca];W[cd];B[db];W[dc];B[cc];MA[ba]C[It’s a seki; neither player should play at X now - if they do, they put their own stones in atari. This is shown in the next two variations.]W[da](;B[ba];W[cb])(;B[];W[ba];B[ad]))'//forked from sample7\r\n\t\t\tgetElementByIdSuffix(\"sgfIn\").value = tSgf\r\n\t\t}\r\n\t\tlet wraparound = Number(getElementByIdSuffix('wraparoundSelect').value)\r\n\t\t\t, wraparoundMarkersType = Number(getElementByIdSuffix('wraparoundBorderSelect').value)\r\n\t\t\t, coordinatesType = Number(getElementByIdSuffix('coordinateSelect').value)\r\n\t\t\t, addComments = getElementByIdSuffix('addComments').checked\r\n\t\t\t, sgf = ''\r\n\t\ttry {\r\n\t\t\tlet transformer = go_variants_transformer({\r\n\t\t\t\taddComments,\r\n\t\t\t\twraparoundMarkersType,\r\n\t\t\t\tcoordinatesType,\r\n\t\t\t\tprojectionSettings: {\r\n\t\t\t\t\toffset: viewer.offset,\r\n\t\t\t\t\twraparound\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tsgf = transformer.transform(tSgf)\r\n\t\t\tgetElementByIdSuffix(\"sgfOut\").value = sgf\r\n\t\t\tviewer.transformer = transformer\r\n\t\t}\r\n\t\tcatch (e) {\r\n\t\t\talert('an error occurred.')\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tviewer.sgf = sgf\r\n\t\tif (!panningDirection) {\r\n\r\n\t\t\tlet oGameTree = GoBoardApi.Create_GameTree()\r\n\t\t\tviewer.oGameTree = oGameTree\r\n\r\n\t\t\tGoBoardApi.Set_OnGameTreeModifiedCallback(oGameTree, () => { })\r\n\t\t\tGoBoardApi.Toggle_Rulers(oGameTree)\r\n\t\t\tGoBoardApi.Set_DrawHandicapMarks(oGameTree, false)\r\n\t\t\tGoBoardApi.Set_CapturingMode(oGameTree, false)\r\n\r\n\t\t\tGoBoardApi.Create_BoardCommentsButtonsNavigator(oGameTree, rootId + '_' + \"playerDiv\")\r\n\t\t\t// GoBoardApi.Create_EditorVer(oGameTree, \"playerDiv\");\r\n\t\t\tif (moveReference !== undefined)\r\n\t\t\t\tGoBoardApi.Load_Sgf(viewer.oGameTree, sgf, undefined, moveReference);\r\n\t\t\telse\r\n\t\t\t\tGoBoardApi.Load_Sgf(oGameTree, sgf);\r\n\r\n\t\t\tGoBoardApi.Set_OnGameTreeModifiedCallback(oGameTree, gameTreeModifiedCallback)\r\n\r\n\t\t\twindow.onresize = function () {\r\n\t\t\t\tGoBoardApi.Update_Size(oGameTree);\r\n\t\t\t};\r\n\r\n\r\n\t\t\tgetElementByIdSuffix('viewerControls').style.display = \"inline-block\"\r\n\t\t\tgetElementByIdSuffix('updateButtonDiv').style.display = \"inline-block\"\r\n\r\n\t\t\tif (showExtras) {\r\n\t\t\t\tgetElementByIdSuffix('transformedSgfFs').style.display = \"inline-block\"\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tGoBoardApi.Set_OnGameTreeModifiedCallback(viewer.oGameTree, () => { })\r\n\t\t\tmoveReference = GoBoardApi.Get_MoveReference(viewer.oGameTree, false)\r\n\t\t\tGoBoardApi.Load_Sgf(viewer.oGameTree, sgf, undefined, moveReference)\r\n\t\t\tGoBoardApi.Set_OnGameTreeModifiedCallback(viewer.oGameTree, gameTreeModifiedCallback)\r\n\t\t\tgetElementByIdSuffix('offsetTr').innerHTML = 'panned: ['\r\n\t\t\t\t+ viewer.transformer.modX(viewer.transformer.options.projectionSettings.offset[0])\r\n\t\t\t\t+ ', ' + viewer.transformer.modY(-viewer.transformer.options.projectionSettings.offset[1]) + ']'\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction gameTreeModifiedCallback() {\r\n\t\t//when a move is played, the callback is raised twice in quick succession. We want to only do work on the second call.\r\n\t\tif (!viewer.callbackLastCalled) {\r\n\t\t\tviewer.callbackLastCalled = Date.now()\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Date.now() - viewer.callbackLastCalled < 300) {\r\n\t\t\tupdateVariantSgf()\r\n\t\t}\r\n\t\telse viewer.callbackLastCalled = Date.now()\r\n\t}\r\n\r\n\tfunction looksLikeSgf(sgf, size) {\r\n\t\tlet result = sgf.startsWith('(')\r\n\t\t// && sgf.indexOf('GM[1]') > 0 //SGF LG doesn't!\r\n\r\n\t\tif (size) {\r\n\t\t\treturn result && sgf.indexOf(`SZ[${size}]` > 3)\r\n\t\t}\r\n\t\treturn result && /SZ\\[\\d+]/.test(sgf)\r\n\t}\r\n\tfunction updateVariantSgf() {\r\n\t\tlet sgf = GoBoardApi.Save_Sgf(viewer.oGameTree)\r\n\t\tif (sgf == viewer.sgf) {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tviewer.sgf = sgf\r\n\t\tlet moveReference = GoBoardApi.Get_MoveReference(viewer.oGameTree, false)\r\n\t\t// let options = viewer.transformer.options\r\n\t\t// options.boardDimensions = options.boardDimensions.map((x) => x - 2 * options.projectionSettings.wraparound) \r\n\t\tlet tSgf = viewer.transformer.inverseTransform(sgf)\r\n\t\tgetElementByIdSuffix(\"sgfIn\").value = tSgf\r\n\t\tshowBoard({ tSgf, moveReference })\r\n\t}\r\n\r\n\tfunction getLittleGolemSgfAndShowBoard() {\r\n\t\tlet gameId = getElementByIdSuffix('littleGolemId').value\r\n\t\tif (gameId === '') {\r\n\t\t\t//gameId = '1860795'\r\n\t\t\talert('enter the ID of a game from LittleGolem, e.g. “1860795”')\r\n\t\t\treturn\r\n\t\t}\r\n\t\tgameId = gameId.trim()\r\n\r\n\t\tlet proxyurl = \"https://cors-anywhere.herokuapp.com/\"\r\n\t\tlet url = `http://littlegolem.net/servlet/sgf/${gameId}/game${gameId}.sgf`\r\n\t\tif (!/^\\d+$/g.test(gameId)) {\r\n\t\t\talert('invalid ID')\r\n\t\t\treturn\r\n\t\t}\r\n\t\tgetElementByIdSuffix('goLgMsg').innerText = 'loading…'\r\n\t\tlet myHeaders = new Headers({\r\n\t\t\t\"Content-Type\": \"application/sgf\"\r\n\t\t});\r\n\t\tconst failMsg = 'load from littel Golem failed'\r\n\t\tfetch(proxyurl + url, { headers: myHeaders }).then(\r\n\t\t\tfunction (response) {\r\n\t\t\t\tif (response.status !== 200) {\r\n\t\t\t\t\tconsole.log('Looks like there was a problem. Status Code: ' + response.status);\r\n\r\n\t\t\t\t\tgetElementByIdSuffix('goLgMsg').innerText = failMsg\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Examine the text in the response\r\n\t\t\t\tresponse.text().then(function (sgf) {\r\n\t\t\t\t\tif (!looksLikeSgf(sgf, 11 /*LG is always 11x11*/)) {\r\n\t\t\t\t\t\tconsole.log('invalid SGF. Received:' + sgf)\r\n\r\n\t\t\t\t\t\tgetElementByIdSuffix('goLgMsg').innerText = failMsg\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsgf = sgf.replace('SZ[11]', `SZ[11]SO[http://littlegolem.net/jsp/game/game.jsp?gid=${gameId}`)\r\n\r\n\t\t\t\t\tgetElementByIdSuffix(\"sgfIn\").value = sgf\r\n\t\t\t\t\tshowBoard()\r\n\r\n\t\t\t\t\tgetElementByIdSuffix('goLgMsg').innerText = 'game loaded from Little Golem'\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t).catch(function (err) {\r\n\t\t\tconsole.log('Fetch Error :-S', err);\r\n\t\t});\r\n\t}\r\n\r\n\r\n\r\n\r\n}\r\ndocument.goVariantsEditor = goVariantsEditor\r\ndocument.addEventListener('DOMContentLoaded', function () {\r\n\t[].forEach.call(document.querySelectorAll('.go-variants-editor'), function (el) {\r\n\t\tlet options = { rootId: el.id }\r\n\t\tif (el.classList.contains('go-variants-hide-extras')) {\r\n\t\t\toptions.showExtras = false\r\n\t\t}\r\n\t\tdocument.goVariantsEditor(options)\r\n\t})\r\n})","module.exports = (options) => {\r\n    let rootId = options.rootId\r\n    return (\r\n    <div>\r\n\r\n        <style type=\"text/css\">\r\n            {`#${rootId}\r\n.masonry {\r\n    -moz-column-count: 3;\r\n    -webkit-column-count: 3;\r\n    column-count: 3;\r\n    column-gap: 1em;\r\n}\r\n.item {\r\n    background-color: #fff;\r\n    display: inline-block;\r\n    margin: 0 0 1em;\r\n    \r\n    padding: 2px;\r\n    border: 1px black solid;\r\n    width: 100%;\r\n}\r\n}\r\n.go-variants-extras {\r\ndisplay: none !important;\r\n}`}\r\n        </style>\r\n        <div class=\"masonry\">\r\n            <div class=\"item go-variants-extras\">\r\n                Paste the SGF for a game of toroidal Go, (e.g. from Little Golem) in the box, and then push the button to view the game!\r\n            <br /><label for={`${rootId}_sgfIn`}>T-Go SGF:</label>\r\n                <textarea id={`${rootId}_sgfIn`} rows=\"3\"></textarea>\r\n                <input type=\"button\" id={`${rootId}_goButton`} value=\"show board (from t-Go SGF)\" />\r\n\r\n            </div>\r\n\r\n            <div class=\"item go-variants-extras\">\r\n                <label for={`${rootId}_littleGolemId`}>LittleGolem game ID:</label>\r\n                <input id={`${rootId}_littleGolemId`} type=\"text\"></input>\r\n                <input type=\"button\" id={`${rootId}_goLgButton`} value=\"show board (from littleGolem game ID)\" /><span id={`${rootId}_goLgMsg`} />\r\n            </div>\r\n\r\n            <div class=\"item go-variants-extras\">\r\n                <label for={`${rootId}_sizeSelect`}>Size:</label>\r\n                <select id={`${rootId}_sizeSelect`}>\r\n                    {/* options filled by editor.js */}\r\n                </select>\r\n                <input type=\"button\" id={`${rootId}_newButton`} value=\"New game\" />\r\n            </div>\r\n            <div style=\"display: none\" id={`${rootId}_transformedSgfFs`} class=\"item go-variants-extras\">\r\n                <label for={`${rootId}_sgfOut`}>Transformed SGF:</label>\r\n                <textarea id={`${rootId}_sgfOut`} rows=\"3\"></textarea>\r\n            </div>\r\n            <div id={`${rootId}_viewerControls`} style=\"display:none\" class=\"item\">\r\n\r\n                <table title=\"panning\" style=\"float:left\">\r\n                    <tr>\r\n                        <td colspan=\"2\" style=\"text-align: center\">\r\n                            <input type=\"button\" value=\"↑\" />\r\n                        </td>\r\n                        <td rowspan=\"4\" style=\"vertical-align: middle\">“Panning”\r\n                <p> Use the buttons to the left to “pan” the board.</p>\r\n                        </td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td>\r\n                            <input type=\"button\" value=\"←\" />\r\n                        </td>\r\n                        <td>\r\n                            <input type=\"button\" value=\"→\" />\r\n                        </td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td colspan=\"2\" style=\"text-align: center\">\r\n                            <input type=\"button\" value=\"↓\" />\r\n                        </td>\r\n                    </tr>\r\n                    <tr>\r\n                        <td colspan=\"2\" style=\"text-align: center; font-size: small\" id={`${rootId}_offsetTr`} >\r\n                            panned: [0,0]\r\n            </td>\r\n                    </tr>\r\n                </table>\r\n            </div>\r\n            <div class=\"item\">\r\n                <label for={`${rootId}_wraparoundSelect`}>number of wraparound lines to add:</label>\r\n                <select id={`${rootId}_wraparoundSelect`}>\r\n                    <option value=\"0\">0</option>\r\n                    <option value=\"1\">1</option>\r\n                    <option value=\"2\">2</option>\r\n                    <option value=\"3\">3</option>\r\n                    <option value=\"4\" selected>4</option>\r\n                    <option value=\"5\">5</option>\r\n                    <option value=\"6\">6</option>\r\n                    <option value=\"7\">7</option>\r\n\r\n                </select>\r\n                <br />\r\n                <label for=\"addComments\">add comments:</label>\r\n                <input type=\"checkbox\" id={`${rootId}_addComments`} />\r\n                <br />\r\n                <label for={`${rootId}_wraparoundBorderSelect`}>Type of border for wraparound:</label>\r\n                <select id={`${rootId}_wraparoundBorderSelect`}>\r\n                    <option value=\"0\">No border</option>\r\n                    <option value=\"1\" selected>Full border</option>\r\n                    <option value=\"2\">Partial border (corners &amp; middles)</option>\r\n                    <option value=\"3\">Just corners</option>\r\n                    <option value=\"4\">Just middles</option>\r\n                </select>\r\n                <br />\r\n                <label for={`${rootId}_coordinateSelect`}>Type of coordinates:</label>\r\n                <select id={`${rootId}_coordinateSelect`}>\r\n                    <option value=\"0\" selected>None</option>\r\n                    <option value=\"1\">(→↑;A|1-K|11): Western</option>\r\n                    <option value=\"2\">(→↑;A|1-L|11): Western, no “I”</option>\r\n                    <option value=\"3\">(→↓;1|1-11|11): Latin/Latin, top to bottom</option>\r\n                    <option value=\"4\">(→↓;1|1-11|十一): Latin/Chinese, top to bottom</option>\r\n                </select>\r\n                <br />\r\n                <div id={`${rootId}_updateButtonDiv`} style=\"display:none\">\r\n                    <input type=\"button\" id={`${rootId}_updateButton`} value=\"update (from board)\" /> Press this button after adding marks to the board position in order to get the wraparound effect.\r\n                </div>\r\n            </div>\r\n\r\n        </div>\r\n        <div id={`${rootId}_playerDiv`} style=\"position:relative; height: 75vh;width: 85vw\"></div>\r\n    </div>)\r\n}"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FkZE1hcEVudHJ5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19hZGRTZXRFbnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlNYXAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbkluLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXRlcmF0ZWUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0VGFnLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja1NldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3Byb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUvbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3RvTnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9zcmMvZW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXNXaXRoLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc05hTi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmlxLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9ub29wLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91bmlxQnkuanMiLCJub2RlX21vZHVsZXMvc21hcnRnYW1lL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NtYXJ0Z2FtZXIvaW5kZXguanMiLCJzcmMvdHJhbnNmb3JtZXIuanMiLCJ1aS9lZGl0b3IuanMiLCJ1aS9lZGl0b3IuanN4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuVkM7OztBQUdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQStDRzs7Ozs7O0FBT0gsU0FBUyxXQUFULENBQXFCLE9BQXJCLEVBQ0U7QUFDRDs7QUFDQSxLQUNDLFdBQVcsUUFBUSxnQkFBUixDQURaO0FBQUEsS0FFRyxVQUFVLFFBQVEsZUFBUixDQUZiO0FBQUEsS0FHRyxNQUFNLFFBQVEsa0JBQVIsQ0FIVDtBQUFBLEtBSUcsU0FBUyxTQUFULE1BQVMsQ0FBQyxDQUFELEVBQUksQ0FBSjtBQUFBLFNBQVUsQ0FBQyxJQUFJLENBQUosR0FBUSxDQUFULElBQWMsQ0FBeEI7QUFBQSxFQUpaO0FBQUEsS0FLRyxtQkFBbUIsNEhBTHRCO0FBTUE7QUFDQyxtQkFBaUIsQ0FBQyxFQUFELEVBQUssRUFBTCxDQURsQjtBQUVHLHFCQUFtQixJQUZ0QjtBQUdHLGVBQWEsSUFIaEI7QUFJRyxtQkFBaUIsQ0FKcEI7QUFLRyx5QkFBdUIsQ0FMMUI7QUFNRyxZQUFVLENBTmI7QUFPRyxnQkFBYztBQUNoQjtBQVJELElBU00sT0FUTjtBQVdBLFNBQVEsa0JBQVI7QUFFRSxjQUFZLENBRmQ7QUFHRSxVQUFRLENBQUMsQ0FBRCxFQUFJLENBQUo7QUFIVixJQUlLLFFBQVEsa0JBSmI7O0FBT0EsS0FBSSxRQUFRLFNBQVIsS0FBc0IsU0FBMUIsRUFDQyxRQUFRLFNBQVIsR0FBb0IsSUFBcEI7O0FBRUQsU0FBUSxlQUFSLEdBQTBCLFFBQVEsZUFBUixJQUEyQixDQUFDLEVBQUQsRUFBSyxFQUFMLENBQXJEOztBQUVBLEtBQUksUUFBUSxpQkFBUixLQUE4QixTQUFsQyxFQUNDLFFBQVEsaUJBQVIsR0FBNEIsSUFBNUI7O0FBRUQsS0FBSSxRQUFRLFdBQVIsS0FBd0IsU0FBNUIsRUFDQyxRQUFRLFdBQVIsR0FBc0IsSUFBdEI7QUFDRDs7QUFFQSxLQUFJLGFBQWEsUUFBUSxrQkFBUixDQUEyQixVQUE1Qzs7QUFFQSxLQUFJLElBQUk7QUFDUDtBQUREO0FBQUEsS0FFRyxtQkFBbUIsU0FBbkIsZ0JBQW1CLENBQVUsQ0FBVixFQUFhO0FBQ2pDO0FBQ0EsU0FBTyxPQUFPLFlBQVAsQ0FBb0IsSUFBSSxFQUFKLEdBQVMsSUFBSSxFQUFiLEdBQWtCLElBQUksRUFBMUMsQ0FBUDtBQUNBO0FBQ0EsRUFORjtBQUFBLEtBUUMsc0JBQXNCLFNBQXRCLG1CQUFzQixDQUFDLENBQUQsRUFBTztBQUM1QixNQUFJLElBQUksRUFBRSxVQUFGLENBQWEsQ0FBYixDQUFSO0FBQ0EsU0FBTyxLQUFLLEVBQUwsR0FBVSxJQUFJLEVBQWQsR0FBbUIsSUFBSSxFQUE5QjtBQUNBLEVBWEY7O0FBWUM7Ozs7O0FBS0Esd0JBQXVCLFNBQXZCLG9CQUF1QixDQUFDLGdCQUFELEVBQXNCO0FBQzVDLFNBQU8sQ0FBQyxvQkFBb0IsaUJBQWlCLFNBQWpCLENBQTJCLENBQTNCLEVBQThCLENBQTlCLENBQXBCLENBQUQsRUFDSixvQkFBb0IsaUJBQWlCLFNBQWpCLENBQTJCLENBQTNCLEVBQThCLENBQTlCLENBQXBCLENBREksQ0FBUDtBQUdBLEVBckJGOztBQXdCQSxHQUFFLGdCQUFGLEdBQXFCLGdCQUFyQjtBQUNBLEdBQUUsb0JBQUYsR0FBeUIsb0JBQXpCO0FBQ0E7OztBQUdBLEdBQUUsT0FBRixHQUFZLE9BQVo7O0FBRUEsR0FBRSxhQUFGLEdBQWtCLFVBQVUsQ0FBVixFQUFhLFVBQWIsRUFBeUI7QUFDMUM7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxNQUFNLEVBQUU7QUFBRixJQUNILFFBQVEsZUFBUixDQUF3QixhQUFhLENBQWIsR0FBaUIsQ0FBekMsQ0FESDtBQUFBLE1BR0csSUFBSSxFQUhQOztBQUtBLE9BQUssSUFBSSxJQUFJLEtBQUssSUFBTCxDQUFVLEVBQUUsYUFBYSxDQUFmLElBQW9CLENBQTlCLENBQWIsRUFBK0MsS0FBSyxDQUFDLGFBQWEsQ0FBYixHQUFpQixDQUFqQixHQUFxQixDQUF0QixJQUEyQixDQUEvRSxFQUFrRixHQUFsRjtBQUNDLEtBQUUsSUFBRixDQUFPLGFBQWEsQ0FBYixHQUFpQixJQUFJLENBQTVCO0FBREQsR0FHQSxJQUFJLFFBQVEsUUFBUixLQUFxQixDQUF6QixFQUE0QjtBQUFDO0FBQzVCLEtBQUUsSUFBRixDQUFPLFVBQUMsQ0FBRCxFQUFJLENBQUosRUFBVTtBQUNoQixRQUFJLEtBQUssVUFBTCxJQUFtQixJQUFJLGFBQWEsQ0FBeEMsRUFBMkMsT0FBTyxDQUFQO0FBQzNDLFFBQUksS0FBSyxVQUFMLElBQW1CLElBQUksYUFBYSxDQUF4QyxFQUEyQyxPQUFPLENBQUMsQ0FBUjtBQUMzQyxXQUFPLENBQVA7QUFDQSxJQUpEO0FBS0E7QUFDRCxTQUFPLENBQVA7QUFDQSxFQWxDRDs7QUFvQ0E7Ozs7OztBQU1BLFVBQVMsb0JBQVQsQ0FBOEIsTUFBOUIsRUFBc0MsUUFBdEMsRUFBZ0Q7QUFDL0MsTUFBSSxDQUFDLE1BQU0sT0FBTixDQUFjLE9BQU8sQ0FBUCxDQUFkLENBQUwsRUFBK0IsU0FBUyxDQUFDLE1BQUQsQ0FBVDtBQUMvQixNQUFJLENBQUMsUUFBTCxFQUNDLE9BQU8sQ0FBQyxPQUFPLE9BQU8sQ0FBUCxFQUFVLENBQVYsSUFBZSxRQUFRLGtCQUFSLENBQTJCLE1BQTNCLENBQWtDLENBQWxDLENBQWYsR0FBc0QsVUFBN0QsRUFBeUUsUUFBUSxlQUFSLENBQXdCLENBQXhCLENBQXpFLENBQUQsRUFDSixPQUFPLE9BQU8sQ0FBUCxFQUFVLENBQVYsSUFBZSxRQUFRLGtCQUFSLENBQTJCLE1BQTNCLENBQWtDLENBQWxDLENBQWYsR0FBc0QsVUFBN0QsRUFBeUUsUUFBUSxlQUFSLENBQXdCLENBQXhCLENBQXpFLENBREksQ0FBUDtBQUVELFNBQU8sUUFBUSxPQUFPLEdBQVAsQ0FBVztBQUFBLFVBQUsscUJBQXFCLENBQUMsQ0FBRCxDQUFyQixDQUFMO0FBQUEsR0FBWCxDQUFSLEVBQW9ELFVBQUMsQ0FBRDtBQUFBLFVBQVUsRUFBRSxDQUFGLENBQVYsU0FBa0IsRUFBRSxDQUFGLENBQWxCO0FBQUEsR0FBcEQsQ0FBUDtBQUNBO0FBQ0QsR0FBRSxvQkFBRixHQUF5QixvQkFBekI7O0FBRUE7Ozs7O0FBS0EsVUFBUyxhQUFULENBQXVCLENBQXZCLEVBQTBCO0FBQ3pCLE1BQU0sSUFBSSxFQUFFLGFBQUYsQ0FBZ0IsRUFBRSxDQUFGLElBQU8sUUFBUSxrQkFBUixDQUEyQixNQUEzQixDQUFrQyxDQUFsQyxDQUF2QixDQUFWO0FBQUEsTUFDRyxJQUFJLEVBQUUsYUFBRixDQUFnQixFQUFFLENBQUYsSUFBTyxRQUFRLGtCQUFSLENBQTJCLE1BQTNCLENBQWtDLENBQWxDLENBQXZCLEVBQTZELElBQTdELENBRFA7QUFBQSxNQUVHLElBQUksRUFGUDtBQUdBLE9BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFFLE1BQXRCLEVBQThCLEdBQTlCO0FBQ0MsUUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEVBQUUsTUFBdEIsRUFBOEIsR0FBOUI7QUFDQyxNQUFFLElBQUYsQ0FBTyxDQUFDLEVBQUUsQ0FBRixDQUFELEVBQU8sRUFBRSxDQUFGLENBQVAsQ0FBUDtBQUREO0FBREQsR0FHQSxPQUFPLENBQVA7QUFDQTtBQUNELEdBQUUsYUFBRixHQUFrQixhQUFsQjs7QUFFQSxHQUFFLElBQUYsR0FBUyxVQUFDLENBQUQ7QUFBQSxTQUFPLE9BQU8sQ0FBUCxFQUFVLFFBQVEsZUFBUixDQUF3QixDQUF4QixDQUFWLENBQVA7QUFBQSxFQUFUO0FBQ0EsR0FBRSxJQUFGLEdBQVMsVUFBQyxDQUFEO0FBQUEsU0FBTyxPQUFPLENBQVAsRUFBVSxRQUFRLGVBQVIsQ0FBd0IsQ0FBeEIsQ0FBVixDQUFQO0FBQUEsRUFBVDs7QUFFQSxLQUFJLGVBQWUsU0FBZixZQUFlLEdBQU07QUFDeEIsSUFBRSxtQkFBRixHQUF3QixFQUF4Qjs7QUFFQTtBQUNBLE1BQUksUUFBUSxrQkFBUixDQUEyQixVQUEzQixHQUF3QyxDQUE1QyxFQUErQztBQUM5QyxPQUFNLElBQUksUUFBUSxlQUFSLENBQXdCLENBQXhCLENBQVY7QUFBQSxPQUNDLElBQUksUUFBUSxlQUFSLENBQXdCLENBQXhCLENBREw7O0FBR0E7Ozs7Ozs7O0FBUUEsT0FBSSxRQUFRLEVBQVo7QUFDQSxPQUFJLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsT0FBVixDQUFrQixRQUFRLHFCQUExQixJQUFtRCxDQUFDLENBQXhELEVBQTJEO0FBQzFELFFBQUksVUFBVSxRQUFRLHFCQUFSLEdBQWdDLENBQWhDLEdBQ2IsQ0FBQyxLQUFLLEtBQUwsQ0FBVyxDQUFDLElBQUksQ0FBTCxJQUFVLENBQXJCLElBQTBCLENBQTNCLEVBQThCLEtBQUssSUFBTCxDQUFVLENBQUMsSUFBSSxDQUFMLElBQVUsQ0FBcEIsSUFBeUIsQ0FBdkQsRUFDQSxLQUFLLEtBQUwsQ0FBVyxDQUFDLElBQUksQ0FBTCxJQUFVLENBQXJCLElBQTBCLENBRDFCLEVBQzZCLEtBQUssSUFBTCxDQUFVLENBQUMsSUFBSSxDQUFMLElBQVUsQ0FBcEIsSUFBeUIsQ0FEdEQsQ0FEYSxHQUdYLENBQUMsQ0FBQyxDQUFGLEVBQUssRUFBTCxFQUFTLENBQUMsQ0FBVixFQUFhLEVBQWIsQ0FISDtBQUlBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsS0FBSyxDQUFyQixFQUF3QixHQUF4QixFQUE2QjtBQUM1QixTQUFJLElBQUksUUFBUSxDQUFSLENBQUosSUFBa0IsSUFBSSxRQUFRLENBQVIsQ0FBMUIsRUFBc0M7QUFDckM7QUFDQTtBQUNELFNBQUksUUFBUSxHQUFaLENBSjRCLENBSWI7O0FBRWYsV0FBTSxJQUFOLENBQVcsaUJBQWlCLGFBQWEsQ0FBYixHQUFpQixDQUFsQyxJQUF1QyxpQkFBaUIsYUFBYSxDQUE5QixDQUF2QyxHQUEwRSxHQUExRSxHQUFnRixLQUEzRjtBQUNBLFdBQU0sSUFBTixDQUFXLGlCQUFpQixhQUFhLENBQWIsR0FBaUIsQ0FBbEMsSUFBdUMsaUJBQWlCLGFBQWEsQ0FBOUIsQ0FBdkMsR0FBMEUsR0FBMUUsR0FBZ0YsS0FBM0Y7QUFDQTtBQUNELFNBQUssSUFBSSxLQUFJLENBQWIsRUFBZ0IsTUFBSyxDQUFyQixFQUF3QixJQUF4QixFQUE2QjtBQUM1QixTQUFJLEtBQUksUUFBUSxDQUFSLENBQUosSUFBa0IsS0FBSSxRQUFRLENBQVIsQ0FBMUIsRUFBc0M7QUFDckM7QUFDQTtBQUNELFNBQUksU0FBUSxHQUFaLENBSjRCLENBSWI7QUFDZixXQUFNLElBQU4sQ0FBVyxpQkFBaUIsYUFBYSxDQUE5QixJQUFtQyxpQkFBaUIsYUFBYSxDQUFiLEdBQWlCLEVBQWxDLENBQW5DLEdBQTBFLEdBQTFFLEdBQWdGLE1BQTNGO0FBQ0EsV0FBTSxJQUFOLENBQVcsaUJBQWlCLGFBQWEsQ0FBOUIsSUFBbUMsaUJBQWlCLGFBQWEsQ0FBYixHQUFpQixFQUFsQyxDQUFuQyxHQUEwRSxHQUExRSxHQUFnRixNQUEzRjtBQUNBO0FBQ0Q7QUFDRCxPQUFJLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsT0FBVixDQUFrQixRQUFRLHFCQUExQixJQUFtRCxDQUFDLENBQXhELEVBQTJEO0FBQzFEO0FBQ0EsVUFBTSxJQUFOLENBQVcsaUJBQWlCLGFBQWEsQ0FBOUIsSUFBbUMsaUJBQWlCLGFBQWEsQ0FBOUIsQ0FBbkMsR0FBc0UsSUFBakY7QUFDQSxVQUFNLElBQU4sQ0FBVyxpQkFBaUIsYUFBYSxDQUE5QixJQUFtQyxpQkFBaUIsYUFBYSxDQUE5QixDQUFuQyxHQUFzRSxJQUFqRjtBQUNBLFVBQU0sSUFBTixDQUFXLGlCQUFpQixhQUFhLENBQTlCLElBQW1DLGlCQUFpQixhQUFhLENBQTlCLENBQW5DLEdBQXNFLElBQWpGO0FBQ0EsVUFBTSxJQUFOLENBQVcsaUJBQWlCLGFBQWEsQ0FBOUIsSUFBbUMsaUJBQWlCLGFBQWEsQ0FBOUIsQ0FBbkMsR0FBc0UsSUFBakY7QUFDQTs7QUFFRCxPQUFJLFFBQVEsZUFBUixHQUEwQixDQUExQixJQUErQixhQUFhLENBQWhELEVBQW1EO0FBQ2xELFNBQUssSUFBSSxNQUFJLENBQWIsRUFBZ0IsTUFBSSxJQUFJLFVBQUosR0FBaUIsQ0FBakIsR0FBcUIsQ0FBekMsRUFBNEMsS0FBNUMsRUFBaUQ7O0FBRWhELFNBQUksYUFBYSxFQUFFLElBQUYsQ0FBTyxDQUFDLFFBQVEsa0JBQVIsQ0FBMkIsTUFBM0IsQ0FBa0MsQ0FBbEMsQ0FBRCxHQUF3QyxVQUF4QyxHQUFxRCxHQUE1RCxDQUFqQjs7QUFFQSxTQUFJLFFBQVEsZUFBUixLQUE0QixDQUE1QixJQUFpQyxjQUFjLENBQW5ELEVBQXNEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0QsU0FBSSxVQUNILFFBQVEsZUFBUixHQUEwQixDQUExQixHQUNHLGlCQUFpQixVQUFqQixFQUE2QixXQUE3QixFQURILEdBRUcsTUFBTSxhQUFhLENBQW5CLENBSEo7QUFJQSxXQUFNLElBQU4sQ0FBVyxpQkFBaUIsR0FBakIsSUFBc0IsaUJBQWlCLENBQWpCLENBQXRCLEdBQTRDLEdBQTVDLEdBQWtELE9BQTdEO0FBQ0EsV0FBTSxJQUFOLENBQVcsaUJBQWlCLEdBQWpCLElBQXNCLGlCQUFpQixJQUFJLFVBQUosR0FBaUIsQ0FBakIsR0FBcUIsQ0FBdEMsQ0FBdEIsR0FBaUUsR0FBakUsR0FBdUUsT0FBbEY7QUFDQTtBQUNELFFBQUksYUFBYSxXQUFqQjtBQUNBLFNBQUssSUFBSSxNQUFJLENBQWIsRUFBZ0IsTUFBSSxJQUFJLFVBQUosR0FBaUIsQ0FBakIsR0FBcUIsQ0FBekMsRUFBNEMsS0FBNUMsRUFBaUQ7QUFDaEQ7Ozs7Ozs7OztBQVNBLFNBQUksY0FDSCxRQUFRLGVBQVIsR0FBMEIsQ0FBMUIsR0FDRyxFQUFFLElBQUYsQ0FBTyxJQUFJLFFBQVEsa0JBQVIsQ0FBMkIsTUFBM0IsQ0FBa0MsQ0FBbEMsQ0FBSixHQUEyQyxVQUEzQyxHQUF3RCxHQUF4RCxHQUE0RCxDQUFuRSxDQURILEdBRUcsRUFBRSxJQUFGLENBQU8sTUFBSSxVQUFKLEdBQWlCLFFBQVEsa0JBQVIsQ0FBMkIsTUFBM0IsQ0FBa0MsQ0FBbEMsQ0FBeEIsQ0FISjtBQUlBLFNBQUksVUFBUSxFQUFaO0FBQ0EsYUFBUSxRQUFRLGVBQWhCO0FBQ0MsV0FBSyxDQUFMO0FBQ0EsV0FBSyxDQUFMO0FBQ0EsV0FBSyxDQUFMO0FBQ0MsaUJBQVEsTUFBTSxjQUFhLENBQW5CLENBQVI7QUFDQTtBQUNELFdBQUssQ0FBTDtBQUNDLGlCQUFRLE9BQU8sV0FBUCxFQUFtQixFQUFuQixNQUEyQixDQUEzQixHQUErQixFQUEvQixHQUFvQyxXQUFXLE9BQU8sV0FBUCxFQUFtQixFQUFuQixDQUFYLENBQTVDOztBQUVBLFdBQUksY0FBYSxDQUFqQixFQUFvQjtBQUNuQixrQkFBUSxDQUFDLGNBQWEsRUFBYixHQUFrQixXQUFXLEtBQUssS0FBTCxDQUFXLENBQUMsY0FBYSxDQUFkLElBQW1CLEVBQTlCLElBQW9DLENBQS9DLENBQWxCLEdBQXNFLEVBQXZFLElBQTZFLEdBQTdFLEdBQW1GLE9BQTNGO0FBQ0E7QUFDRDtBQVpGO0FBY0EsV0FBTSxJQUFOLENBQVcsaUJBQWlCLENBQWpCLElBQXNCLGlCQUFpQixHQUFqQixDQUF0QixHQUE0QyxHQUE1QyxHQUFrRCxPQUE3RDtBQUNBLFdBQU0sSUFBTixDQUFXLGlCQUFpQixJQUFJLFVBQUosR0FBaUIsQ0FBakIsR0FBcUIsQ0FBdEMsSUFBMkMsaUJBQWlCLEdBQWpCLENBQTNDLEdBQWlFLEdBQWpFLEdBQXVFLE9BQWxGO0FBQ0E7QUFDRDs7QUFFRCxLQUFFLG1CQUFGLEdBQXdCLEtBQXhCO0FBQ0E7QUFDRCxFQXRHRDtBQXVHQTs7QUFHQSxHQUFFLGFBQUY7QUFDQzs7O0FBR0EsVUFBUyxhQUFULENBQXVCLE1BQXZCLEVBQStCO0FBQzlCLFNBQU8saUJBQWlCLE9BQU8sQ0FBUCxDQUFqQixJQUE4QixpQkFBaUIsT0FBTyxDQUFQLENBQWpCLENBQXJDO0FBQ0EsRUFORjs7QUFRQSxVQUFTLGFBQVQsQ0FBdUIsS0FBdkIsRUFBOEI7QUFBQSxNQUN2QixXQUR1QixHQUMwQixLQUQxQixDQUN2QixXQUR1QjtBQUFBLE1BQ1YsSUFEVSxHQUMwQixLQUQxQixDQUNWLElBRFU7QUFBQSxNQUNKLE9BREksR0FDMEIsS0FEMUIsQ0FDSixPQURJO0FBQUEsTUFDSyxXQURMLEdBQzBCLEtBRDFCLENBQ0ssV0FETDtBQUFBLE1BQ2tCLEdBRGxCLEdBQzBCLEtBRDFCLENBQ2tCLEdBRGxCO0FBQUEsTUFFMUIsWUFGMEIsR0FFWCxZQUFZLFVBQVosR0FBeUIsTUFGZDs7QUFHN0IsTUFBSSxZQUFZLENBQVosR0FBZ0IsSUFBcEIsRUFBMEIsTUFBTSxJQUFJLEtBQUosQ0FBVSxtQkFBVixDQUFOO0FBQzFCLFFBQU0sV0FBTixHQUFvQixlQUFlLENBQW5DO0FBQ0EsTUFBSSxNQUFNLFdBQVYsRUFBdUI7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUssSUFBSSxJQUFJLGVBQWUsQ0FBNUIsRUFBK0IsSUFBSSxDQUFuQyxFQUFzQyxHQUF0QztBQUNBO0FBQ0E7QUFDQyxRQUFJLDRCQUFvQixXQUFwQixDQUFKLENBREQsQ0FDc0M7QUFDckMsaUJBQWEsWUFBWSxDQUFaLEdBQWdCLENBQTdCLElBQWtDLENBQWxDO0FBQ0EsaUJBQWEsQ0FBYixJQUFrQixDQUFsQjs7QUFFQSxRQUFJLFFBQVEsU0FBWixFQUNDLFFBQVEsSUFBUixDQUFhLEVBQUUsTUFBTSxZQUFSLEVBQXNCLFNBQVMsSUFBSSxVQUFKLEVBQS9CLEVBQWIsRUFERCxLQUdDLFFBQVEsSUFBUixDQUFhLEVBQUUsTUFBTSxZQUFSLEVBQWI7QUFFRDtBQUNELFNBQU0sSUFBTixHQUFhLFlBQVksSUFBWixHQUFtQixJQUFuQixFQUFiO0FBQ0EsZUFBWSxZQUFZLENBQVosR0FBZ0IsQ0FBNUIsSUFBaUMsQ0FBakM7QUFDQSxlQUFZLENBQVosSUFBaUIsQ0FBakI7QUFDQSxVQUFPLE1BQU0sSUFBYjtBQUNBOztBQUVELE1BQUksV0FBVyxZQUFZLElBQVosR0FBbUIsSUFBbkIsRUFBZjtBQUNBLE1BQUksU0FBUyxRQUFiLEVBQXVCO0FBQUM7QUFDdkIsT0FBSSxRQUFRLE1BQVIsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDekIsVUFBTSxJQUFOLEdBQWEsSUFBYjtBQUNBLFdBQU8sTUFBTSxJQUFiLENBRnlCLENBRVI7QUFDakI7QUFDRCxPQUFJLFlBQVksUUFBUSxHQUFSLEVBQWhCO0FBQ0EsU0FBTSxXQUFOLEdBQW9CLElBQXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFJLFFBQVEsU0FBWixFQUF1QixJQUFJLFFBQUosQ0FBYSxVQUFVLE9BQXZCO0FBQ3ZCLFNBQU0sSUFBTixHQUFhLFlBQVksSUFBWixDQUFpQixVQUFVLElBQTNCLEVBQWlDLElBQWpDLEVBQWI7QUFDQSxTQUFNLFdBQU4sR0FBb0IsVUFBVSxJQUE5QjtBQUNBLFVBQU8sTUFBTSxJQUFiO0FBQ0EsR0FmRCxNQWdCSztBQUNKLGVBQVksQ0FBWixJQUFpQixDQUFqQjtBQUNBLFNBQU0sSUFBTixHQUFhLFFBQWI7QUFDQSxVQUFPLE1BQU0sSUFBYjtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFVBQVMsZ0JBQVQsQ0FDQyxXQURELEVBQ2MsU0FEZCxFQUN5Qjs7QUFFeEIsTUFBSSxjQUFjLFNBQWxCLEVBQTZCO0FBQzVCLGVBQVksUUFBUSxXQUFSLENBQVo7QUFDQTs7QUFFRCxNQUFJLE9BQU8sV0FBUCxLQUF1QixRQUEzQixFQUFxQztBQUNwQyxPQUFJLGFBQWEsUUFBUSxZQUFSLENBQWpCO0FBQ0EsaUJBQWMsV0FBVyxVQUFVLEtBQVYsQ0FBZ0IsV0FBaEIsQ0FBWCxDQUFkO0FBQ0E7O0FBRUQsTUFBSSxPQUFPLFlBQVksS0FBWixHQUFvQixJQUFwQixFQUFYO0FBQUEsTUFDRyxVQUFVLEVBRGI7QUFBQSxNQUVHLGNBQWMsRUFBRSxHQUFHLENBQUwsRUFGakI7QUFBQSxNQUdHLGVBQWUsd0RBSGxCO0FBQUEsTUFJRyxnQkFBZ0IsU0FBaEIsYUFBZ0IsR0FBTTtBQUN2QixPQUFJLEtBQUssQ0FBTCxLQUFXLFNBQWYsRUFBMEI7QUFDekIsU0FBSyxDQUFMLEdBQVMsS0FBSyxDQUFMLENBQU8sT0FBUCxDQUFlLFlBQWYsRUFBNkIsRUFBN0IsQ0FBVDtBQUNBO0FBQ0QsT0FBSSxLQUFLLENBQUwsS0FBVyxFQUFmLEVBQ0MsT0FBTyxLQUFLLENBQVo7QUFDRCxHQVZGOztBQVlDOzs7OztBQUtBLGdCQUFjLFNBQWQsV0FBYyxHQUFNOztBQUVuQixPQUFJLFNBQVMsRUFBYjtBQUNBLE9BQUksS0FBSyxFQUFMLEtBQVksU0FBaEIsRUFBMkI7QUFDMUIsYUFBUyxLQUFLLEVBQWQ7QUFDQSxRQUFJLENBQUMsTUFBTSxPQUFOLENBQWMsTUFBZCxDQUFMLEVBQ0MsU0FBUyxDQUFDLE1BQUQsQ0FBVDtBQUNELGFBQVMsT0FBTyxNQUFQLENBQWM7QUFBQSxZQUFLLENBQUMsRUFBRSxtQkFBRixDQUFzQixRQUF0QixDQUErQixDQUEvQixDQUFOO0FBQUEsS0FBZCxDQUFUO0FBQ0E7QUFDQSxhQUNDLFFBQ0MsT0FDRSxHQURGLENBQ00sVUFBVSxDQUFWLEVBQWE7QUFBRSxZQUFPLEVBQUUsS0FBRixDQUFRLEdBQVIsRUFBYSxDQUFiLENBQVA7QUFBd0IsS0FEN0MsRUFDOEM7QUFEOUMsS0FFRSxHQUZGLENBRU0sVUFBQyxDQUFEO0FBQUEsWUFBTyxDQUFDLEVBQUUsYUFBRixDQUFnQixFQUFFLG9CQUFGLENBQXVCLHFCQUFxQixFQUFFLENBQUYsQ0FBckIsQ0FBdkIsQ0FBaEIsQ0FBRCxFQUFzRSxFQUFFLENBQUYsQ0FBdEUsQ0FBUDtBQUFBLEtBRk4sQ0FERCxFQUlHLFVBQUMsQ0FBRDtBQUFBLFlBQU8sRUFBRSxDQUFGLENBQVA7QUFBQSxLQUpILEVBS0UsR0FMRixDQUtNLFVBQUMsQ0FBRDtBQUFBLFlBQVUsRUFBRSxDQUFGLENBQVYsU0FBa0IsRUFBRSxDQUFGLENBQWxCO0FBQUEsS0FMTixDQUREOztBQVNBO0FBQ0E7QUFDQTtBQUNBOztBQUVELFFBQUssRUFBTCxHQUFVLE1BQVY7QUFDQSxPQUFJLEtBQUssRUFBTCxDQUFRLE1BQVIsS0FBbUIsQ0FBdkIsRUFDQyxPQUFPLEtBQUssRUFBWjs7QUFFRCxPQUFJLEtBQUssRUFBVCxFQUNDLE9BQU8sS0FBSyxFQUFaO0FBQ0QsT0FBSSxLQUFLLEVBQVQsRUFDQyxPQUFPLEtBQUssRUFBWjtBQUNELEdBaERGOztBQWtEQTtBQUNBLE9BQUssRUFBTCxHQUFVLFFBQVEsZUFBUixDQUF3QixDQUF4QixDQUFWO0FBQ0EsT0FBSyxFQUFMLEdBQVUseUJBQVY7O0FBRUEsTUFBSSxLQUFLLEVBQUwsS0FBWSxTQUFoQixFQUEyQjtBQUMxQixPQUFJLG1CQUFtQixJQUFJLE1BQUosVUFBa0IsZ0JBQWxCLFNBQXZCO0FBQ0EsUUFBSyxFQUFMLEdBQVUsS0FBSyxFQUFMLENBQVEsT0FBUixDQUFnQixnQkFBaEIsRUFBa0MsRUFBbEMsQ0FBVjtBQUNBO0FBQ0E7QUFDQTs7QUFFRCxNQUFJLFFBQVE7QUFDWCwyQkFEVyxFQUNFLFVBREYsRUFDUSxnQkFEUixFQUNpQix3QkFEakIsRUFDOEIsY0FBYyxFQUQ1QyxDQUM4QztBQUQ5QyxHQUFaOztBQUlBLFNBQU8sY0FBYyxLQUFkLENBQVA7QUFDQSxTQUFPLFNBQVMsSUFBaEIsRUFBc0I7QUFDckI7QUFDQTs7QUFFQSxPQUNDLFVBQVUsS0FBSyxFQUFMLEtBQVksU0FBWixJQUF5QixLQUFLLENBQUwsS0FBVyxTQUQvQztBQUFBLE9BRUcsY0FBYyxVQUFVLEtBQUssRUFBZixHQUFvQixLQUFLLEVBRjFDO0FBQUEsT0FHRyxjQUFjLFVBQVUsS0FBSyxDQUFmLEdBQW1CLEtBQUssQ0FIekM7QUFBQSxPQUlHLE9BQU8sY0FBYyxXQUFkLEdBQTRCLFdBSnRDO0FBQUEsT0FLRyxjQUFjLE1BQU0sT0FBTixDQUFjLElBQWQsSUFBc0IsSUFBdEIsR0FBNkIsQ0FBQyxJQUFELENBTDlDO0FBQUEsT0FNRyxVQUFVLFVBQVUsS0FBSyxDQUFMLEtBQVcsRUFBckIsR0FBMEIsS0FBSyxDQUFMLEtBQVcsRUFObEQ7QUFBQSxPQU9HLGdCQUFnQixTQUFTLFNBQVQsSUFBc0IsU0FBUyxFQVBsRDtBQUFBLE9BUUcsU0FBUyxDQUFDLGFBQUQsR0FBaUIsU0FBakIsR0FBNkIsRUFBRSxhQUFGLENBQWdCLEVBQUUsb0JBQUYsQ0FBdUIsWUFBWSxHQUFaLENBQWdCLG9CQUFoQixDQUF2QixDQUFoQixDQVJ6Qzs7QUFVQTs7QUFFQTs7Ozs7QUFLQSxPQUFJLE1BQU0sV0FBVixFQUF1QjtBQUN0QixRQUFJLDZCQUFxQixZQUFZLElBQWpDLENBQUosQ0FEc0IsQ0FDc0I7QUFDNUMsa0JBQWMsQ0FBZDtBQUNBLFdBQU8sY0FBYyxjQUFjLENBQTVCLENBQVA7QUFDQSxvQkFBZ0IsWUFBWSxhQUFaLENBQTBCLGFBQTFCLENBQWhCO0FBQ0E7QUFDQSxRQUFJLE1BQU0sWUFBTixDQUFtQixhQUFuQixNQUFzQyxTQUExQyxFQUFxRDtBQUNwRCxXQUFNLFlBQU4sQ0FBbUIsYUFBbkIsSUFBb0MsRUFBcEM7QUFDQTtBQUNELFFBQUksV0FBSixFQUFpQjtBQUNoQixXQUFNLFlBQU4sQ0FBbUIsYUFBbkIsRUFBa0MsSUFBbEMsQ0FBdUMsTUFBdkM7QUFDQSxLQUZELE1BSUMsSUFBSSxlQUFlLE1BQU0sWUFBTixDQUFtQixhQUFuQixFQUFrQyxPQUFsQyxDQUEwQyxNQUExQyxJQUFvRCxDQUFDLENBQXhFLEVBQTJFOztBQUUxRTtBQUNBLFVBQUssRUFBTCxHQUFVLDBCQUFWO0FBQ0E7QUFDRjtBQUNBOztBQUVELFVBQU8sS0FBSyxVQUFVLElBQVYsR0FBaUIsSUFBdEIsQ0FBUDtBQUNBLFVBQU8sS0FBSyxVQUFVLEdBQVYsR0FBZ0IsR0FBckIsQ0FBUDtBQUNBLFVBQU8sS0FBSyxFQUFaO0FBQ0EsVUFBTyxLQUFLLEVBQVo7O0FBRUEsT0FBSSxPQUFKLEVBQWE7QUFDWixTQUFLLFVBQVUsR0FBVixHQUFnQixHQUFyQixJQUE0QixFQUE1QjtBQUNBOztBQUVELE9BQUksYUFBSixFQUFtQjtBQUNsQixTQUFLLFVBQVUsR0FBVixHQUFnQixHQUFyQixJQUE0QixNQUE1QjtBQUNBOztBQUVELElBdkRxQixDQXVEcEIseUNBQXlDLENBQUM7QUFDMUM7QUFDQSxPQUZ5QyxFQUVuQyxJQUZtQyxFQUU3QixJQUY2QixFQUV2QixJQUZ1QixFQUVqQixJQUZpQixFQUVYLE9BRlcsQ0FFSCxVQUFVLFdBQVYsRUFBdUI7QUFDNUQ7QUFDQSxRQUFJLEtBQUssV0FBTCxNQUFzQixTQUExQixFQUFxQztBQUNyQyxRQUFJLFNBQVMsRUFBYjtBQUNBLFFBQUksTUFBTSxPQUFOLENBQWMsS0FBSyxXQUFMLENBQWQsQ0FBSixFQUFzQztBQUNyQyxjQUFTLEtBQUssV0FBTCxDQUFUO0FBQ0EsS0FGRCxNQUdLO0FBQ0osY0FBUyxDQUFDLEtBQUssV0FBTCxDQUFELENBQVQ7QUFDQTtBQUNELGFBQ0MsRUFBRSxvQkFBRixDQUNDLE9BQU8sR0FBUCxDQUFXLG9CQUFYLENBREQsRUFDbUMsSUFEbkMsRUFHRSxHQUhGLENBR00sRUFBRSxhQUhSLENBREQ7QUFLQSxTQUFLLFdBQUwsSUFBb0IsTUFBcEI7QUFDQSxJQWxCd0M7QUFtQjFDO0FBQ0EsVUFBTyxjQUFjLEtBQWQsQ0FBUDtBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE1BQUksY0FBYyxTQUFkLFdBQWMsQ0FBQyxRQUFELEVBQWM7QUFDL0IsT0FBSSxTQUFTLFNBQWIsRUFBd0I7O0FBRXZCLFFBQ0MsWUFBWSxTQUFTLFNBRHRCO0FBQUEsUUFFRyxRQUFRLElBQUksU0FBSixFQUFlLFVBQUMsR0FBRDtBQUFBLFlBQVMsSUFBSSxLQUFKLENBQVUsQ0FBVixFQUFhLEVBQWIsS0FBb0IsMEJBQTdCO0FBQUEsS0FBZixDQUZYO0FBQUEsUUFHRyxPQUFPLENBSFY7QUFBQSxRQUdhLE1BQU0sVUFBVSxNQUg3QjtBQUlBLFdBQU8sUUFBUSxDQUFDLENBQWhCLEVBQW1CO0FBQ2xCLGVBQVUsTUFBVixDQUFpQixLQUFqQixFQUF3QixDQUF4QjtBQUNBLGFBQVEsSUFBSSxTQUFKLEVBQWUsVUFBQyxHQUFEO0FBQUEsYUFBUyxJQUFJLEtBQUosQ0FBVSxDQUFWLEVBQWEsRUFBYixLQUFvQiwwQkFBN0I7QUFBQSxNQUFmLENBQVI7QUFDQTtBQUNBLFNBQUksT0FBTyxHQUFYLEVBQWdCLE1BQU0sSUFBSSxLQUFKLENBQVUsbUJBQVYsQ0FBTjtBQUNoQjtBQUNELFNBQUssSUFBSSxTQUFTLENBQWxCLEVBQXFCLFNBQVMsVUFBVSxNQUF4QyxFQUFnRCxRQUFoRCxFQUEwRDtBQUN6RDtBQUNBLGlCQUFZLFVBQVUsTUFBVixDQUFaO0FBRUE7QUFDRCxJQWpCRCxNQWtCSyxJQUFJLFNBQVMsS0FBYixFQUNKLFlBQVksU0FBUyxLQUFULENBQWUsU0FBUyxLQUFULENBQWUsTUFBZixHQUF3QixDQUF2QyxDQUFaO0FBQ0QsR0FyQkQ7QUFzQkEsY0FBWSxZQUFZLElBQXhCOztBQUVBLE1BQUksUUFBUSxpQkFBWixFQUNDLE9BQU8sVUFBVSxRQUFWLENBQW1CLEVBQUUsV0FBVyxDQUFDLFlBQVksSUFBYixDQUFiLEVBQW5CLENBQVAsQ0FERCxLQUVLLE9BQU8sV0FBUDtBQUVMO0FBQ0QsR0FBRSxnQkFBRixHQUFxQixnQkFBckI7O0FBRUE7Ozs7Ozs7OztBQVNBLFVBQVMsU0FBVCxDQUNDLElBREQsQ0FDTTtBQUROLEdBRUcsR0FGSCxDQUVPO0FBRlAsR0FHRyxTQUhILEVBSUcsVUFKSCxFQUllOztBQUVkLE1BQUksUUFBUSxTQUFaLEVBQXVCO0FBQ3RCO0FBQ0E7QUFDQSxTQUFNLFFBQVEsb0JBQVIsRUFBOEI7QUFDbkM7QUFDQTtBQUNBLHFCQUFpQixRQUFRO0FBSFUsSUFBOUIsQ0FBTjtBQUtBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDQTs7QUFFQSxNQUFJLGNBQWMsU0FBbEIsRUFBNkI7QUFDNUIsZUFBWSxRQUFRLFdBQVIsQ0FBWjtBQUNBO0FBQ0QsTUFBSSxlQUFlLFNBQW5CLEVBQThCO0FBQzdCLGdCQUFhLFFBQVEsWUFBUixDQUFiO0FBQ0E7QUFDRDtBQUNBLE1BQUksU0FBUyxVQUFVLEtBQVYsQ0FBZ0IsSUFBaEIsQ0FBYjtBQUFBLE1BQ0csY0FBYyxXQUFXLE1BQVgsQ0FEakI7QUFBQSxNQUVHLE9BQU8sWUFBWSxJQUFaLEVBRlY7QUFBQSxNQUdHLFNBQVMsQ0FIWjtBQUFBLE1BSUcsVUFBVSxFQUpiO0FBQUEsTUFLRyxjQUFjLEVBQUUsR0FBRyxDQUFMLEVBTGpCO0FBTUEsTUFBSSxLQUFLLEVBQUwsS0FBWSxTQUFoQixFQUEyQjtBQUMxQixPQUFJLEtBQUssT0FBTyxLQUFLLEVBQVosQ0FBVDtBQUNBO0FBQ0EsV0FBUSxlQUFSLEdBQTBCLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FBMUI7QUFDQSxPQUFJLE9BQUosQ0FBWSxlQUFaLEdBQThCLFFBQVEsZUFBdEM7QUFDQTtBQUNBO0FBQ0QsTUFBSSxLQUFLLEVBQUwsS0FBWSxTQUFoQixFQUEyQjtBQUMxQixXQUFRLEtBQVIsY0FBa0IsTUFBTSxXQUFXLEtBQUssRUFBaEIsQ0FBeEIsSUFBZ0QsUUFBUSxLQUF4RDtBQUNBO0FBQ0QsT0FBSyxFQUFMLEdBQVUsTUFBTSxRQUFRLGVBQVIsQ0FBd0IsQ0FBeEIsSUFBNkIsSUFBSSxRQUFRLGtCQUFSLENBQTJCLFVBQWxFLENBQVYsQ0F4Q2MsQ0F3Q3lFO0FBQ3ZGO0FBQ0EsVUFBUSxrQkFBUixDQUEyQixNQUEzQixDQUFrQyxDQUFsQyxJQUF1QyxPQUFPLFFBQVEsa0JBQVIsQ0FBMkIsTUFBM0IsQ0FBa0MsQ0FBbEMsQ0FBUCxFQUE2QyxRQUFRLGVBQVIsQ0FBd0IsQ0FBeEIsQ0FBN0MsQ0FBdkM7QUFDQSxVQUFRLGtCQUFSLENBQTJCLE1BQTNCLENBQWtDLENBQWxDLElBQXVDLE9BQU8sUUFBUSxrQkFBUixDQUEyQixNQUEzQixDQUFrQyxDQUFsQyxDQUFQLEVBQTZDLFFBQVEsZUFBUixDQUF3QixDQUF4QixDQUE3QyxDQUF2QztBQUNBLE1BQUksWUFBWSxTQUFaLFNBQVksR0FBTTtBQUNyQjtBQUNBLE9BQUksU0FBUyxFQUFiO0FBQ0EsT0FBSSxLQUFLLEVBQUwsS0FBWSxTQUFoQixFQUEyQjtBQUFBO0FBQzFCLGNBQVMsS0FBSyxFQUFkO0FBQ0EsU0FBSSxDQUFDLE1BQU0sT0FBTixDQUFjLE1BQWQsQ0FBTCxFQUNDLFNBQVMsQ0FBQyxNQUFELENBQVQ7O0FBRUQ7QUFDQSxTQUFJLFVBQVUsT0FBTTtBQUFOLE1BQ1osR0FEWSxDQUNSLFVBQVUsQ0FBVixFQUFhO0FBQUUsYUFBTyxFQUFFLEtBQUYsQ0FBUSxHQUFSLEVBQWEsQ0FBYixDQUFQO0FBQXdCLE1BRC9CLEVBQ2dDO0FBRGhDLE1BRVosR0FGWSxDQUVSLFVBQVUsQ0FBVixFQUFhO0FBQUUsYUFBTyxDQUFDLHFCQUFxQixFQUFFLENBQUYsQ0FBckIsQ0FBRCxFQUE2QixFQUFFLENBQUYsQ0FBN0IsQ0FBUDtBQUEyQyxNQUZsRCxFQUdaLEdBSFksQ0FHUixVQUFVLENBQVYsRUFBYTtBQUFFLGFBQU8sQ0FBQyxFQUFFLGFBQUYsQ0FBZ0IsRUFBRSxDQUFGLENBQWhCLENBQUQsRUFBd0IsRUFBRSxDQUFGLENBQXhCLENBQVA7QUFBc0MsTUFIN0MsQ0FBZDtBQUlBO0FBQ0EsY0FBUyxFQUFUOztBQVgwQixnQ0FZakIsQ0FaaUI7QUFhekIsZUFBUyxPQUFPLE1BQVAsQ0FDUixRQUFRLENBQVIsRUFBVyxDQUFYLEVBQWMsR0FBZCxDQUFrQixVQUFVLENBQVYsRUFBYTtBQUM5QixjQUFPLEVBQUUsYUFBRixDQUFnQixDQUFoQixJQUFxQixHQUFyQixHQUEyQixRQUFRLENBQVIsRUFBVyxDQUFYLENBQWxDO0FBQ0EsT0FGRCxDQURRLENBQVQ7QUFieUI7O0FBWTFCLFVBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxRQUFRLE1BQTVCLEVBQW9DLEdBQXBDO0FBQUEsWUFBUyxDQUFUO0FBQUE7QUFaMEI7QUFrQjFCOztBQUVELFFBQUssRUFBTCxHQUFVLEVBQUUsbUJBQUYsQ0FBc0IsTUFBdEIsQ0FBNkIsTUFBN0IsQ0FBVjtBQUNBLE9BQUksS0FBSyxFQUFMLENBQVEsTUFBUixLQUFtQixDQUF2QjtBQUNDO0FBQ0EsV0FBTyxLQUFLLEVBQVo7QUFDRCxHQTNCRDs7QUE2QkE7O0FBRUEsTUFBSSxLQUFLLEVBQUwsS0FBWSxTQUFoQixFQUNDLEtBQUssRUFBTCxHQUFVLFlBQVksSUFBWixDQUFpQixLQUFqQixDQUF1QixDQUF2QixFQUEwQixFQUExQixXQUFvQyxnQkFBcEMsT0FBVjtBQUNEOztBQUVBLE9BQUssRUFBTCxHQUFVLHlCQUFWOztBQUdBLE1BQUksUUFBUSxFQUFFLHdCQUFGLEVBQWUsVUFBZixFQUFxQixnQkFBckIsRUFBOEIsd0JBQTlCLEVBQTJDLFFBQTNDLEVBQVo7O0FBRUEsV0FBUyxPQUFULENBQWlCLE1BQWpCLEVBQXlCLE9BQXpCLEVBQWtDLEtBQWxDLEVBQXlDO0FBQ3hDLE9BQUksQ0FBQyxRQUFRLFdBQVQsSUFBd0IsQ0FBQyxLQUE3QixFQUNDOztBQUVELE9BQUksSUFBSyxDQUFDLFFBQVEsV0FBVCxJQUF3QixDQUFDLEtBQTFCLEdBQ1AsRUFETyxHQUVMLFVBQVUsTUFBTSxXQUFOLENBQWtCLENBQTVCLEdBQWdDLElBQWhDLEdBQXVDLGtDQUF2QyxHQUE0RSxJQUFJLEtBQUosQ0FBVSxRQUFWLENBQW1CLENBQW5CLENBQTVFLEdBQW9HLG9DQUFwRyxHQUEySSxJQUFJLEtBQUosQ0FBVSxRQUFWLENBQW1CLENBQW5CO0FBQzdJO0FBREUsTUFFQyxDQUFDLE1BQUQsR0FBVSxFQUFWLEdBQWUsUUFBUSxVQUFVLGNBQVYsR0FBMkIsY0FBbkMsQ0FGaEIsS0FHQyxDQUFDLEtBQUQsR0FBUyxFQUFULEdBQWMscUJBQWtCLEtBQWxCLENBSGYsQ0FGSDs7QUFPQSxRQUFLLGdGQUFMO0FBQ0EsUUFBTSxLQUFLLENBQUwsS0FBVyxTQUFYLEdBQXVCLEVBQXZCLEdBQTRCLE9BQU8sS0FBSyxDQUE5QztBQUNBLFFBQUssQ0FBTCxHQUFTLENBQVQ7QUFDQTtBQUNBOztBQUVELFNBQU8sY0FBYyxLQUFkLENBQVA7QUFDQSxTQUFPLFNBQVMsSUFBaEIsRUFBc0I7O0FBR3JCLE9BQ0MsVUFBVSxLQUFLLENBQUwsS0FBVyxTQUR0QjtBQUFBLE9BRUcsT0FBTyxVQUFVLEtBQUssQ0FBZixHQUFtQixLQUFLLENBRmxDO0FBQUEsT0FHRyxVQUFVLFNBQVMsRUFBVCxJQUFnQixRQUFRLGVBQVIsQ0FBd0IsQ0FBeEIsTUFBK0IsUUFBUSxlQUFSLENBQXdCLENBQXhCLENBQS9CLElBQ3hCLFFBQVEsZUFBUixDQUF3QixDQUF4QixLQUE4QixFQUROLElBRXhCLFNBQVMsSUFGRCxDQUVNO0FBTG5CO0FBQUEsT0FPRyx5QkFBeUIsRUFQNUI7O0FBU0EsT0FBSSxTQUFTLFNBQVQsSUFBc0IsQ0FBQyxPQUEzQixFQUFvQztBQUNuQyxXQUFPLGNBQWMsS0FBZCxDQUFQO0FBQ0E7QUFDQTtBQUNEOztBQUVBLE9BQUksT0FBSixFQUFhO0FBQ1osV0FBTyxLQUFLLFVBQVUsR0FBVixHQUFnQixHQUFyQixDQUFQO0FBQ0EsWUFBUSxPQUFSLEVBQWlCLE9BQWpCO0FBQ0EsU0FBSyxVQUFVLElBQVYsR0FBaUIsSUFBdEIsSUFBOEIsRUFBOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSSxVQUFVLElBQWQsRUFDQyxNQVZXLENBVU47QUFDTixXQUFPLGNBQWMsS0FBZCxDQUFQO0FBQ0EsSUFaRCxNQWFLO0FBQ0osUUFBTSxTQUFTLHFCQUFxQixJQUFyQixDQUFmO0FBQ0EsUUFBSSxhQUFhLElBQWpCO0FBQ0E7QUFDQSxRQUFJO0FBQ0gsa0JBQWEsSUFBSSxJQUFKLENBQVMsVUFBVSxHQUFWLEdBQWdCLEdBQXpCLEVBQThCLE1BQTlCLENBQWI7QUFFQSxLQUhELENBR0UsT0FBTyxLQUFQLEVBQWM7QUFDZixTQUFJLE1BQU0sT0FBTixLQUFrQixvQkFBdEIsQ0FBMkMsd0dBQTNDLEVBQ0MsTUFBTyxLQUFQO0FBQ0Q7QUFDRCxRQUFNLGtCQUFrQixFQUFFLGFBQUYsQ0FBZ0IsTUFBaEIsQ0FBeEI7QUFDQSxRQUFJLFFBQVEsZUFBZSxJQUFmLEdBQXNCLEVBQXRCLEdBQTJCLGdCQUFnQixHQUFoQixDQUFvQixFQUFFLGFBQXRCLENBQXZDO0FBQUEsUUFDRyxXQUFXLGVBQWUsSUFBZixHQUFzQixFQUF0QjtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQ0MsU0FBUyxXQUFXLE9BQXBCLEVBQ0UsR0FERixDQUNNLEVBQUUsYUFEUixDQURELEVBR0UsR0FIRixDQUdNLEVBQUUsYUFIUixDQVJGOztBQWFBO0FBQ0EsUUFBSSxRQUFRLFFBQVIsS0FBcUIsQ0FBekIsRUFBNEI7QUFDM0IsU0FBSSxtQkFBZ0IsVUFBVSxHQUFWLEdBQWdCLEdBQWhDLENBQUo7QUFDQSxVQUFLLFVBQUwsSUFBbUIsTUFBTSxHQUFOLEVBQW5CO0FBQ0EsU0FBSSxNQUFNLE1BQU4sR0FBZSxDQUFuQixFQUFzQjtBQUNyQixXQUFLLE1BQU0sVUFBWCxJQUF5QixLQUF6QjtBQUNBO0FBRUQsS0FQRCxNQU9PO0FBQ04sU0FBSSxvQkFBZ0IsUUFBUSxRQUFSLEdBQW1CLENBQW5CLEdBQXVCLEdBQXZCLEdBQTZCLEVBQTdDLEtBQWtELFVBQVUsR0FBVixHQUFnQixHQUFsRSxDQUFKOztBQUVBLFVBQUssV0FBTCxJQUFtQixLQUFuQjtBQUNBLFNBQUksUUFBUSxZQUFaLEVBQTBCO0FBQ3pCLFdBQUssUUFBUSxZQUFiLElBQTZCLEtBQTdCO0FBQ0E7QUFDRDs7QUFFRCxRQUFJLFFBQVEsUUFBUixLQUFxQixDQUF6QixFQUNDLEtBQUssVUFBVSxHQUFWLEdBQWdCLEdBQXJCLElBQTRCLEVBQTVCOztBQUdELFFBQUksU0FBUyxNQUFULEdBQWtCLENBQXRCLEVBQ0MsS0FBSyxFQUFMLEdBQVU7O0FBRVQ7Ozs7Ozs7QUFGRCxLQS9DRyxDQXdERDtBQUNIO0FBQ0M7QUFDQSxRQUZELEVBRU8sSUFGUCxFQUVhLElBRmIsRUFFbUIsSUFGbkIsRUFFeUIsSUFGekIsRUFFK0IsT0FGL0IsQ0FFdUMsVUFBVSxXQUFWLEVBQXVCO0FBQzVEO0FBQ0EsU0FBSSxLQUFLLFdBQUwsTUFBc0IsU0FBMUIsRUFBcUM7QUFDckMsU0FBSSxTQUFTLEVBQWI7QUFDQSxTQUFJLE1BQU0sT0FBTixDQUFjLEtBQUssV0FBTCxDQUFkLENBQUosRUFBc0M7QUFDckMsZUFBUyxLQUFLLFdBQUwsQ0FBVDtBQUNBLE1BRkQsTUFHSztBQUNKLGVBQVMsQ0FBQyxLQUFLLFdBQUwsQ0FBRCxDQUFUO0FBQ0E7QUFDRCxTQUFJLEtBQUssRUFBTCxJQUFXLGdCQUFnQixJQUEvQixFQUFxQztBQUNwQywrQkFDRSxPQUNFLEdBREYsQ0FDTSxvQkFETixDQURGO0FBR0E7O0FBRUQ7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUNDLE9BQ0UsR0FERixDQUNNLG9CQUROLEVBRUUsR0FGRixDQUVNLEVBQUUsYUFGUixDQURELEVBS0UsR0FMRixDQUtNLEVBQUUsYUFMUixDQVBEO0FBYUEsVUFBSyxXQUFMLElBQW9CLE1BQXBCO0FBQ0EsS0FoQ0Y7QUFpQ0EsUUFBSSxRQUFRLGFBQVosRUFDQyxLQUFLLEVBQUwsR0FBVSxZQUFZLENBQXRCOztBQUVEOzs7Ozs7OztBQVFBLFFBQUksaUJBQWlCLEtBQXJCO0FBQ0EsUUFBSSxLQUFLLEVBQVQsRUFBYTtBQUNaLFNBQUksS0FBSixDQUFVLElBQVYsR0FBaUIsV0FBVyxZQUFZLElBQVosQ0FBaUIsS0FBakIsQ0FBdUIsQ0FBdkIsRUFBMEIsRUFBckMsQ0FBakI7O0FBRUEsU0FBSSxRQUFRLElBQUksS0FBSixDQUFVLEtBQVYsQ0FBZ0Isc0JBQWhCLENBQVo7QUFBQSxTQUNHLGNBQWMsU0FBUyxLQUFLLEVBQWQsQ0FEakI7QUFFQSxTQUFJLENBQUMsY0FBYyxDQUFmLE1BQXNCLENBQTFCLEVBQTZCO0FBQzVCLHVCQUFpQixJQUFqQjtBQUNBLGNBQVEsT0FBUixFQUFpQixPQUFqQixFQUEwQixNQUFNLEVBQWhDO0FBQ0EsTUFIRCxNQUlLO0FBQ0osVUFBSSxDQUFDLGNBQWMsQ0FBZixNQUFzQixDQUExQixFQUE2QjtBQUM1Qix3QkFBaUIsSUFBakI7QUFDQSxlQUFRLE9BQVIsRUFBaUIsT0FBakIsY0FDVyxNQUFNLFVBRGpCLFdBQ2lDLE1BQU0sbUJBRHZDLHNCQUMwRSxNQUFNLGNBQU4sR0FBdUIsTUFBTSxrQkFEdkcsNEJBRUUsTUFBTSxVQUZSLFdBRXdCLE1BQU0sbUJBRjlCLHNCQUVpRSxNQUFNLGNBQU4sR0FBdUIsTUFBTSxrQkFGOUYsc0JBRWdJLElBQUksS0FBSixDQUFVLElBRjFJLHVCQUdHLE1BQU0sRUFIVDtBQUlBO0FBQ0YsU0FBSSxDQUFDLGNBQWMsQ0FBZixNQUFzQixDQUExQixFQUE2QjtBQUM1QixrQkFBWSxJQUFaLENBQWlCLEtBQWpCLENBQXVCLENBQXZCLEVBQTBCLEVBQTFCLEdBQStCLE1BQU0sRUFBckM7QUFDQTtBQUNEO0FBQ0QsUUFBSSxDQUFDLGNBQUwsRUFDQyxRQUFRLE9BQVIsRUFBaUIsT0FBakI7O0FBRUQ7QUFDQSxXQUFPLGNBQWMsS0FBZCxDQUFQO0FBQ0E7QUFDRDtBQUNELE1BQUksUUFBUSxpQkFBWixFQUNDLE9BQU8sVUFBVSxRQUFWLENBQW1CLEVBQUUsV0FBVyxDQUFDLFlBQVksSUFBYixDQUFiLEVBQW5CLENBQVAsQ0FERCxLQUVLLE9BQU8sV0FBUDtBQUNMO0FBQ0QsR0FBRSxTQUFGLEdBQWMsU0FBZDtBQUNBLFFBQU8sQ0FBUDtBQUVBO0FBQ0QsT0FBTyxPQUFQLEdBQWlCLFdBQWpCOzs7Ozs7O0FDNTFCQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUEsSUFBSSxtQkFBbUIsU0FBbkIsZ0JBQW1CLENBQVUsYUFBVixFQUF5QjtBQUMvQyw0QkFBa0IsUUFBUSxXQUExQixFQUF1QyxZQUFZLElBQW5ELEVBQXlELGdCQUFlLElBQXhFLElBQWlGLGFBQWpGOztBQUQrQyxzQkFFbEIsYUFGa0I7QUFBQSxLQUV6QyxNQUZ5QyxrQkFFekMsTUFGeUM7QUFBQSxLQUVqQyxVQUZpQyxrQkFFakMsVUFGaUM7QUFBQSxLQUc1QyxjQUg0QyxHQUczQixRQUFRLGNBQVIsQ0FIMkI7QUFBQSxLQUk1Qyx1QkFKNEMsR0FJbEIsUUFBUSxvQkFBUixDQUprQjtBQUFBLEtBSzNDLG9CQUwyQyxHQUtwQixTQUF2QixvQkFBdUIsQ0FBQyxNQUFEO0FBQUEsU0FBWSxTQUFTLGNBQVQsQ0FBd0IsU0FBUyxHQUFULEdBQWUsTUFBdkMsQ0FBWjtBQUFBLEVBTG9CO0FBQUEsS0FNM0MsTUFOMkMsR0FNbEMsRUFOa0M7O0FBUS9DLEtBQUksT0FBTyxHQUFYLEVBQWdCO0FBQ2hCLFFBQU8sR0FBUCxHQUFhLElBQWIsQ0FUK0MsQ0FTOUI7O0FBRWpCO0FBQ0EsS0FBSSxjQUFjLFNBQVMsZ0JBQVQsT0FDYixNQURhLDJCQUFsQjtBQUVBLEtBQUksWUFBWSxNQUFaLEdBQXFCLENBQXpCLEVBQTRCO0FBQzNCLE1BQUksVUFBVSxLQUFLLEtBQUwsQ0FBVyxZQUFZLENBQVosRUFBZSxTQUExQixDQUFkO0FBQ0EsK0JBQXFCLGFBQXJCLEVBQXdDLE9BQXhDO0FBQ0E7QUFDRCxLQUFJLGNBQWMsY0FBZCxJQUFnQyxTQUFTLFFBQVQsS0FBc0IsRUFBMUQsRUFBOEQ7O0FBRTlELFVBQVMsY0FBVCxDQUF3QixNQUF4QixFQUFnQyxXQUFoQyxDQUE0QyxlQUFlLGFBQWYsQ0FBNUM7O0FBS0Esc0JBQXFCLGNBQXJCLEVBQXFDLGdCQUFyQyxDQUFzRCxPQUF0RCxFQUErRCxnQkFBL0QsRUFFRSxHQUFHLE9BQUgsQ0FBVyxJQUFYLENBQWdCLFNBQVMsZ0JBQVQsT0FBOEIsTUFBOUIsd0NBQWhCLEVBQTJGLFVBQVUsRUFBVixFQUFjO0FBQ3pHLEtBQUcsZ0JBQUgsQ0FBb0IsT0FBcEIsRUFBNkIsVUFBVSxDQUFWLEVBQWE7QUFDekMsT0FBSSxTQUFTLEVBQUUsTUFBRixJQUFZLEVBQUUsVUFBM0I7QUFDQSxhQUFVLEVBQUUsa0JBQWtCLE9BQU8sS0FBM0IsRUFBVjtBQUNBLEdBSEQ7QUFJQSxFQUxBOztBQU9GLEtBQUksVUFBSixFQUFnQjtBQUNmLEtBQUcsT0FBSCxDQUFXLElBQVgsQ0FBZ0IsU0FBUyxnQkFBVCxPQUE4QixNQUE5QiwwQkFBaEIsRUFBNkUsVUFBVSxFQUFWLEVBQWM7QUFDMUYsTUFBRyxLQUFILENBQVMsT0FBVCxHQUFtQixjQUFuQjtBQUNBLEdBRkQ7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQSxNQUFJLFNBQVMscUJBQXFCLFlBQXJCLENBQWI7QUFDQSxPQUFLLElBQUksUUFBUSxDQUFqQixFQUFvQixRQUFRLEVBQTVCLEVBQWdDLE9BQWhDLEVBQXlDO0FBQ3hDLE9BQU0sU0FBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBZjtBQUNBLFVBQU8sS0FBUCxHQUFlLEtBQUssS0FBcEI7QUFDQSxVQUFPLFdBQVAsQ0FBbUIsU0FBUyxjQUFULENBQXdCLEtBQXhCLENBQW5CO0FBQ0EsVUFBTyxXQUFQLENBQW1CLE1BQW5CO0FBQ0E7QUFFRCxFQWxCRCxNQWtCTztBQUNOLEtBQUcsT0FBSCxDQUFXLElBQVgsQ0FBZ0IsU0FBUyxnQkFBVCxPQUE4QixNQUE5QiwwQkFBaEIsRUFBNkUsVUFBVSxFQUFWLEVBQWM7QUFDMUY7QUFDQSxNQUFHLEtBQUgsQ0FBUyxPQUFULEdBQW1CLE1BQW5CO0FBQ0EsR0FIRDtBQUlBOztBQUVELHNCQUFxQixVQUFyQixFQUFpQyxnQkFBakMsQ0FBa0QsT0FBbEQsRUFBMkQsWUFBWTtBQUN0RTtBQUNBLEVBRkQ7QUFHQSxzQkFBcUIsWUFBckIsRUFBbUMsZ0JBQW5DLENBQW9ELE9BQXBELEVBQTZELFlBQVk7QUFDeEU7QUFDQSxFQUZEO0FBR0Esc0JBQXFCLFdBQXJCLEVBQWtDLGdCQUFsQyxDQUFtRCxPQUFuRCxFQUE0RCxZQUFZO0FBQ3ZFLHVCQUFxQixPQUFyQixFQUE4QixLQUE5QixrREFBbUYscUJBQXFCLFlBQXJCLEVBQW1DLEtBQXRIO0FBQ0E7QUFDQSxFQUhEOztBQUtBLHNCQUFxQixnQkFBckIsRUFBdUMsS0FBdkMsQ0FBNkMsT0FBN0MsR0FBdUQsTUFBdkQ7O0FBRUE7QUFDQSxLQUFJLGVBQWUsU0FBUyxnQkFBVDtBQUNsQjtBQURrQixPQUVkLE1BRmMsd0JBQW5CO0FBR0EsS0FBSSxhQUFhLE1BQWIsR0FBc0IsQ0FBMUIsRUFBNkI7QUFDNUIsdUJBQXFCLE9BQXJCLEVBQThCLEtBQTlCLEdBQXNDLGFBQWEsQ0FBYixFQUFnQixTQUF0RDs7QUFFQTtBQUNBLEVBSkQsTUFLSztBQUNKLE1BQUksU0FBUyxJQUFJLGVBQUosQ0FBcUIsSUFBSSxHQUFKLENBQVEsT0FBTyxRQUFmLENBQUQsQ0FBMkIsTUFBM0IsQ0FBa0MsS0FBbEMsQ0FBd0MsQ0FBeEMsQ0FBcEIsQ0FBYjtBQUNBLE1BQUksT0FBTyxHQUFQLENBQVcsS0FBWCxDQUFKLEVBQXVCO0FBQ3RCLE9BQUksTUFBTSxPQUFPLEdBQVAsQ0FBVyxLQUFYLENBQVY7QUFDQSxPQUFJLGFBQWEsR0FBYixDQUFKLEVBQXVCO0FBQ3RCLHlCQUFxQixPQUFyQixFQUE4QixLQUE5QixHQUFzQyxHQUF0QztBQUNBO0FBQ0E7QUFDRCxHQU5ELE1BTU8sSUFBSSxPQUFPLEdBQVAsQ0FBVyxlQUFYLENBQUosRUFBaUM7QUFDdkMsT0FBSSxLQUFLLE9BQU8sR0FBUCxDQUFXLGVBQVgsQ0FBVDtBQUNBLE9BQUksU0FBUyxJQUFULENBQWMsRUFBZCxDQUFKLEVBQXVCO0FBQ3RCLHlCQUFxQixlQUFyQixFQUFzQyxLQUF0QyxHQUE4QyxFQUE5QztBQUNBO0FBQ0E7QUFDRDtBQUNEOztBQUdELFVBQVMsU0FBVCxDQUFtQixPQUFuQixFQUE0QjtBQUMzQixNQUFJLFlBQVksU0FBaEIsRUFBMkIsVUFBVSxFQUFWO0FBREEsaUJBRTRCLE9BRjVCO0FBQUEsTUFFckIsSUFGcUIsWUFFckIsSUFGcUI7QUFBQSxNQUVmLGdCQUZlLFlBRWYsZ0JBRmU7QUFBQSxNQUVHLGFBRkgsWUFFRyxhQUZIO0FBQUEsTUFFa0IsS0FGbEIsWUFFa0IsS0FGbEI7O0FBRzNCLE1BQUksU0FBUyxDQUFDLE9BQU8sTUFBckIsRUFBNkIsT0FBTyxNQUFQLEdBQWdCLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBaEI7QUFDN0IsTUFBSSxnQkFBSixFQUFzQjtBQUNyQixPQUFJLFFBQVEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFaO0FBQUEsT0FBOEIsS0FBSyxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQW5DO0FBQ0EsV0FBUSxnQkFBUjs7QUFFQyxTQUFLLEdBQUw7QUFDQztBQUNDO0FBQ0E7QUFDQTs7QUFFRixTQUFLLEdBQUw7QUFDQztBQUNDO0FBQ0E7QUFDQTtBQUNGLFNBQUssR0FBTDtBQUNDO0FBQ0M7QUFDQTtBQUNBOztBQUVGLFNBQUssR0FBTDtBQUNDO0FBQ0M7QUFDQTtBQUNBO0FBdkJIO0FBeUJBLFVBQU8sTUFBUCxHQUFnQixDQUFDLEtBQUQsRUFBUSxFQUFSLENBQWhCO0FBQ0E7O0FBRUQsTUFBSSxTQUFTLFNBQVQsSUFBc0IsU0FBUyxJQUFuQyxFQUF5QztBQUN4QyxVQUFPLHFCQUFxQixPQUFyQixFQUE4QixLQUFyQztBQUNBO0FBQ0QsTUFBSSxTQUFTLEVBQWIsRUFBaUI7QUFDaEIsT0FBSSxDQUFDLE9BQU8sY0FBWixFQUE0QjtBQUMzQixVQUFNLHlEQUFOO0FBQ0EsV0FBTyxjQUFQLEdBQXdCLElBQXhCO0FBQ0E7QUFDRCxVQUFPLG1hQUFQLENBTGdCLENBSzBaO0FBQzFhLHdCQUFxQixPQUFyQixFQUE4QixLQUE5QixHQUFzQyxJQUF0QztBQUNBO0FBQ0QsTUFBSSxhQUFhLE9BQU8scUJBQXFCLGtCQUFyQixFQUF5QyxLQUFoRCxDQUFqQjtBQUFBLE1BQ0csd0JBQXdCLE9BQU8scUJBQXFCLHdCQUFyQixFQUErQyxLQUF0RCxDQUQzQjtBQUFBLE1BRUcsa0JBQWtCLE9BQU8scUJBQXFCLGtCQUFyQixFQUF5QyxLQUFoRCxDQUZyQjtBQUFBLE1BR0csY0FBYyxxQkFBcUIsYUFBckIsRUFBb0MsT0FIckQ7QUFBQSxNQUlHLE1BQU0sRUFKVDtBQUtBLE1BQUk7QUFDSCxPQUFJLGNBQWMsd0JBQXdCO0FBQ3pDLDRCQUR5QztBQUV6QyxnREFGeUM7QUFHekMsb0NBSHlDO0FBSXpDLHdCQUFvQjtBQUNuQixhQUFRLE9BQU8sTUFESTtBQUVuQjtBQUZtQjtBQUpxQixJQUF4QixDQUFsQjtBQVNBLFNBQU0sWUFBWSxTQUFaLENBQXNCLElBQXRCLENBQU47QUFDQSx3QkFBcUIsUUFBckIsRUFBK0IsS0FBL0IsR0FBdUMsR0FBdkM7QUFDQSxVQUFPLFdBQVAsR0FBcUIsV0FBckI7QUFDQSxHQWJELENBY0EsT0FBTyxDQUFQLEVBQVU7QUFDVCxTQUFNLG9CQUFOO0FBQ0E7QUFDQTs7QUFFRCxTQUFPLEdBQVAsR0FBYSxHQUFiO0FBQ0EsTUFBSSxDQUFDLGdCQUFMLEVBQXVCOztBQUV0QixPQUFJLFlBQVksV0FBVyxlQUFYLEVBQWhCO0FBQ0EsVUFBTyxTQUFQLEdBQW1CLFNBQW5COztBQUVBLGNBQVcsOEJBQVgsQ0FBMEMsU0FBMUMsRUFBcUQsWUFBTSxDQUFHLENBQTlEO0FBQ0EsY0FBVyxhQUFYLENBQXlCLFNBQXpCO0FBQ0EsY0FBVyxxQkFBWCxDQUFpQyxTQUFqQyxFQUE0QyxLQUE1QztBQUNBLGNBQVcsaUJBQVgsQ0FBNkIsU0FBN0IsRUFBd0MsS0FBeEM7O0FBRUEsY0FBVyxvQ0FBWCxDQUFnRCxTQUFoRCxFQUEyRCxTQUFTLEdBQVQsR0FBZSxXQUExRTtBQUNBO0FBQ0EsT0FBSSxrQkFBa0IsU0FBdEIsRUFDQyxXQUFXLFFBQVgsQ0FBb0IsT0FBTyxTQUEzQixFQUFzQyxHQUF0QyxFQUEyQyxTQUEzQyxFQUFzRCxhQUF0RCxFQURELEtBR0MsV0FBVyxRQUFYLENBQW9CLFNBQXBCLEVBQStCLEdBQS9COztBQUVELGNBQVcsOEJBQVgsQ0FBMEMsU0FBMUMsRUFBcUQsd0JBQXJEOztBQUVBLFVBQU8sUUFBUCxHQUFrQixZQUFZO0FBQzdCLGVBQVcsV0FBWCxDQUF1QixTQUF2QjtBQUNBLElBRkQ7O0FBS0Esd0JBQXFCLGdCQUFyQixFQUF1QyxLQUF2QyxDQUE2QyxPQUE3QyxHQUF1RCxjQUF2RDtBQUNBLHdCQUFxQixpQkFBckIsRUFBd0MsS0FBeEMsQ0FBOEMsT0FBOUMsR0FBd0QsY0FBeEQ7O0FBRUEsT0FBSSxVQUFKLEVBQWdCO0FBQ2YseUJBQXFCLGtCQUFyQixFQUF5QyxLQUF6QyxDQUErQyxPQUEvQyxHQUF5RCxjQUF6RDtBQUNBO0FBQ0QsR0E5QkQsTUErQks7QUFDSixjQUFXLDhCQUFYLENBQTBDLE9BQU8sU0FBakQsRUFBNEQsWUFBTSxDQUFHLENBQXJFO0FBQ0EsbUJBQWdCLFdBQVcsaUJBQVgsQ0FBNkIsT0FBTyxTQUFwQyxFQUErQyxLQUEvQyxDQUFoQjtBQUNBLGNBQVcsUUFBWCxDQUFvQixPQUFPLFNBQTNCLEVBQXNDLEdBQXRDLEVBQTJDLFNBQTNDLEVBQXNELGFBQXREO0FBQ0EsY0FBVyw4QkFBWCxDQUEwQyxPQUFPLFNBQWpELEVBQTRELHdCQUE1RDtBQUNBLHdCQUFxQixVQUFyQixFQUFpQyxTQUFqQyxHQUE2QyxjQUMxQyxPQUFPLFdBQVAsQ0FBbUIsSUFBbkIsQ0FBd0IsT0FBTyxXQUFQLENBQW1CLE9BQW5CLENBQTJCLGtCQUEzQixDQUE4QyxNQUE5QyxDQUFxRCxDQUFyRCxDQUF4QixDQUQwQyxHQUUxQyxJQUYwQyxHQUVuQyxPQUFPLFdBQVAsQ0FBbUIsSUFBbkIsQ0FBd0IsQ0FBQyxPQUFPLFdBQVAsQ0FBbUIsT0FBbkIsQ0FBMkIsa0JBQTNCLENBQThDLE1BQTlDLENBQXFELENBQXJELENBQXpCLENBRm1DLEdBRWlELEdBRjlGO0FBR0E7QUFFRDs7QUFFRCxVQUFTLHdCQUFULEdBQW9DO0FBQ25DO0FBQ0EsTUFBSSxDQUFDLE9BQU8sa0JBQVosRUFBZ0M7QUFDL0IsVUFBTyxrQkFBUCxHQUE0QixLQUFLLEdBQUwsRUFBNUI7QUFDQTtBQUNBO0FBQ0QsTUFBSSxLQUFLLEdBQUwsS0FBYSxPQUFPLGtCQUFwQixHQUF5QyxHQUE3QyxFQUFrRDtBQUNqRDtBQUNBLEdBRkQsTUFHSyxPQUFPLGtCQUFQLEdBQTRCLEtBQUssR0FBTCxFQUE1QjtBQUNMOztBQUVELFVBQVMsWUFBVCxDQUFzQixHQUF0QixFQUEyQixJQUEzQixFQUFpQztBQUNoQyxNQUFJLFNBQVMsSUFBSSxVQUFKLENBQWUsR0FBZixDQUFiO0FBQ0E7O0FBRUEsTUFBSSxJQUFKLEVBQVU7QUFDVCxVQUFPLFVBQVUsSUFBSSxPQUFKLENBQVksUUFBTSxJQUFOLFNBQWdCLENBQTVCLENBQWpCO0FBQ0E7QUFDRCxTQUFPLFVBQVUsV0FBVyxJQUFYLENBQWdCLEdBQWhCLENBQWpCO0FBQ0E7QUFDRCxVQUFTLGdCQUFULEdBQTRCO0FBQzNCLE1BQUksTUFBTSxXQUFXLFFBQVgsQ0FBb0IsT0FBTyxTQUEzQixDQUFWO0FBQ0EsTUFBSSxPQUFPLE9BQU8sR0FBbEIsRUFBdUI7QUFDdEI7QUFDQTtBQUNELFNBQU8sR0FBUCxHQUFhLEdBQWI7QUFDQSxNQUFJLGdCQUFnQixXQUFXLGlCQUFYLENBQTZCLE9BQU8sU0FBcEMsRUFBK0MsS0FBL0MsQ0FBcEI7QUFDQTtBQUNBO0FBQ0EsTUFBSSxPQUFPLE9BQU8sV0FBUCxDQUFtQixnQkFBbkIsQ0FBb0MsR0FBcEMsQ0FBWDtBQUNBLHVCQUFxQixPQUFyQixFQUE4QixLQUE5QixHQUFzQyxJQUF0QztBQUNBLFlBQVUsRUFBRSxVQUFGLEVBQVEsNEJBQVIsRUFBVjtBQUNBOztBQUVELFVBQVMsNkJBQVQsR0FBeUM7QUFDeEMsTUFBSSxTQUFTLHFCQUFxQixlQUFyQixFQUFzQyxLQUFuRDtBQUNBLE1BQUksV0FBVyxFQUFmLEVBQW1CO0FBQ2xCO0FBQ0EsU0FBTSx5REFBTjtBQUNBO0FBQ0E7QUFDRCxXQUFTLE9BQU8sSUFBUCxFQUFUOztBQUVBLE1BQUksV0FBVyxzQ0FBZjtBQUNBLE1BQUksOENBQTRDLE1BQTVDLGFBQTBELE1BQTFELFNBQUo7QUFDQSxNQUFJLENBQUMsU0FBUyxJQUFULENBQWMsTUFBZCxDQUFMLEVBQTRCO0FBQzNCLFNBQU0sWUFBTjtBQUNBO0FBQ0E7QUFDRCx1QkFBcUIsU0FBckIsRUFBZ0MsU0FBaEMsR0FBNEMsVUFBNUM7QUFDQSxNQUFJLFlBQVksSUFBSSxPQUFKLENBQVk7QUFDM0IsbUJBQWdCO0FBRFcsR0FBWixDQUFoQjtBQUdBLE1BQU0sVUFBVSwrQkFBaEI7QUFDQSxRQUFNLFdBQVcsR0FBakIsRUFBc0IsRUFBRSxTQUFTLFNBQVgsRUFBdEIsRUFBOEMsSUFBOUMsQ0FDQyxVQUFVLFFBQVYsRUFBb0I7QUFDbkIsT0FBSSxTQUFTLE1BQVQsS0FBb0IsR0FBeEIsRUFBNkI7QUFDNUIsWUFBUSxHQUFSLENBQVksa0RBQWtELFNBQVMsTUFBdkU7O0FBRUEseUJBQXFCLFNBQXJCLEVBQWdDLFNBQWhDLEdBQTRDLE9BQTVDO0FBQ0E7QUFDQTs7QUFFRDtBQUNBLFlBQVMsSUFBVCxHQUFnQixJQUFoQixDQUFxQixVQUFVLEdBQVYsRUFBZTtBQUNuQyxRQUFJLENBQUMsYUFBYSxHQUFiLEVBQWtCLEVBQWxCLENBQXFCLHNCQUFyQixDQUFMLEVBQW1EO0FBQ2xELGFBQVEsR0FBUixDQUFZLDJCQUEyQixHQUF2Qzs7QUFFQSwwQkFBcUIsU0FBckIsRUFBZ0MsU0FBaEMsR0FBNEMsT0FBNUM7QUFDQTtBQUNBO0FBQ0QsVUFBTSxJQUFJLE9BQUosQ0FBWSxRQUFaLDZEQUErRSxNQUEvRSxDQUFOOztBQUVBLHlCQUFxQixPQUFyQixFQUE4QixLQUE5QixHQUFzQyxHQUF0QztBQUNBOztBQUVBLHlCQUFxQixTQUFyQixFQUFnQyxTQUFoQyxHQUE0QywrQkFBNUM7QUFDQSxJQWJEO0FBY0EsR0F4QkYsRUF5QkUsS0F6QkYsQ0F5QlEsVUFBVSxHQUFWLEVBQWU7QUFDdEIsV0FBUSxHQUFSLENBQVksaUJBQVosRUFBK0IsR0FBL0I7QUFDQSxHQTNCRDtBQTRCQTtBQUtELENBNVNEO0FBNlNBLFNBQVMsZ0JBQVQsR0FBNEIsZ0JBQTVCO0FBQ0EsU0FBUyxnQkFBVCxDQUEwQixrQkFBMUIsRUFBOEMsWUFBWTtBQUN6RCxJQUFHLE9BQUgsQ0FBVyxJQUFYLENBQWdCLFNBQVMsZ0JBQVQsQ0FBMEIscUJBQTFCLENBQWhCLEVBQWtFLFVBQVUsRUFBVixFQUFjO0FBQy9FLE1BQUksVUFBVSxFQUFFLFFBQVEsR0FBRyxFQUFiLEVBQWQ7QUFDQSxNQUFJLEdBQUcsU0FBSCxDQUFhLFFBQWIsQ0FBc0IseUJBQXRCLENBQUosRUFBc0Q7QUFDckQsV0FBUSxVQUFSLEdBQXFCLEtBQXJCO0FBQ0E7QUFDRCxXQUFTLGdCQUFULENBQTBCLE9BQTFCO0FBQ0EsRUFORDtBQU9BLENBUkQ7Ozs7O0FDdlRBLE9BQU8sT0FBUCxHQUFpQixVQUFDLE9BQUQsRUFBYTtBQUMxQixRQUFJLFNBQVMsUUFBUSxNQUFyQjtBQUNBLFdBQ0E7QUFBQTtBQUFBO0FBRUk7QUFBQTtBQUFBLGNBQU8sTUFBSyxVQUFaO0FBQUEsa0JBQ1MsTUFEVDtBQUFBLFNBRko7QUF3Qkk7QUFBQTtBQUFBLGNBQUssU0FBTSxTQUFYO0FBQ0k7QUFBQTtBQUFBLGtCQUFLLFNBQU0seUJBQVg7QUFBQTtBQUVBLCtDQUZBO0FBRU07QUFBQTtBQUFBLHNCQUFPLE9BQVEsTUFBUixXQUFQO0FBQUE7QUFBQSxpQkFGTjtBQUdJLGtEQUFVLElBQU8sTUFBUCxXQUFWLEVBQWlDLE1BQUssR0FBdEMsR0FISjtBQUlJLCtDQUFPLE1BQUssUUFBWixFQUFxQixJQUFPLE1BQVAsY0FBckIsRUFBK0MsT0FBTSw0QkFBckQ7QUFKSixhQURKO0FBU0k7QUFBQTtBQUFBLGtCQUFLLFNBQU0seUJBQVg7QUFDSTtBQUFBO0FBQUEsc0JBQU8sT0FBUSxNQUFSLG1CQUFQO0FBQUE7QUFBQSxpQkFESjtBQUVJLCtDQUFPLElBQU8sTUFBUCxtQkFBUCxFQUFzQyxNQUFLLE1BQTNDLEdBRko7QUFHSSwrQ0FBTyxNQUFLLFFBQVosRUFBcUIsSUFBTyxNQUFQLGdCQUFyQixFQUFpRCxPQUFNLHVDQUF2RCxHQUhKO0FBR3FHLDhDQUFNLElBQU8sTUFBUCxhQUFOO0FBSHJHLGFBVEo7QUFlSTtBQUFBO0FBQUEsa0JBQUssU0FBTSx5QkFBWDtBQUNJO0FBQUE7QUFBQSxzQkFBTyxPQUFRLE1BQVIsZ0JBQVA7QUFBQTtBQUFBLGlCQURKO0FBRUksZ0RBQVEsSUFBTyxNQUFQLGdCQUFSLEdBRko7QUFLSSwrQ0FBTyxNQUFLLFFBQVosRUFBcUIsSUFBTyxNQUFQLGVBQXJCLEVBQWdELE9BQU0sVUFBdEQ7QUFMSixhQWZKO0FBc0JJO0FBQUE7QUFBQSxrQkFBSyxPQUFNLGVBQVgsRUFBMkIsSUFBTyxNQUFQLHNCQUEzQixFQUE2RCxTQUFNLHlCQUFuRTtBQUNJO0FBQUE7QUFBQSxzQkFBTyxPQUFRLE1BQVIsWUFBUDtBQUFBO0FBQUEsaUJBREo7QUFFSSxrREFBVSxJQUFPLE1BQVAsWUFBVixFQUFrQyxNQUFLLEdBQXZDO0FBRkosYUF0Qko7QUEwQkk7QUFBQTtBQUFBLGtCQUFLLElBQU8sTUFBUCxvQkFBTCxFQUFxQyxPQUFNLGNBQTNDLEVBQTBELFNBQU0sTUFBaEU7QUFFSTtBQUFBO0FBQUEsc0JBQU8sT0FBTSxTQUFiLEVBQXVCLE9BQU0sWUFBN0I7QUFDSTtBQUFBO0FBQUE7QUFDSTtBQUFBO0FBQUEsOEJBQUksU0FBUSxHQUFaLEVBQWdCLE9BQU0sb0JBQXRCO0FBQ0ksMkRBQU8sTUFBSyxRQUFaLEVBQXFCLE9BQU0sUUFBM0I7QUFESix5QkFESjtBQUlJO0FBQUE7QUFBQSw4QkFBSSxTQUFRLEdBQVosRUFBZ0IsT0FBTSx3QkFBdEI7QUFBQTtBQUNSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEUTtBQUpKLHFCQURKO0FBU0k7QUFBQTtBQUFBO0FBQ0k7QUFBQTtBQUFBO0FBQ0ksMkRBQU8sTUFBSyxRQUFaLEVBQXFCLE9BQU0sUUFBM0I7QUFESix5QkFESjtBQUlJO0FBQUE7QUFBQTtBQUNJLDJEQUFPLE1BQUssUUFBWixFQUFxQixPQUFNLFFBQTNCO0FBREo7QUFKSixxQkFUSjtBQWlCSTtBQUFBO0FBQUE7QUFDSTtBQUFBO0FBQUEsOEJBQUksU0FBUSxHQUFaLEVBQWdCLE9BQU0sb0JBQXRCO0FBQ0ksMkRBQU8sTUFBSyxRQUFaLEVBQXFCLE9BQU0sUUFBM0I7QUFESjtBQURKLHFCQWpCSjtBQXNCSTtBQUFBO0FBQUE7QUFDSTtBQUFBO0FBQUEsOEJBQUksU0FBUSxHQUFaLEVBQWdCLE9BQU0sc0NBQXRCLEVBQTZELElBQU8sTUFBUCxjQUE3RDtBQUFBO0FBQUE7QUFESjtBQXRCSjtBQUZKLGFBMUJKO0FBeURJO0FBQUE7QUFBQSxrQkFBSyxTQUFNLE1BQVg7QUFDSTtBQUFBO0FBQUEsc0JBQU8sT0FBUSxNQUFSLHNCQUFQO0FBQUE7QUFBQSxpQkFESjtBQUVJO0FBQUE7QUFBQSxzQkFBUSxJQUFPLE1BQVAsc0JBQVI7QUFDSTtBQUFBO0FBQUEsMEJBQVEsT0FBTSxHQUFkO0FBQUE7QUFBQSxxQkFESjtBQUVJO0FBQUE7QUFBQSwwQkFBUSxPQUFNLEdBQWQ7QUFBQTtBQUFBLHFCQUZKO0FBR0k7QUFBQTtBQUFBLDBCQUFRLE9BQU0sR0FBZDtBQUFBO0FBQUEscUJBSEo7QUFJSTtBQUFBO0FBQUEsMEJBQVEsT0FBTSxHQUFkO0FBQUE7QUFBQSxxQkFKSjtBQUtJO0FBQUE7QUFBQSwwQkFBUSxPQUFNLEdBQWQsRUFBa0IsY0FBbEI7QUFBQTtBQUFBLHFCQUxKO0FBTUk7QUFBQTtBQUFBLDBCQUFRLE9BQU0sR0FBZDtBQUFBO0FBQUEscUJBTko7QUFPSTtBQUFBO0FBQUEsMEJBQVEsT0FBTSxHQUFkO0FBQUE7QUFBQSxxQkFQSjtBQVFJO0FBQUE7QUFBQSwwQkFBUSxPQUFNLEdBQWQ7QUFBQTtBQUFBO0FBUkosaUJBRko7QUFhSSwrQ0FiSjtBQWNJO0FBQUE7QUFBQSxzQkFBTyxPQUFJLGFBQVg7QUFBQTtBQUFBLGlCQWRKO0FBZUksK0NBQU8sTUFBSyxVQUFaLEVBQXVCLElBQU8sTUFBUCxpQkFBdkIsR0FmSjtBQWdCSSwrQ0FoQko7QUFpQkk7QUFBQTtBQUFBLHNCQUFPLE9BQVEsTUFBUiw0QkFBUDtBQUFBO0FBQUEsaUJBakJKO0FBa0JJO0FBQUE7QUFBQSxzQkFBUSxJQUFPLE1BQVAsNEJBQVI7QUFDSTtBQUFBO0FBQUEsMEJBQVEsT0FBTSxHQUFkO0FBQUE7QUFBQSxxQkFESjtBQUVJO0FBQUE7QUFBQSwwQkFBUSxPQUFNLEdBQWQsRUFBa0IsY0FBbEI7QUFBQTtBQUFBLHFCQUZKO0FBR0k7QUFBQTtBQUFBLDBCQUFRLE9BQU0sR0FBZDtBQUFBO0FBQUEscUJBSEo7QUFJSTtBQUFBO0FBQUEsMEJBQVEsT0FBTSxHQUFkO0FBQUE7QUFBQSxxQkFKSjtBQUtJO0FBQUE7QUFBQSwwQkFBUSxPQUFNLEdBQWQ7QUFBQTtBQUFBO0FBTEosaUJBbEJKO0FBeUJJLCtDQXpCSjtBQTBCSTtBQUFBO0FBQUEsc0JBQU8sT0FBUSxNQUFSLHNCQUFQO0FBQUE7QUFBQSxpQkExQko7QUEyQkk7QUFBQTtBQUFBLHNCQUFRLElBQU8sTUFBUCxzQkFBUjtBQUNJO0FBQUE7QUFBQSwwQkFBUSxPQUFNLEdBQWQsRUFBa0IsY0FBbEI7QUFBQTtBQUFBLHFCQURKO0FBRUk7QUFBQTtBQUFBLDBCQUFRLE9BQU0sR0FBZDtBQUFBO0FBQUEscUJBRko7QUFHSTtBQUFBO0FBQUEsMEJBQVEsT0FBTSxHQUFkO0FBQUE7QUFBQSxxQkFISjtBQUlJO0FBQUE7QUFBQSwwQkFBUSxPQUFNLEdBQWQ7QUFBQTtBQUFBLHFCQUpKO0FBS0k7QUFBQTtBQUFBLDBCQUFRLE9BQU0sR0FBZDtBQUFBO0FBQUE7QUFMSixpQkEzQko7QUFrQ0ksK0NBbENKO0FBbUNJO0FBQUE7QUFBQSxzQkFBSyxJQUFPLE1BQVAscUJBQUwsRUFBc0MsT0FBTSxjQUE1QztBQUNJLG1EQUFPLE1BQUssUUFBWixFQUFxQixJQUFPLE1BQVAsa0JBQXJCLEVBQW1ELE9BQU0scUJBQXpELEdBREo7QUFBQTtBQUFBO0FBbkNKO0FBekRKLFNBeEJKO0FBMEhJLHFDQUFLLElBQU8sTUFBUCxlQUFMLEVBQWdDLE9BQU0sNkNBQXRDO0FBMUhKLEtBREE7QUE2SEgsQ0EvSEQiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcbiIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuIiwidmFyIGxpc3RDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlQ2xlYXInKSxcbiAgICBsaXN0Q2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVEZWxldGUnKSxcbiAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVHZXQnKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVIYXMnKSxcbiAgICBsaXN0Q2FjaGVTZXQgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3RDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG4iLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRDYWNoZTtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gcGFpciBUaGUga2V5LXZhbHVlIHBhaXIgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAqL1xuZnVuY3Rpb24gYWRkTWFwRW50cnkobWFwLCBwYWlyKSB7XG4gIC8vIERvbid0IHJldHVybiBgbWFwLnNldGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gIHJldHVybiBtYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkTWFwRW50cnk7XG4iLCIvKipcbiAqIEFkZHMgYHZhbHVlYCB0byBgc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYHNldGAuXG4gKi9cbmZ1bmN0aW9uIGFkZFNldEVudHJ5KHNldCwgdmFsdWUpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBzZXQuYWRkYCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIHJldHVybiBzZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkU2V0RW50cnk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlSZWR1Y2U7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcbiIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25JbjtcbiIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ24nKSxcbiAgICBiYXNlQXNzaWduSW4gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduSW4nKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgY29weVN5bWJvbHMgPSByZXF1aXJlKCcuL19jb3B5U3ltYm9scycpLFxuICAgIGNvcHlTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19jb3B5U3ltYm9sc0luJyksXG4gICAgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKSxcbiAgICBnZXRBbGxLZXlzSW4gPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzSW4nKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpbml0Q2xvbmVBcnJheSA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUFycmF5JyksXG4gICAgaW5pdENsb25lQnlUYWcgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVCeVRhZycpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgYmFzZUNsb25lLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmluZEluZGV4O1xuIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0QWxsS2V5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIGVxdWFsQnlUYWcgPSByZXF1aXJlKCcuL19lcXVhbEJ5VGFnJyksXG4gICAgZXF1YWxPYmplY3RzID0gcmVxdWlyZSgnLi9fZXF1YWxPYmplY3RzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmFyeTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG4iLCJ2YXIgYWRkTWFwRW50cnkgPSByZXF1aXJlKCcuL19hZGRNYXBFbnRyeScpLFxuICAgIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgbWFwLlxuICovXG5mdW5jdGlvbiBjbG9uZU1hcChtYXAsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhtYXBUb0FycmF5KG1hcCksIENMT05FX0RFRVBfRkxBRykgOiBtYXBUb0FycmF5KG1hcCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkTWFwRW50cnksIG5ldyBtYXAuY29uc3RydWN0b3IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lTWFwO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVJlZ0V4cDtcbiIsInZhciBhZGRTZXRFbnRyeSA9IHJlcXVpcmUoJy4vX2FkZFNldEVudHJ5JyksXG4gICAgYXJyYXlSZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheVJlZHVjZScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU2V0KHNldCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKHNldFRvQXJyYXkoc2V0KSwgQ0xPTkVfREVFUF9GTEFHKSA6IHNldFRvQXJyYXkoc2V0KTtcbiAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRTZXRFbnRyeSwgbmV3IHNldC5jb25zdHJ1Y3Rvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTZXQ7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0eTtcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlTb21lID0gcmVxdWlyZSgnLi9fYXJyYXlTb21lJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQXJyYXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuIiwidmFyIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsT2JqZWN0cztcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lTWFwID0gcmVxdWlyZSgnLi9fY2xvbmVNYXAnKSxcbiAgICBjbG9uZVJlZ0V4cCA9IHJlcXVpcmUoJy4vX2Nsb25lUmVnRXhwJyksXG4gICAgY2xvbmVTZXQgPSByZXF1aXJlKCcuL19jbG9uZVNldCcpLFxuICAgIGNsb25lU3ltYm9sID0gcmVxdWlyZSgnLi9fY2xvbmVTeW1ib2wnKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBjbG9uZUZ1bmMsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lTWFwKG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVNldChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVCeVRhZztcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmljdENvbXBhcmFibGU7XG4iLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlR2V0O1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG4iLCJ2YXIgSGFzaCA9IHJlcXVpcmUoJy4vX0hhc2gnKSxcbiAgICBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlO1xuIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tEZWxldGU7XG4iLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrSGFzO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tTZXQ7XG4iLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlTGVhZGluZ0RvdCA9IC9eXFwuLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAocmVMZWFkaW5nRG90LnRlc3Qoc3RyaW5nKSkge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9LZXk7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG4iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi9fYmFzZUNsb25lJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZURlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEluZGV4O1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG4iLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcbiIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRmluaXRlO1xuIiwidmFyIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSW50ZWdlcjtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCIvKiBnbG9iYWxzIG1vZHVsZTogZmFsc2UsIHJlcXVpcmU6IGZhbHNlICovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHQndXNlIHN0cmljdCc7XHJcblx0bGV0IF9maSA9IHJlcXVpcmUoJ2xvZGFzaC9maW5kSW5kZXgnKVxyXG5cdFx0Ly8gLCBfaXNlcSA9IHJlcXVpcmUoJ2xvZGFzaC9pc0VxdWFsJylcclxuXHRcdCwgX2Nsb25lID0gcmVxdWlyZSgnbG9kYXNoL2Nsb25lJylcclxuXHRcdC8vdXRpbGl0aWVzXHJcblx0XHQvLyBjb25zdFxyXG5cclxuXHRcdCwgX2lzZXEgPSAoeCwgeSkgPT4ge1xyXG5cclxuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KHgpIHx8ICFBcnJheS5pc0FycmF5KHkpKSB7XHJcblx0XHRcdFx0cmV0dXJuIHggPT0geS8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXHJcblx0XHRcdFx0Ly8gcmV0dXJuIHggPT09IHlcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSByZXR1cm4gZmFsc2VcclxuXHRcdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHgubGVuZ3RoOyBpbmRleCsrKSB7XHJcblx0XHRcdFx0aWYgKCFfaXNlcSh4W2luZGV4XSwgeVtpbmRleF0pKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2VcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWVcclxuXHJcblx0XHR9XHJcblx0XHQsIG15SW5kZXhPZiA9IChhLCBiKSA9PiB7XHJcblx0XHRcdHJldHVybiBfZmkoYSwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIF9pc2VxKHgsIGIpIH0pO1xyXG5cdFx0fVxyXG5cdC8vIHRoaXMgdmVyc2lvbiwgd2l0aG91dCB0aGUgX2ZpIGRlcGVuZGVuY3ksIGRvZXNuJ3Qgd29yayF0b2RvXHJcblx0Ly8gICwgbXlJbmRleE9mID0gKGFycmF5LCBpdGVtKSA9PiB7XHJcblx0Ly8gXHRcdGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhcnJheS5sZW5ndGg7IGluZGV4KyspIHtcclxuXHQvLyBcdFx0XHRpZiAoX2lzZXEoYXJyYXlbaW5kZXhdLCBpdGVtKSkge1xyXG5cdC8vIFx0XHRcdFx0cmV0dXJuIGluZGV4O1xyXG5cclxuXHQvLyBcdFx0XHR9XHJcblx0Ly8gXHRcdFx0cmV0dXJuIC0xO1xyXG5cdC8vIFx0XHR9XHJcblxyXG5cdC8vIFx0fVxyXG5cclxuXHQvLyBcdCwgX2Nsb25lID0gcmVxdWlyZSgnbG9kYXNoL2Nsb25lJylcclxuXHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XHJcblx0Ly8gYm9hcmRNb2RlID0gb3B0aW9ucy5ib2FyZE1vZGUgfHwgJ3QnLyp0OnRvcm9pZDsgYzpjbGFzc2ljIOKApiovXHJcblx0Ly8gLCBib2FyZERpbWVuc2lvbnMgPSBvcHRpb25zLmJvYXJkRGltZW5zaW9ucyB8fCBbMTEsIDExXS8qbW92ZSBsYXRlciovXHJcblx0Ly8gLCBydWxlcyA9IG9wdGlvbnMucnVsZXMgfHwge1xyXG5cdC8vIHN1aWNpZGU6IHRydWUsXHJcblx0Ly8gc3VwZXJrbzogZmFsc2VcclxuXHQvLyB9XHJcblx0bGV0ICQgPSB7fVxyXG5cdC8vLy9wcm9ibGVtIHdpdGggdGhlIG9iamVjdCBzcHJlYWQgb3BlcmF0b3IgYW5kIHRoZSBidWlsZCBzbyB1c2luZyBPYmplY3QuYXNzaWduIGluc3RlYWQuXHJcblx0Ly8gJC5ydWxlcyA9IHtcclxuXHQvLyBcdFx0c3VpY2lkZTogdHJ1ZSxcclxuXHQvLyBcdFx0Ly8gc3VwZXJrbzogZmFsc2UgLyrih5J0b2RvOiBlbmZvcmNlIHdoZW4gdHJ1ZT8qLyxcclxuXHQvLyBcdFx0a29taTogNy41LFxyXG5cdC8vIFx0XHQuLi4gb3B0aW9ucy5ydWxlc1xyXG5cdC8vIFx0fVxyXG5cdCQucnVsZXMgPSBPYmplY3QuYXNzaWduKHt9LCB7XHJcblx0XHRzdWljaWRlOiB0cnVlLFxyXG5cdFx0Ly8gc3VwZXJrbzogZmFsc2UgLyrih5J0b2RvOiBlbmZvcmNlIHdoZW4gdHJ1ZT8qLyxcclxuXHRcdGtvbWk6IDcuNSxcclxuXHR9LCBvcHRpb25zLnJ1bGVzKVxyXG5cclxuXHQvLyAkLm1vdmVzID0gb3B0aW9ucy5tb3ZlcyB8fCBbXVxyXG5cdCQub3B0aW9ucyA9IG9wdGlvbnNcclxuXHRvcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zIHx8IFsxMSwgMTFdXHJcblx0b3B0aW9ucy5ib2FyZE1vZGUgPSBvcHRpb25zLmJvYXJkTW9kZSB8fCAndCcvKnQ6dG9yb2lkOyBjOmNsYXNzaWMg4oCmKi9cclxuXHQkLmJvYXJkID0ge31cclxuXHQkLmJvYXJkLmJsYWNrU3RvbmVzID0gb3B0aW9ucy5ibGFja1N0b25lcyB8fCBbXVxyXG5cdCQuYm9hcmQud2hpdGVTdG9uZXMgPSBvcHRpb25zLndoaXRlU3RvbmVzIHx8IFtdXHJcblxyXG5cdCQuYm9hcmQubmV4dFBsYXllciA9IG9wdGlvbnMubmV4dFBsYXllciB8fCBcImJcIlxyXG5cdCQuYm9hcmQuY2FwdHVyZWQgPSBvcHRpb25zLmNhcHR1cmVkIHx8IFswLCAwXVxyXG5cclxuXHQkLmV4cG9ydERhdGEgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRibGFja1N0b25lczogJC5ib2FyZC5ibGFja1N0b25lcy5tYXAoX2Nsb25lKSxcclxuXHJcblx0XHRcdHdoaXRlU3RvbmVzOiAkLmJvYXJkLndoaXRlU3RvbmVzLm1hcChfY2xvbmUpLFxyXG5cdFx0XHRjYXB0dXJlZDogX2Nsb25lKCQuYm9hcmQuY2FwdHVyZWQpLFxyXG5cdFx0XHRuZXh0UGxheWVyOiAkLmJvYXJkLm5leHRQbGF5ZXJcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdCQubG9hZERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdFx0JC5ib2FyZC5ibGFja1N0b25lcyA9IGRhdGEuYmxhY2tTdG9uZXNcclxuXHRcdCQuYm9hcmQud2hpdGVTdG9uZXMgPSBkYXRhLndoaXRlU3RvbmVzXHJcblx0XHQkLmJvYXJkLmNhcHR1cmVkID0gZGF0YS5jYXB0dXJlZFxyXG5cdFx0JC5ib2FyZC5uZXh0UGxheWVyID0gZGF0YS5uZXh0UGxheWVyXHJcblx0fVxyXG5cclxuXHQvL3Rvcm9pZFxyXG5cdGlmIChvcHRpb25zLmJvYXJkTW9kZSA9PT0gJ3QnKSAkLmJvYXJkLmdldE5laWdoYm91cnMgPVxyXG5cdFx0ZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRcdGxldCByZXN1bHQgPSBbXVxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG5cdFx0XHRcdGxldCBuZXdQb2ludFxyXG5cdFx0XHRcdHN3aXRjaCAoaSkge1xyXG5cdFx0XHRcdFx0Y2FzZSAwOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSArIDEsIHBvaW50WzFdXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSAtIDEsIHBvaW50WzFdXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAyOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSwgcG9pbnRbMV0gKyAxXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0Y2FzZSAzOlxyXG5cdFx0XHRcdFx0XHRuZXdQb2ludCA9IFtwb2ludFswXSwgcG9pbnRbMV0gLSAxXVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXN1bHQucHVzaChbKG5ld1BvaW50WzBdICsgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0pICUgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0sIChuZXdQb2ludFsxXSArIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdKSAlIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdXSlcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0XHJcblx0XHR9XHJcblx0aWYgKG9wdGlvbnMuYm9hcmRNb2RlID09PSAnYycpICQuYm9hcmQuZ2V0TmVpZ2hib3VycyA9XHJcblx0XHRmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdFx0bGV0IHJlc3VsdCA9IFtdXHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcblx0XHRcdFx0bGV0IG5ld1BvaW50XHJcblx0XHRcdFx0c3dpdGNoIChpKSB7XHJcblx0XHRcdFx0XHRjYXNlIDA6XHJcblx0XHRcdFx0XHRcdG5ld1BvaW50ID0gW3BvaW50WzBdICsgMSwgcG9pbnRbMV1dXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHRjYXNlIDE6XHJcblx0XHRcdFx0XHRcdG5ld1BvaW50ID0gW3BvaW50WzBdIC0gMSwgcG9pbnRbMV1dXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHRjYXNlIDI6XHJcblx0XHRcdFx0XHRcdG5ld1BvaW50ID0gW3BvaW50WzBdLCBwb2ludFsxXSArIDFdXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHRjYXNlIDM6XHJcblx0XHRcdFx0XHRcdG5ld1BvaW50ID0gW3BvaW50WzBdLCBwb2ludFsxXSAtIDFdXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChuZXdQb2ludFswXSA+PSAwICYmIG5ld1BvaW50WzBdIDwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF1cclxuXHRcdFx0XHRcdCYmIG5ld1BvaW50WzFdID49IDAgJiYgbmV3UG9pbnRbMV0gPCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXVxyXG5cdFx0XHRcdClcclxuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKG5ld1BvaW50KVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiByZXN1bHRcclxuXHRcdH1cclxuXHQvL3RvZG86IGtsZWluLCBwcm9qZWN0aXZlIHBsYW5lLCDigKZcclxuXHJcblx0JC5ib2FyZC5pc0VtcHR5ID0gZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gbXlJbmRleE9mKCQuYm9hcmQuYmxhY2tTdG9uZXMsIHBvaW50KSA8IDBcclxuXHRcdFx0JiYgbXlJbmRleE9mKCQuYm9hcmQud2hpdGVTdG9uZXMsIHBvaW50KSA8IDBcclxuXHR9XHJcblx0JC5ib2FyZC5nZXRDb2xvdXIgPSBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdGlmIChteUluZGV4T2YoJC5ib2FyZC5ibGFja1N0b25lcywgcG9pbnQpID49IDApIHJldHVybiAnYidcclxuXHRcdGlmIChteUluZGV4T2YoJC5ib2FyZC53aGl0ZVN0b25lcywgcG9pbnQpID49IDApIHJldHVybiAndydcclxuXHRcdHJldHVybiAnZSdcclxuXHR9XHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lcyBpZiBhIHBvaW50IGlzIHBhcnQgb2YgYSBjaGFpbiB3aXRoIGEgbGliZXJ0eTsgaWYgdGhlcmUgYXJlIG5vIGxpYmVydGllcyB0aGVuIGl0IHJldHVybnMgdGhlIGNoYWluIG9mIHN0b25lcyBvZiB0aGUgc2FtZSBjb2xvdXIgdGhhdCBhcmUgY29ubmVjdGVkIHRvIGBzdGFydFBvaW50YC4gQWxzbyB1c2VkIGZvciBjb3VudGluZyB0byByZXR1cm4gY29ubmVjdGVkIGNvbXBvbmVudHMgb2Ygc2FtZSBjb2xvdXIgKGJsYWNrLCB3aGl0ZSBvciBlbXB0eSkuXHJcblx0ICogQHBhcmFtIHsqfSBzdGFydFBvaW50IFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IGNoYWluQ29sb3VyIGluZGljYXRlcyB0aGUgY29sb3VyIG9mIHRoZSBzdGFydGluZyBwb2ludC5cclxuXHQgKiBAcGFyYW0geyp9IFtzdG9wQ29sb3VyPSdlJ10gc3RvcCB3b3JraW5nIGlmIHRoZSBjaGFpbiBtZWV0cyB0aGlzIGNvbG91clxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtnZXRDb2xvdXI9JC5ib2FyZC5nZXRDb2xvdXJdIEZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBjb2xvdXIgb2YgYSBwb2ludC5cclxuXHQgKiBAcmV0dXJucyB7Ym9vbHxhcnJheX0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRoZSBjb21wb25lbnQgbWVldHMgYHN0b3BDb2xvdXJgLCBhbmQgYW4gYXJyYXkgY29udGFpbmluZyBjb25uZWN0ZWQgY29tcG9uZW50IG9mIHBvaW50cyBsaW5rZWQgdG8gYHN0YXJ0UG9pbnRgIG90aGVyd2lzZS4gXHJcblx0ICovXHRcclxuXHRmdW5jdGlvbiBjaGFpbkhhc0xpYmVydHkgKHN0YXJ0UG9pbnQsIGNoYWluQ29sb3VyLCBzdG9wQ29sb3VyLCBnZXRDb2xvdXIpIHtcclxuXHRcdGlmIChzdG9wQ29sb3VyID09PSB1bmRlZmluZWQpXHJcblx0XHRcdHN0b3BDb2xvdXIgPSAnZScvL2J5IGRlZmF1bHQsIHN0b3AgZ2V0dGluZyB0aGUgY2hhaW4gd2hlbiB0aGVyZSBpcyBhIGxpYmVydHkuXHJcblx0XHRpZiAoZ2V0Q29sb3VyID09PSB1bmRlZmluZWQpXHJcblx0XHRcdGdldENvbG91ciA9ICQuYm9hcmQuZ2V0Q29sb3VyLy9ieSBkZWZhdWx0LCB1c2UgdGhlIHVzdWFsIGJvYXJkIGNvbG91ciBmdW5jdGlvblxyXG5cclxuXHRcdGlmIChjaGFpbkNvbG91ciA9PT0gbnVsbClcclxuXHRcdFx0Y2hhaW5Db2xvdXIgPSBnZXRDb2xvdXIoc3RhcnRQb2ludClcclxuXHRcdGxldFxyXG5cdFx0XHRjaGFpbiA9IFtzdGFydFBvaW50XVxyXG5cdFx0XHQsIHRvRXhwbG9yZSA9IFtdXHJcblx0XHRcdCwgcG9pbnQgPSBzdGFydFBvaW50IC8vYXNzdW1lZCB0byBiZSBvZiBjb2xvdXIgY2hhaW5Db2xvdXJcclxuXHJcblx0XHR3aGlsZSAocG9pbnQgIT09IHVuZGVmaW5lZCkge1xyXG5cclxuXHRcdFx0bGV0IG5laWdoYm91cnMgPSAkLmJvYXJkLmdldE5laWdoYm91cnMocG9pbnQpXHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmVpZ2hib3Vycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGxldCBuZXdQb2ludCA9IG5laWdoYm91cnNbaV0sXHJcblx0XHRcdFx0XHRuZXdDb2xvdXIgPSBnZXRDb2xvdXIobmV3UG9pbnQpXHJcblx0XHRcdFx0aWYgKG5ld0NvbG91ciA9PT0gc3RvcENvbG91cikgcmV0dXJuIHRydWU7XHJcblx0XHRcdFx0aWYgKG5ld0NvbG91ciA9PT0gY2hhaW5Db2xvdXIpIHtcclxuXHRcdFx0XHRcdGlmIChteUluZGV4T2YoY2hhaW4sIG5ld1BvaW50KSA8IDApIHtcclxuXHRcdFx0XHRcdFx0Y2hhaW4ucHVzaChuZXdQb2ludClcclxuXHRcdFx0XHRcdFx0Ly8gaWYgKG15SW5kZXhPZih0b0V4cGxvcmUsIG5ld1BvaW50KSA8IDApXHJcblx0XHRcdFx0XHRcdHRvRXhwbG9yZS5wdXNoKG5ld1BvaW50KVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRwb2ludCA9IHRvRXhwbG9yZS5wb3AoKVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjaGFpbjtcclxuXHR9XHJcblxyXG5cdCQuYm9hcmQuY2hhaW5IYXNMaWJlcnR5ID0gY2hhaW5IYXNMaWJlcnR5IFxyXG5cclxuXHQkLmJvYXJkLnNjb3JlID0gZnVuY3Rpb24gKGRlYWRTdG9uZXMpIHtcclxuXHRcdC8qXHJcblx0XHRnbyB0aHJvdWdoIHRoZSB3aG9sZSBib2FyZCBcclxuXHRcdCovXHJcblx0XHRpZiAoZGVhZFN0b25lcyA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGRlYWRTdG9uZXMgPSBbXVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCByZXN1bHQgPSB7XHJcblx0XHRcdGJsYWNrRW1wdHk6IFtdXHJcblx0XHRcdCwgd2hpdGVFbXB0eTogW11cclxuXHRcdFx0LCBkYW1lOiBbXVxyXG5cdFx0XHQsIGJsYWNrQWxpdmU6IFtdXHJcblx0XHRcdCwgd2hpdGVBbGl2ZTogW11cclxuXHRcdFx0LCBibGFja0RlYWQ6IFtdXHJcblx0XHRcdCwgd2hpdGVEZWFkOiBbXVxyXG5cdFx0XHQsIHRvdGFsQmxhY2tDYXB0dXJlZDogJC5ib2FyZC5jYXB0dXJlZFswXSAvL25iIEIgc3RvbmVzIHJlbW92ZWQgYnkgVyBkdXJpbmcgdGhlIGdhbWVcclxuXHRcdFx0LCB0b3RhbFdoaXRlQ2FwdHVyZWQ6ICQuYm9hcmQuY2FwdHVyZWRbMV0gLy9uYiBXIHN0b25lcyByZW1vdmVkIGJ5IEIgZHVyaW5nIHRoZSBnYW1lXHJcblx0XHRcdC8vdG9kbzpjb3VsZCByZXBsYWNlIGJ5IGFuIGNsYXNzLiBkYXRhIHN0b3JlZCBpbiBhIGJpZyBhcnJheSBvZiBwYWlycyBbcG9pbnQsIHN0YXR1c11cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZGVhZFN0b25lcy5sZW5ndGg7IGluZGV4KyspIHtcclxuXHRcdFx0Y29uc3QgZGVhZFN0b25lID0gZGVhZFN0b25lc1tpbmRleF07XHJcblx0XHRcdGxldCBkZWFkQ29sb3VyID0gJC5ib2FyZC5nZXRDb2xvdXIoZGVhZFN0b25lKVxyXG5cdFx0XHRpZiAoZGVhZENvbG91ciA9PT0gJ2UnKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWFya2VkIGRlYWQgc3RvbmUnKVxyXG5cdFx0XHRsZXRcclxuXHRcdFx0XHRkZWFkVG9GaWxsID0gZGVhZENvbG91ciA9PT0gJ2InID8gcmVzdWx0LmJsYWNrRGVhZCA6IHJlc3VsdC53aGl0ZURlYWRcclxuXHRcdFx0XHQsIGVtcHR5VG9GaWxsID0gZGVhZENvbG91ciA9PT0gJ2InID8gcmVzdWx0LndoaXRlRW1wdHkgOiByZXN1bHQuYmxhY2tFbXB0eVxyXG5cdFx0XHRcdCwgYWxpdmVUb0ZpbGwgPSBkZWFkQ29sb3VyID09PSAnYicgPyByZXN1bHQud2hpdGVBbGl2ZSA6IHJlc3VsdC5ibGFja0FsaXZlXHJcblx0XHRcdFx0LCBwcm9jZXNzUG9pbnQgPSAocG9pbnQsIGNvbG91cikgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGNvbG91ciA9PT0gZGVhZENvbG91ciAmJiBteUluZGV4T2YoZGVhZFRvRmlsbCwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRkZWFkVG9GaWxsLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHRcdGVtcHR5VG9GaWxsLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoKGNvbG91ciA9PT0gZGVhZENvbG91ciB8fCBjb2xvdXIgPT09ICdlJykgJiYgbXlJbmRleE9mKGVtcHR5VG9GaWxsLCBwb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdGVtcHR5VG9GaWxsLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoY29sb3VyICE9PSBkZWFkQ29sb3VyICYmIGNvbG91ciAhPT0gJ2UnICYmIG15SW5kZXhPZihhbGl2ZVRvRmlsbCwgcG9pbnQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRhbGl2ZVRvRmlsbC5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQsIGdldENvbG91ckZvckRlYWRDb21wb25lbnQgPSAocG9pbnQpID0+IHtcclxuXHRcdFx0XHRcdGxldCBjb2xvdXIgPSAkLmJvYXJkLmdldENvbG91cihwb2ludClcclxuXHRcdFx0XHRcdHByb2Nlc3NQb2ludChwb2ludCwgY29sb3VyKVxyXG5cdFx0XHRcdFx0cmV0dXJuIGNvbG91ciA9PT0gZGVhZENvbG91ciA/ICdlJyA6IGNvbG91clxyXG5cdFx0XHRcdH1cclxuXHRcdFx0cHJvY2Vzc1BvaW50KGRlYWRTdG9uZSwgZGVhZENvbG91cilcclxuXHRcdFx0JC5ib2FyZC5jaGFpbkhhc0xpYmVydHkoZGVhZFN0b25lLCAnZScsICcnLCBnZXRDb2xvdXJGb3JEZWFkQ29tcG9uZW50KVxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwLGV4aXRMb29wID0gZmFsc2U7IGkgPCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXTsgaSsrKSB7XHJcblx0XHRcdGlmIChleGl0TG9vcCkge1xyXG5cdFx0XHRcdGJyZWFrXHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXTsgaisrKSB7XHJcblx0XHRcdFx0aWYgKHJlc3VsdC5ibGFja0VtcHR5Lmxlbmd0aFxyXG5cdFx0XHRcdFx0KyByZXN1bHQud2hpdGVFbXB0eS5sZW5ndGhcclxuXHRcdFx0XHRcdCsgcmVzdWx0LmRhbWUubGVuZ3RoXHJcblx0XHRcdFx0XHQrIHJlc3VsdC5ibGFja0FsaXZlLmxlbmd0aFxyXG5cdFx0XHRcdFx0KyByZXN1bHQud2hpdGVBbGl2ZS5sZW5ndGhcclxuXHRcdFx0XHRcdC8vICsgcmVzdWx0LmJsYWNrRGVhZC5sZW5ndGhcclxuXHRcdFx0XHRcdC8vICsgcmVzdWx0LndoaXRlRGVhZC5sZW5ndGhcclxuXHRcdFx0XHRcdD09PSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXSAqIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzFdXHJcblx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRleGl0TG9vcCA9IHRydWVcclxuXHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gW2ksIGpdLCBjb2xvdXIgPSAkLmJvYXJkLmdldENvbG91cihwb2ludClcclxuXHJcblx0XHRcdFx0aWYgKGNvbG91ciA9PT0gJ2InXHJcblx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRpZiAobXlJbmRleE9mKHJlc3VsdC5ibGFja0FsaXZlLCBwb2ludCkgPCAwXHJcblx0XHRcdFx0XHRcdCYmIG15SW5kZXhPZihyZXN1bHQuYmxhY2tEZWFkLCBwb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdC5ibGFja0FsaXZlLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHR9IGVsc2UgY29udGludWVcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGNvbG91ciA9PT0gJ3cnKSB7XHJcblx0XHRcdFx0XHRpZiAobXlJbmRleE9mKHJlc3VsdC53aGl0ZUFsaXZlLCBwb2ludCkgPCAwXHJcblx0XHRcdFx0XHRcdCYmIG15SW5kZXhPZihyZXN1bHQud2hpdGVEZWFkLCBwb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdC53aGl0ZUFsaXZlLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHR9IGVsc2UgY29udGludWVcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjb2xvdXIgPT09ICdlJykge1xyXG5cdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQuYmxhY2tFbXB0eSwgcG9pbnQpID49IDBcclxuXHRcdFx0XHRcdFx0fHwgbXlJbmRleE9mKHJlc3VsdC53aGl0ZUVtcHR5LCBwb2ludCkgPj0gMFxyXG5cdFx0XHRcdFx0XHR8fCBteUluZGV4T2YocmVzdWx0LmRhbWUsIHBvaW50KSA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0XHJcblx0XHRcdFx0XHRcdG1lZXRzQmxhY2sgPSBmYWxzZVxyXG5cdFx0XHRcdFx0XHQsIG1lZXRzV2hpdGUgPSBmYWxzZVxyXG5cdFx0XHRcdFx0XHQsIGlzQmxhY2tUZXJyaXRvcnkgPSBmYWxzZVxyXG5cdFx0XHRcdFx0XHQsIGlzV2hpdGVUZXJyaXRvcnkgPSBmYWxzZVxyXG5cdFx0XHRcdFx0XHQsIGdldENvbG91ckZvclNjb3JpbmcgPSAocG9pbnQpID0+IHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bGV0IGNvbG91ciA9ICQuYm9hcmQuZ2V0Q29sb3VyKHBvaW50KVxyXG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAoY29sb3VyKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlICdiJzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG15SW5kZXhPZihyZXN1bHQuYmxhY2tEZWFkLCBwb2ludCkgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbG91ciA9ICdlJ1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlzV2hpdGVUZXJyaXRvcnkgPSB0cnVlXHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bWVldHNCbGFjayA9IHRydWVcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobXlJbmRleE9mKHJlc3VsdC5ibGFja0FsaXZlLCBwb2ludCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQuYmxhY2tBbGl2ZS5wdXNoKHBvaW50KVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgJ3cnOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAobXlJbmRleE9mKHJlc3VsdC53aGl0ZURlYWQsIHBvaW50KSA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29sb3VyID0gJ2UnXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aXNCbGFja1RlcnJpdG9yeSA9IHRydWVcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRtZWV0c1doaXRlID0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChteUluZGV4T2YocmVzdWx0LndoaXRlQWxpdmUsIHBvaW50KSA8IDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC53aGl0ZUFsaXZlLnB1c2gocG9pbnQpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6Ly9ub3RoaW5nIG5lZWRlZCBmb3IgJ2UnXHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY29sb3VyXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxldCBlbXB0eUNvbXBvbmVudCA9ICQuYm9hcmQuY2hhaW5IYXNMaWJlcnR5KHBvaW50LCAnZScsICcnLCBnZXRDb2xvdXJGb3JTY29yaW5nKVxyXG5cdFx0XHRcdFx0aWYgKCFtZWV0c0JsYWNrICYmICFtZWV0c1doaXRlKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignY291bnRpbmcgYW4gZW1wdHkgYm9hcmQhJylcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChpc0JsYWNrVGVycml0b3J5ICYmIGlzV2hpdGVUZXJyaXRvcnkpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCd0b28gbWFueSBzdG9uZXMgbWFya2VkIGFzIGRlYWQnKVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly9jb3VsZCBzdG9yZSB0aGUgZGlmZmVyZW50IGVtcHR5IGNvbXBvbmVudHM6IFYyIFxyXG5cdFx0XHRcdFx0aWYgKG1lZXRzQmxhY2sgJiYgbWVldHNXaGl0ZSkge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHQuZGFtZSA9IHJlc3VsdC5kYW1lLmNvbmNhdChlbXB0eUNvbXBvbmVudClcclxuXHRcdFx0XHRcdFx0Y29udGludWVcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChtZWV0c0JsYWNrKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdC5ibGFja0VtcHR5ID0gcmVzdWx0LmJsYWNrRW1wdHkuY29uY2F0KGVtcHR5Q29tcG9uZW50KVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKG1lZXRzV2hpdGUpIHtcclxuXHRcdFx0XHRcdFx0cmVzdWx0LndoaXRlRW1wdHkgPSByZXN1bHQud2hpdGVFbXB0eS5jb25jYXQoZW1wdHlDb21wb25lbnQpXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvL3RvdGFsc1xyXG5cdFx0cmVzdWx0LnRvdGFsQmxhY2tEZWFkID0gcmVzdWx0LmJsYWNrRGVhZC5sZW5ndGhcclxuXHRcdHJlc3VsdC50b3RhbFdoaXRlRGVhZCA9IHJlc3VsdC53aGl0ZURlYWQubGVuZ3RoXHJcblx0XHRyZXN1bHQudG90YWxCbGFja1RlcnJpdG9yeSA9IHJlc3VsdC5ibGFja0VtcHR5Lmxlbmd0aFxyXG5cdFx0cmVzdWx0LnRvdGFsV2hpdGVUZXJyaXRvcnkgPSByZXN1bHQud2hpdGVFbXB0eS5sZW5ndGhcclxuXHJcblxyXG5cdFx0Ly90b2RvOiBpbXBsZW1lbnQgb3RoZXIgcnVsZXNldHMuIEZvciBub3csIGp1c3QgZG8gdGVycml0b3J5ICsgcHJpc29uZXJzIChKYXBhbmVzZSBzdHlsZSBjb3VudGluZylcclxuXHRcdHJlc3VsdC5ibGFja1Njb3JlID1cclxuXHRcdFx0cmVzdWx0LnRvdGFsV2hpdGVEZWFkXHJcblx0XHRcdCsgcmVzdWx0LnRvdGFsV2hpdGVDYXB0dXJlZFxyXG5cdFx0XHQrIHJlc3VsdC50b3RhbEJsYWNrVGVycml0b3J5XHJcblx0XHRyZXN1bHQud2hpdGVTY29yZSA9XHJcblx0XHRcdHJlc3VsdC50b3RhbEJsYWNrRGVhZFxyXG5cdFx0XHQrIHJlc3VsdC50b3RhbEJsYWNrQ2FwdHVyZWRcclxuXHRcdFx0KyByZXN1bHQudG90YWxXaGl0ZVRlcnJpdG9yeVxyXG5cdFx0XHQrICQucnVsZXMua29taVxyXG5cdFx0bGV0IHIgPSByZXN1bHQuYmxhY2tTY29yZSAtIHJlc3VsdC53aGl0ZVNjb3JlXHJcblx0XHRpZiAociA9PT0gMCkgcmVzdWx0LlJFID0gJzAnXHJcblx0XHRlbHNlIGlmIChyID4gMCkgcmVzdWx0LlJFID0gJ0IrJyArIHJcclxuXHRcdGVsc2UgcmVzdWx0LlJFID0gJ1crJyArICgtcilcclxuXHRcdHJldHVybiByZXN1bHRcclxuXHR9XHJcblxyXG5cdCQuYm9hcmQuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHQkLmJvYXJkLndoaXRlU3RvbmVzID0gW11cclxuXHRcdCQuYm9hcmQuYmxhY2tTdG9uZXMgPSBbXVxyXG5cdFx0JC5ib2FyZC5jYXB0dXJlZCA9IFswLCAwXVxyXG5cclxuXHR9XHJcblxyXG5cdCQucmVtb3ZlQ2hhaW4gPSBmdW5jdGlvbiAoY2hhaW4sIGNvbG91cikge1xyXG5cdFx0bGV0IHRvUmVtb3ZlRnJvbSA9IGNvbG91ciA9PT0gJ3cnID8gJC5ib2FyZC53aGl0ZVN0b25lcyA6ICQuYm9hcmQuYmxhY2tTdG9uZXNcclxuXHRcdGZvciAobGV0IGogPSAwOyBqIDwgY2hhaW4ubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0bGV0IGluZGV4ID0gbXlJbmRleE9mKHRvUmVtb3ZlRnJvbSwgY2hhaW5bal0pXHJcblx0XHRcdHRvUmVtb3ZlRnJvbS5zcGxpY2UoaW5kZXgsIDEpXHJcblx0XHRcdGlmIChjb2xvdXIgPT09ICd3JykgJC5ib2FyZC5jYXB0dXJlZFsxXSA9ICQuYm9hcmQuY2FwdHVyZWRbMV0gKyAxXHJcblx0XHRcdGVsc2UgJC5ib2FyZC5jYXB0dXJlZFswXSA9ICQuYm9hcmQuY2FwdHVyZWRbMF0gKyAxXHJcblx0XHR9XHJcblx0fVxyXG5cdCQucGxheSA9IGZ1bmN0aW9uIChwbGF5ZXJDb2xvdXIsIHBvaW50KSB7XHJcblxyXG5cclxuXHJcblx0XHQvLyBsZXQgcmVzdWx0ID0gXCJva1wiXHJcblx0XHRpZiAoISQuYm9hcmQuaXNFbXB0eShwb2ludCkpXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigncG9pbnQgaXMgbm90IGVtcHR5JylcclxuXHRcdC8vIGNvbnNvbGUubG9nKCdwb2ludCBpcyBub3QgZW1wdHknICsgcG9pbnQpXHJcblxyXG5cdFx0aWYgKHBsYXllckNvbG91ciA9PT0gJ2InKSAkLmJvYXJkLmJsYWNrU3RvbmVzLnB1c2gocG9pbnQpXHJcblx0XHRlbHNlICQuYm9hcmQud2hpdGVTdG9uZXMucHVzaChwb2ludClcclxuXHJcblx0XHRsZXQgbmVpZ2hib3VycyA9ICQuYm9hcmQuZ2V0TmVpZ2hib3Vycyhwb2ludClcclxuXHRcdFx0LCByZW1vdmVkID0gW10vL2NoYWlucyByZW1vdmVkXHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuZWlnaGJvdXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCBuZWlnaGJvdXIgPSBuZWlnaGJvdXJzW2ldLCBjb2xvdXIgPSAkLmJvYXJkLmdldENvbG91cihuZWlnaGJvdXIpXHJcblx0XHRcdGlmIChjb2xvdXIgPT09IHBsYXllckNvbG91ciB8fCBjb2xvdXIgPT09ICdlJykgY29udGludWVcclxuXHRcdFx0bGV0IG9wcENvbG91ciA9ICQuZ2V0T3Bwb3NpdGVDb2xvdXIocGxheWVyQ29sb3VyKSxcclxuXHRcdFx0XHRyID0gJC5ib2FyZC5jaGFpbkhhc0xpYmVydHkobmVpZ2hib3VyLCBvcHBDb2xvdXIpXHJcblx0XHRcdGlmIChyID09PSB0cnVlKSBjb250aW51ZVxyXG5cdFx0XHQvLy8vcmVtb3ZlIC0gbm8gbGliZXJ0aWVzXHJcblx0XHRcdHJlbW92ZWRbcmVtb3ZlZC5sZW5ndGhdID0gclxyXG5cclxuXHRcdFx0JC5yZW1vdmVDaGFpbihyLCBvcHBDb2xvdXIpXHJcblxyXG5cdFx0XHQvLyBsZXQgY2hhaW5Ub1JlbW92ZSA9IHJbMV0sXHJcblx0XHRcdC8vIHRvUmVtb3ZlRnJvbSA9IHBsYXllckNvbG91ciA9PT0gJ2InID8gJC5ib2FyZC53aGl0ZVN0b25lcyA6ICQuYm9hcmQuYmxhY2tTdG9uZXNcclxuXHRcdFx0Ly8gZm9yIChsZXQgaiA9IDA7IGo8Y2hhaW5Ub1JlbW92ZS5sZW5ndGg7IGorKylcclxuXHRcdFx0Ly8ge1xyXG5cdFx0XHQvLyBsZXQgaW5kZXggPSBteUluZGV4T2YodG9SZW1vdmVGcm9tLGNoYWluVG9SZW1vdmVbal0pXHJcblx0XHRcdC8vIHRvUmVtb3ZlRnJvbS5zcGxpY2UoaW5kZXgsIDEpXHJcblx0XHRcdC8vIGlmIChwbGF5ZXJDb2xvdXIgPT09ICdiJykgJC5ib2FyZC5jYXB0dXJlZFsxXSA9ICQuYm9hcmQuY2FwdHVyZWRbMV0gKyAxXHJcblx0XHRcdC8vIGVsc2UgJC5ib2FyZC5jYXB0dXJlZFswXSA9ICQuYm9hcmQuY2FwdHVyZWRbMF0gKyAxXHJcblx0XHRcdC8vIH1cclxuXHRcdFx0Ly8gcmVtb3ZlZCA9IHRydWVcclxuXHRcdH1cclxuXHRcdGxldCBzdWljaWRlID0gZmFsc2VcclxuXHRcdGlmIChyZW1vdmVkLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRsZXQgcyA9ICQuYm9hcmQuY2hhaW5IYXNMaWJlcnR5KHBvaW50LCBwbGF5ZXJDb2xvdXIpXHJcblx0XHRcdGlmIChzICE9PSB0cnVlKSB7XHJcblx0XHRcdFx0aWYgKCQucnVsZXMuc3VpY2lkZSkge1xyXG5cdFx0XHRcdFx0JC5yZW1vdmVDaGFpbihzLCBwbGF5ZXJDb2xvdXIpXHJcblx0XHRcdFx0XHRzdWljaWRlID0gc1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignc3VpY2lkZScpLy9pc27igJl0IGFsbG93ZWRcclxuXHRcdFx0XHRcdC8vdG9kbzogcmVtb3ZlIHBvaW50IGZyb20gd2hpdGVTdG9uZXMgb3IgYmxhY2tTdG9uZXNcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvKlxyXG5cdFx0XHRzdG9yaW5nIHRoZSBzaXR1YXRpb24gaW4gbWVtb3J5IC0gd291bGQgYmUgdXNlZnVsIHdoZW4gaW1wbGVtZW50aW5nIGdvaW5nIGJhY2sgYSBtb3ZlLCBzdXBlcmtvLCDigKZcclxuXHRcdFx0bm90IG5lZWRlZCBmb3Igbm93XHJcblx0XHQqL1xyXG5cdFx0Ly8kLm1vdmVzLnB1c2goW3BsYXllckNvbG91cixwb2ludCxfLmNsb25lKCQuYm9hcmQud2hpdGVTdG9uZXMpLF8uY2xvbmUoJC5ib2FyZC5ibGFja1N0b25lcyldKVxyXG5cdFx0Ly8gJC5tb3Zlcy5wdXNoKFtwbGF5ZXJDb2xvdXIscG9pbnRdKVxyXG5cclxuXHRcdC8vIGdldE5laWdoYm91cnNbaV0gPSBbZ2V0TmVpZ2hib3Vyc1tpXSwgJC5ib2FyZC5nZXRDb2xvdXJbZ2V0TmVpZ2hib3Vyc1tpXV1cclxuXHRcdC8vIC8v4oCmXHJcblxyXG5cclxuXHRcdHJldHVybiB7IHJlbW92ZWQsIHN1aWNpZGUgfVxyXG5cdH1cclxuXHQkLmdldE9wcG9zaXRlQ29sb3VyID0gZnVuY3Rpb24gKGNvbG91cikge1xyXG5cdFx0c3dpdGNoIChjb2xvdXIpIHtcclxuXHRcdFx0Y2FzZSAnYic6XHJcblx0XHRcdFx0cmV0dXJuICd3J1xyXG5cdFx0XHRjYXNlICd3JzpcclxuXHRcdFx0XHRyZXR1cm4gJ2InXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbFxyXG5cdH1cclxuXHRyZXR1cm4gJFxyXG5cclxufSIsInZhciBiYXNlSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Jhc2VJbmRleE9mJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlcztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhcnJheUluY2x1ZGVzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IodmFsdWUsIGFycmF5W2luZGV4XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXNOYU4gPSByZXF1aXJlKCcuL19iYXNlSXNOYU4nKSxcbiAgICBzdHJpY3RJbmRleE9mID0gcmVxdWlyZSgnLi9fc3RyaWN0SW5kZXhPZicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYU47XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKSxcbiAgICBjcmVhdGVTZXQgPSByZXF1aXJlKCcuL19jcmVhdGVTZXQnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gIH1cbiAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgIH1cbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgfVxuICBlbHNlIHtcbiAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmlxO1xuIiwidmFyIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIG5vb3AgPSByZXF1aXJlKCcuL25vb3AnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNldDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaWN0SW5kZXhPZjtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5vb3A7XG4iLCJ2YXIgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZVVuaXEgPSByZXF1aXJlKCcuL19iYXNlVW5pcScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gKiB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gKiAvLyA9PiBbMi4xLCAxLjJdXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gKiAvLyA9PiBbeyAneCc6IDEgfSwgeyAneCc6IDIgfV1cbiAqL1xuZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxQnk7XG4iLCIvKipcbiAqIENvbnZlcnQgU0dGIGZpbGVzIHRvIGEgSlMgb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2dmIEEgdmFsaWQgU0dGIGZpbGUuXG4gKiBAc2VlIGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWxcbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIFNHRiBmaWxlIHJlcHJlc2VudGVkIGFzIGEgSlMgb2JqZWN0XG4gKi9cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc2dmKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgcGFyc2U7XG5cdHZhciBwYXJzZXI7XG5cdHZhciBjb2xsZWN0aW9uID0ge307XG5cblx0Ly8gdHJhY2tzIHRoZSBjdXJyZW50IHNlcXVlbmNlXG5cdHZhciBzZXF1ZW5jZTtcblxuXHQvLyB0cmFja3MgdGhlIGN1cnJlbnQgbm9kZVxuXHR2YXIgbm9kZTtcblxuXHQvLyB0cmFja3MgdGhlIGxhc3QgUHJvcElkZW50XG5cdHZhciBsYXN0UHJvcElkZW50O1xuXG5cdC8vIEEgbWFwIG9mIGZ1bmN0aW9ucyB0byBwYXJzZSB0aGUgZGlmZmVyZW50IGNvbXBvbmVudHMgb2YgYW4gU0dGIGZpbGVcblx0cGFyc2VyID0ge1xuXG5cdFx0YmVnaW5TZXF1ZW5jZTogZnVuY3Rpb24gKHNnZikge1xuXHRcdFx0dmFyIGtleSA9ICdzZXF1ZW5jZXMnO1xuXG5cdFx0XHQvLyBUb3AtbGV2ZWwgc2VxdWVuY2VzIGFyZSBnYW1lVHJlZXNcblx0XHRcdGlmICghc2VxdWVuY2UpIHtcblx0XHRcdFx0c2VxdWVuY2UgPSBjb2xsZWN0aW9uO1xuXHRcdFx0XHRrZXkgPSAnZ2FtZVRyZWVzJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNlcXVlbmNlLmdhbWVUcmVlcykge1xuXHRcdFx0XHRrZXkgPSAnZ2FtZVRyZWVzJztcblx0XHRcdH1cblxuXHRcdFx0dmFyIG5ld1NlcXVlbmNlID0ge1xuXHRcdFx0XHRwYXJlbnQ6IHNlcXVlbmNlXG5cdFx0XHR9O1xuXG5cdFx0XHRzZXF1ZW5jZVtrZXldID0gc2VxdWVuY2Vba2V5XSB8fCBbXTtcblx0XHRcdHNlcXVlbmNlW2tleV0ucHVzaChuZXdTZXF1ZW5jZSk7XG5cdFx0XHRzZXF1ZW5jZSA9IG5ld1NlcXVlbmNlO1xuXG5cdFx0XHRyZXR1cm4gc2dmLnN1YnN0cmluZygxKTtcblx0XHR9LFxuXG5cdFx0ZW5kU2VxdWVuY2U6IGZ1bmN0aW9uIChzZ2YpIHtcblx0XHRcdGlmIChzZXF1ZW5jZS5wYXJlbnQpIHtcblx0XHRcdFx0c2VxdWVuY2UgPSBzZXF1ZW5jZS5wYXJlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXF1ZW5jZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2dmLnN1YnN0cmluZygxKTtcblx0XHR9LFxuXG5cdFx0bm9kZTogZnVuY3Rpb24gKHNnZikge1xuXHRcdFx0bm9kZSA9IHt9O1xuXHRcdFx0c2VxdWVuY2Uubm9kZXMgPSBzZXF1ZW5jZS5ub2RlcyB8fCBbXTtcblx0XHRcdHNlcXVlbmNlLm5vZGVzLnB1c2gobm9kZSk7XG5cdFx0XHRyZXR1cm4gc2dmLnN1YnN0cmluZygxKTtcblx0XHR9LFxuXG5cdFx0cHJvcGVydHk6IGZ1bmN0aW9uIChzZ2YpIHtcblx0XHRcdHZhciBwcm9wVmFsdWU7XG5cblx0XHRcdC8vIFNlYXJjaCBmb3IgdGhlIGZpcnN0IHVuZXNjYXBlZCBdXG5cdFx0XHR2YXIgZmlyc3RQcm9wRW5kID0gc2dmLm1hdGNoKC8oW15cXFxcXFxdXXxcXFxcKC58XFxufFxccikpKlxcXS8pO1xuXG5cdFx0XHRpZiAoIWZpcnN0UHJvcEVuZC5sZW5ndGgpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgc2dmJyk7XG5cdFx0XHR9XG5cblx0XHRcdGZpcnN0UHJvcEVuZCA9IGZpcnN0UHJvcEVuZFswXS5sZW5ndGg7XG5cblx0XHRcdHZhciBwcm9wZXJ0eSA9IHNnZi5zdWJzdHJpbmcoMCwgZmlyc3RQcm9wRW5kKTtcblx0XHRcdHZhciBwcm9wVmFsdWVCZWdpbiA9IHByb3BlcnR5LmluZGV4T2YoJ1snKTtcblx0XHRcdHZhciBwcm9wSWRlbnQgPSBwcm9wZXJ0eS5zdWJzdHJpbmcoMCwgcHJvcFZhbHVlQmVnaW4pO1xuXG5cdFx0XHQvLyBQb2ludCBsaXN0cyBkb24ndCBkZWNsYXJlIGEgUHJvcElkZW50IGZvciBlYWNoIFByb3BWYWx1ZVxuXHRcdFx0Ly8gSW5zdGVhZCwgdGhleSBzaG91bGQgdXNlIHRoZSBsYXN0IGRlY2xhcmVkIHByb3BlcnR5XG5cdFx0XHQvLyBTZWU6IGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWwjbW92ZS9wb3Ncblx0XHRcdGlmICghcHJvcElkZW50KSB7XG5cdFx0XHRcdHByb3BJZGVudCA9IGxhc3RQcm9wSWRlbnQ7XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgcHJvcGVydHkgaW4gYSBsaXN0IG9mIG11bHRpcGxlXG5cdFx0XHRcdC8vIHByb3BlcnRpZXMsIHdlIG5lZWQgdG8gd3JhcCB0aGUgUHJvcFZhbHVlIGluIGFuIGFycmF5XG5cdFx0XHRcdGlmICghQXJyYXkuaXNBcnJheShub2RlW3Byb3BJZGVudF0pKSB7XG5cdFx0XHRcdFx0bm9kZVtwcm9wSWRlbnRdID0gW25vZGVbcHJvcElkZW50XV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGFzdFByb3BJZGVudCA9IHByb3BJZGVudDtcblxuXHRcdFx0cHJvcFZhbHVlID0gcHJvcGVydHkuc3Vic3RyaW5nKHByb3BWYWx1ZUJlZ2luICsgMSwgcHJvcGVydHkubGVuZ3RoIC0gMSk7XG5cblx0XHRcdC8vIFdlIGhhdmUgbm8gcHJvYmxlbSBwYXJzaW5nIFByb3BJZGVudHMgb2YgYW55IGxlbmd0aCwgYnV0IHRoZSBzcGVjXG5cdFx0XHQvLyBzYXlzIHRoZXkgc2hvdWxkIGJlIG5vIGxvbmdlciB0aGFuIHR3byBjaGFyYWN0ZXJzLlxuXHRcdFx0Ly9cblx0XHRcdC8vIGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWwjMi4yXG5cdFx0XHRpZiAocHJvcElkZW50Lmxlbmd0aCA+IDIpIHtcblx0XHRcdFx0Ly8gVE9ETzogV2hhdCdzIHRoZSBiZXN0IHdheSB0byBpc3N1ZSBhIHdhcm5pbmc/XG5cdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHQnU0dGIFByb3BJZGVudHMgc2hvdWxkIGJlIG5vIGxvbmdlciB0aGFuIHR3byBjaGFyYWN0ZXJzOicsIHByb3BJZGVudFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShub2RlW3Byb3BJZGVudF0pKSB7XG5cdFx0XHRcdG5vZGVbcHJvcElkZW50XS5wdXNoKHByb3BWYWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlW3Byb3BJZGVudF0gPSBwcm9wVmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZ2Yuc3Vic3RyaW5nKGZpcnN0UHJvcEVuZCk7XG5cdFx0fSxcblxuXHRcdC8vIFdoaXRlc3BhY2UsIHRhYnMsIG9yIGFueXRoaW5nIGVsc2Ugd2UgZG9uJ3QgcmVjb2duaXplXG5cdFx0dW5yZWNvZ25pemVkOiBmdW5jdGlvbiAoc2dmKSB7XG5cblx0XHRcdC8vIE1hcmNoIGFoZWFkIHRvIHRoZSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0cmV0dXJuIHNnZi5zdWJzdHJpbmcoMSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFByb2Nlc3NlcyBhbiBTR0YgZmlsZSBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyXG5cdHBhcnNlID0gZnVuY3Rpb24gKHNnZikge1xuXHRcdHdoaWxlIChzZ2YpIHtcblx0XHRcdHZhciBpbml0aWFsID0gc2dmLnN1YnN0cmluZygwLCAxKTtcblx0XHRcdHZhciB0eXBlO1xuXG5cdFx0XHQvLyBVc2UgdGhlIGluaXRpYWwgKHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHJlbWFpbmluZyBzZ2YgZmlsZSkgdG9cblx0XHRcdC8vIGRlY2lkZSB3aGljaCBwYXJzZXIgZnVuY3Rpb24gdG8gdXNlXG5cdFx0XHRpZiAoaW5pdGlhbCA9PT0gJygnKSB7XG5cdFx0XHRcdHR5cGUgPSAnYmVnaW5TZXF1ZW5jZSc7XG5cdFx0XHR9IGVsc2UgaWYgKGluaXRpYWwgPT09ICcpJykge1xuXHRcdFx0XHR0eXBlID0gJ2VuZFNlcXVlbmNlJztcblx0XHRcdH0gZWxzZSBpZiAoaW5pdGlhbCA9PT0gJzsnKSB7XG5cdFx0XHRcdHR5cGUgPSAnbm9kZSc7XG5cdFx0XHR9IGVsc2UgaWYgKGluaXRpYWwuc2VhcmNoKC9bQS1aXFxbXS8pICE9PSAtMSkge1xuXHRcdFx0XHR0eXBlID0gJ3Byb3BlcnR5Jztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSAndW5yZWNvZ25pemVkJztcblx0XHRcdH1cblxuXHRcdFx0c2dmID0gcGFyc2VyW3R5cGVdKHNnZik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbGxlY3Rpb247XG5cdH07XG5cblx0Ly8gQmVnaW4gcGFyc2luZyB0aGUgU0dGIGZpbGVcblx0cmV0dXJuIHBhcnNlKHNnZik7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGFuIFNHRiBmaWxlIGZyb20gYSBTbWFydEdhbWUgUmVjb3JkIEphdmFTY3JpcHQgT2JqZWN0XG4gKiBAcGFyYW0ge29iamVjdH0gcmVjb3JkIEEgcmVjb3JkIG9iamVjdC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHJlY29yZCBhcyBhIHN0cmluZyBzdWl0YWJsZSBmb3Igc2F2aW5nIGFzIGFuIFNHRiBmaWxlXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAocmVjb3JkKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHRmdW5jdGlvbiBzdHJpbmdpZnlTZXF1ZW5jZXMoc2VxdWVuY2VzKSB7XG5cdFx0dmFyIGNvbnRlbnRzID0gJyc7XG5cblx0XHRzZXF1ZW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoc2VxdWVuY2UpIHtcblx0XHRcdGNvbnRlbnRzICs9ICcoJztcblxuXHRcdFx0Ly8gUGFyc2UgYWxsIG5vZGVzIGluIHRoaXMgc2VxdWVuY2Vcblx0XHRcdGlmIChzZXF1ZW5jZS5ub2Rlcykge1xuXHRcdFx0XHRzZXF1ZW5jZS5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRcdFx0dmFyIG5vZGVTdHJpbmcgPSAnOyc7XG5cdFx0XHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gbm9kZSkge1xuXHRcdFx0XHRcdFx0aWYgKG5vZGUuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBwcm9wID0gbm9kZVtwcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHByb3ApKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvcCA9IHByb3Auam9pbignXVsnKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRub2RlU3RyaW5nICs9IHByb3BlcnR5ICsgJ1snICsgcHJvcCArICddJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29udGVudHMgKz0gbm9kZVN0cmluZztcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgdGhlIGZ1bmN0aW9uIHdlJ3JlIGluIHJlY3Vyc2l2ZWx5IGZvciBhbnkgY2hpbGQgc2VxdWVuY2VzXG5cdFx0XHRpZiAoc2VxdWVuY2Uuc2VxdWVuY2VzKSB7XG5cdFx0XHRcdGNvbnRlbnRzICs9IHN0cmluZ2lmeVNlcXVlbmNlcyhzZXF1ZW5jZS5zZXF1ZW5jZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb250ZW50cyArPSAnKSc7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gY29udGVudHM7XG5cdH1cblxuXHRyZXR1cm4gc3RyaW5naWZ5U2VxdWVuY2VzKHJlY29yZC5nYW1lVHJlZXMpO1xufTtcblxuIiwiLyoqXG4gKiBJbnRlcmFjdCB3aXRoIHNtYXJ0Z2FtZSBvYmplY3RzLlxuICogQHBhcmFtIHtvYmplY3R9IHNtYXJ0Z2FtZSBBIEpTIE9iamVjdCByZXByZXNlbnRpbmcgYSBzbWFydGdhbWVcbiAqIEBzZWUgaHR0cDovL3d3dy5yZWQtYmVhbi5jb20vc2dmL3NnZjQuaHRtbFxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIGZvciBuYXZpZ2F0aW5nIGFuZCBtYW5pcHVsYXRpbmcgYVxuICogc21hcnRnYW1lXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNtYXJ0Z2FtZSkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHNlcXVlbmNlO1xuXHR2YXIgbm9kZTtcblxuXHR2YXIgU21hcnRnYW1lciA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmluaXQoKTtcblx0fTtcblxuXHRTbWFydGdhbWVyLnByb3RvdHlwZSA9IHtcblx0XHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoc21hcnRnYW1lKSB7XG5cdFx0XHRcdHRoaXMuZ2FtZSA9IHNtYXJ0Z2FtZS5nYW1lVHJlZXNbMF07XG5cdFx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gTG9hZCBhIHNtYXJ0Z2FtZSB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIGxvYWQgbmV3IGdhbWVzIG9yIGFkZCBvbmUgYWZ0ZXJcblx0XHQvLyBpbml0aWFsaXphdGlvbiwgaWYgZGVzaXJlZFxuXHRcdGxvYWQ6IGZ1bmN0aW9uIChuZXdTbWFydGdhbWUpIHtcblx0XHRcdHNtYXJ0Z2FtZSA9IG5ld1NtYXJ0Z2FtZTtcblx0XHRcdHRoaXMuaW5pdCgpO1xuXHRcdH0sXG5cblx0XHQvLyBIYXZpbmcgbXVsdGlwbGUgZ2FtZXMgaW4gYSBjb2xsZWN0aW9uIGlzIG5vdCBjb21tb24sIGJ1dCBpdCdzIHBhcnQgb2Zcblx0XHQvLyB0aGUgc3BlY1xuXHRcdGdhbWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gc21hcnRnYW1lLmdhbWVUcmVlcztcblx0XHR9LFxuXG5cdFx0c2VsZWN0R2FtZTogZnVuY3Rpb24gKGkpIHtcblx0XHRcdGlmIChpIDwgc21hcnRnYW1lLmdhbWVUcmVlcy5sZW5ndGgpIHtcblx0XHRcdFx0dGhpcy5nYW1lID0gc21hcnRnYW1lLmdhbWVUcmVlc1tpXTtcblx0XHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCd0aGUgY29sbGVjdGlvbiBkb2VzblxcJ3QgY29udGFpbiB0aGF0IG1hbnkgZ2FtZXMnKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZXF1ZW5jZSA9IHRoaXMuZ2FtZTtcblx0XHRcdG5vZGUgPSBzZXF1ZW5jZS5ub2Rlc1swXTtcblx0XHRcdHRoaXMucGF0aCA9IHsgbTogMCB9O1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Z2V0U21hcnRnYW1lOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gc21hcnRnYW1lO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gYW55IHZhcmlhdGlvbnMgYXZhaWxhYmxlIGF0IHRoZSBjdXJyZW50IG1vdmVcblx0XHQgKiovXG5cdFx0dmFyaWF0aW9uczogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHNlcXVlbmNlKSB7XG5cdFx0XHRcdHZhciBsb2NhbE5vZGVzID0gc2VxdWVuY2Uubm9kZXM7XG5cdFx0XHRcdHZhciBsb2NhbEluZGV4ID0gKGxvY2FsTm9kZXMpID8gbG9jYWxOb2Rlcy5pbmRleE9mKG5vZGUpIDogbnVsbDtcblxuXHRcdFx0XHRpZiAobG9jYWxOb2Rlcykge1xuXHRcdFx0XHRcdGlmIChsb2NhbEluZGV4ID09PSAobG9jYWxOb2Rlcy5sZW5ndGggLSAxKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNlcXVlbmNlLnNlcXVlbmNlcyB8fCBbXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBHbyB0byB0aGUgbmV4dCBtb3ZlXG5cdFx0ICoqL1xuXHRcdG5leHQ6IGZ1bmN0aW9uICh2YXJpYXRpb24pIHtcblx0XHRcdHZhcmlhdGlvbiA9IHZhcmlhdGlvbiB8fCAwO1xuXG5cdFx0XHR2YXIgbG9jYWxOb2RlcyA9IHNlcXVlbmNlLm5vZGVzO1xuXHRcdFx0dmFyIGxvY2FsSW5kZXggPSAobG9jYWxOb2RlcykgPyBsb2NhbE5vZGVzLmluZGV4T2Yobm9kZSkgOiBudWxsO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSBhcmUgbm8gYWRkaXRpb25hbCBub2RlcyBpbiB0aGlzIHNlcXVlbmNlLFxuXHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBvbmVcblx0XHRcdGlmIChsb2NhbEluZGV4ID09PSBudWxsIHx8IGxvY2FsSW5kZXggPj0gKGxvY2FsTm9kZXMubGVuZ3RoIC0gMSkpIHtcblx0XHRcdFx0aWYgKHNlcXVlbmNlLnNlcXVlbmNlcykge1xuXHRcdFx0XHRcdGlmIChzZXF1ZW5jZS5zZXF1ZW5jZXNbdmFyaWF0aW9uXSkge1xuXHRcdFx0XHRcdFx0c2VxdWVuY2UgPSBzZXF1ZW5jZS5zZXF1ZW5jZXNbdmFyaWF0aW9uXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VxdWVuY2UgPSBzZXF1ZW5jZS5zZXF1ZW5jZXNbMF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bm9kZSA9IHNlcXVlbmNlLm5vZGVzWzBdO1xuXG5cdFx0XHRcdFx0Ly8gTm90ZSB0aGUgZm9yayBjaG9zZW4gZm9yIHRoaXMgdmFyaWF0aW9uIGluIHRoZSBwYXRoXG5cdFx0XHRcdFx0dGhpcy5wYXRoW3RoaXMucGF0aC5tXSA9IHZhcmlhdGlvbjtcblx0XHRcdFx0XHR0aGlzLnBhdGgubSArPSAxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEVuZCBvZiBzZXF1ZW5jZSAvIGdhbWVcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZSA9IGxvY2FsTm9kZXNbbG9jYWxJbmRleCArIDFdO1xuXHRcdFx0XHR0aGlzLnBhdGgubSArPSAxO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogR28gdG8gdGhlIHByZXZpb3VzIG1vdmVcblx0XHQgKiovXG5cdFx0cHJldmlvdXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBsb2NhbE5vZGVzID0gc2VxdWVuY2Uubm9kZXM7XG5cdFx0XHR2YXIgbG9jYWxJbmRleCA9IChsb2NhbE5vZGVzKSA/IGxvY2FsTm9kZXMuaW5kZXhPZihub2RlKSA6IG51bGw7XG5cblx0XHRcdC8vIERlbGV0ZSBhbnkgdmFyaWF0aW9uIGZvcmtzIGF0IHRoaXMgcG9pbnRcblx0XHRcdC8vIFRPRE86IE1ha2UgdGhpcyBjb25maWd1cmFibGUuLi4gd2Ugc2hvdWxkIGtlZXAgdGhpcyBpZiB3ZSdyZVxuXHRcdFx0Ly8gcmVtZW1iZXJpbmcgY2hvc2VuIHBhdGhzXG5cdFx0XHRkZWxldGUgdGhpcy5wYXRoW3RoaXMucGF0aC5tXTtcblxuXHRcdFx0aWYgKCFsb2NhbEluZGV4IHx8IGxvY2FsSW5kZXggPT09IDApIHtcblx0XHRcdFx0aWYgKHNlcXVlbmNlLnBhcmVudCAmJiAhc2VxdWVuY2UucGFyZW50LmdhbWVUcmVlcykge1xuXHRcdFx0XHRcdHNlcXVlbmNlID0gc2VxdWVuY2UucGFyZW50O1xuXHRcdFx0XHRcdGlmIChzZXF1ZW5jZS5ub2Rlcykge1xuXHRcdFx0XHRcdFx0bm9kZSA9IHNlcXVlbmNlLm5vZGVzW3NlcXVlbmNlLm5vZGVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdFx0dGhpcy5wYXRoLm0gLT0gMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bm9kZSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEFscmVhZHkgYXQgdGhlIGJlZ2lubmluZ1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlID0gbG9jYWxOb2Rlc1tsb2NhbEluZGV4IC0gMV07XG5cdFx0XHRcdHRoaXMucGF0aC5tIC09IDE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHQvLyBHbyB0byB0aGUgbGFzdCBtb3ZlIG9mIHRoZSBnYW1lXG5cdFx0bGFzdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHRvdGFsTW92ZXMgPSB0aGlzLnRvdGFsTW92ZXMoKTtcblxuXHRcdFx0d2hpbGUodGhpcy5wYXRoLm0gPCB0b3RhbE1vdmVzKSB7XG5cdFx0XHRcdHRoaXMubmV4dCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Ly8gR28gdG8gdGhlIGZpcnN0IG1vdmUgb2YgdGhlIGdhbWVcblx0XHRmaXJzdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEdvIHRvIGEgcGFydGljdWxhciBtb3ZlLCBzcGVjaWZpZWQgYXMgYVxuXHRcdCAqIGEpIG51bWJlclxuXHRcdCAqIGIpIHBhdGggc3RyaW5nXG5cdFx0ICogYykgcGF0aCBvYmplY3Rcblx0XHQgKiovXG5cdFx0Z29UbzogZnVuY3Rpb24gKHBhdGgpIHtcblx0XHRcdGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cGF0aCA9IHRoaXMucGF0aFRyYW5zZm9ybShwYXRoLCAnb2JqZWN0Jyk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRwYXRoID0geyBtOiBwYXRoIH07XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMucmVzZXQoKTtcblxuXHRcdFx0dmFyIG4gPSBub2RlO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubSAmJiBuOyBpICs9IDEpIHtcblx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGEgdmFyaWF0aW9uIGluIHRoZSBwYXRoIGZvciB0aGUgdXBjb21pbmcgbW92ZVxuXHRcdFx0XHR2YXIgdmFyaWF0aW9uID0gcGF0aFtpICsgMV0gfHwgMDtcblx0XHRcdFx0biA9IHRoaXMubmV4dCh2YXJpYXRpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Z2V0R2FtZUluZm86IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdhbWUubm9kZXNbMF07XG5cdFx0fSxcblxuXHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgbm9kZVxuXHRcdG5vZGU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH0sXG5cblx0XHQvLyBHZXQgdGhlIHRvdGFsIG51bWJlciBvZiBtb3ZlcyBpbiBhIGdhbWVcblx0XHR0b3RhbE1vdmVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgbG9jYWxTZXF1ZW5jZSA9IHRoaXMuZ2FtZTtcblx0XHRcdHZhciBtb3ZlcyA9IDA7XG5cdFx0XHR3aGlsZShsb2NhbFNlcXVlbmNlKSB7XG5cdFx0XHRcdG1vdmVzICs9IGxvY2FsU2VxdWVuY2Uubm9kZXMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmIChsb2NhbFNlcXVlbmNlLnNlcXVlbmNlcykge1xuXHRcdFx0XHRcdGxvY2FsU2VxdWVuY2UgPSBsb2NhbFNlcXVlbmNlLnNlcXVlbmNlc1swXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsb2NhbFNlcXVlbmNlID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUT0RPOiBSaWdodCBub3cgd2UncmUgKmFzc3VtaW5nKiB0aGF0IHRoZSByb290IG5vZGUgZG9lc24ndCBoYXZlIGFcblx0XHRcdC8vIG1vdmUgaW4gaXQsIHdoaWNoIGlzICpyZWNvbW1lbmRlZCogYnV0IG5vdCByZXF1aXJlZCBwcmFjdGljZS5cblx0XHRcdC8vIEBzZWUgaHR0cDovL3d3dy5yZWQtYmVhbi5jb20vc2dmL3NnZjQuaHRtbFxuXHRcdFx0Ly8gXCJOb3RlOiBpdCdzIGJhZCBzdHlsZSB0byBoYXZlIG1vdmUgcHJvcGVydGllcyBpbiByb290IG5vZGVzLlxuXHRcdFx0Ly8gKGl0IGlzbid0IGZvcmJpZGRlbiB0aG91Z2gpXCJcblx0XHRcdHJldHVybiBtb3ZlcyAtIDE7XG5cdFx0fSxcblxuXHRcdC8vIEdldCBvciBzZXQgYSBjb21tZW50IG9uIHRoZSBjdXJyZW50IG5vZGVcblx0XHQvLyBAc2VlIGh0dHA6Ly93d3cucmVkLWJlYW4uY29tL3NnZi9zZ2Y0Lmh0bWwjdGV4dFxuXHRcdGNvbW1lbnQ6IGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHRpZiAodHlwZW9mIHRleHQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdC8vIFVuZXNjYXBlIGNoYXJhY3RlcnNcblx0XHRcdFx0aWYgKG5vZGUuQykge1xuXHRcdFx0XHRcdHJldHVybiBub2RlLkMucmVwbGFjZSgvXFxcXChbXFxcXDpcXF1dKS9nLCAnJDEnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEVzY2FwZSBjaGFyYWN0ZXJzXG5cdFx0XHRcdG5vZGUuQyA9IHRleHQucmVwbGFjZSgvW1xcXFw6XFxdXS9nLCAnXFxcXCQmJyk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyYW5zbGF0ZSBhbHBoYSBjb29yZGluYXRlcyBpbnRvIGFuIGFycmF5XG5cdFx0ICogQHBhcmFtIHN0cmluZyBhbHBoYUNvb3JkaW5hdGVzXG5cdFx0ICogQHJldHVybiBhcnJheSBbeCwgeV1cblx0XHQgKiovXG5cdFx0dHJhbnNsYXRlQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uIChhbHBoYUNvb3JkaW5hdGVzKSB7XG5cdFx0XHR2YXIgY29vcmRpbmF0ZUxhYmVscyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG5cdFx0XHR2YXIgaW50ZXJzZWN0aW9uID0gW107XG5cblx0XHRcdGludGVyc2VjdGlvblswXSA9IGNvb3JkaW5hdGVMYWJlbHMuaW5kZXhPZihhbHBoYUNvb3JkaW5hdGVzLnN1YnN0cmluZygwLCAxKSk7XG5cdFx0XHRpbnRlcnNlY3Rpb25bMV0gPSBjb29yZGluYXRlTGFiZWxzLmluZGV4T2YoYWxwaGFDb29yZGluYXRlcy5zdWJzdHJpbmcoMSwgMikpO1xuXG5cdFx0XHRyZXR1cm4gaW50ZXJzZWN0aW9uO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDb252ZXJ0IHBhdGggb2JqZWN0cyB0byBzdHJpbmdzIGFuZCBwYXRoIHN0cmluZ3MgdG8gb2JqZWN0c1xuXHRcdCAqKi9cblx0XHRwYXRoVHJhbnNmb3JtOiBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dFR5cGUsIHZlcmJvc2UpIHtcblx0XHRcdHZhciBvdXRwdXQ7XG5cblx0XHRcdC8vIElmIG5vIG91dHB1dCB0eXBlIGhhcyBiZWVuIHNwZWNpZmllZCwgdHJ5IHRvIHNldCBpdCB0byB0aGVcblx0XHRcdC8vIG9wcG9zaXRlIG9mIHRoZSBpbnB1dFxuXHRcdFx0aWYgKHR5cGVvZiBvdXRwdXRUeXBlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRvdXRwdXRUeXBlID0gKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpID8gJ29iamVjdCcgOiAnc3RyaW5nJztcblx0XHRcdH1cblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUdXJuIGEgcGF0aCBvYmplY3QgaW50byBhIHN0cmluZy5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gc3RyaW5naWZ5KGlucHV0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGlucHV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFpbnB1dCkge1xuXHRcdFx0XHRcdHJldHVybiAnJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dCA9IGlucHV0Lm07XG5cblx0XHRcdFx0dmFyIHZhcmlhdGlvbnMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGlucHV0KSB7XG5cdFx0XHRcdFx0aWYgKGlucHV0Lmhhc093blByb3BlcnR5KGtleSkgJiYga2V5ICE9PSAnbScpIHtcblx0XHRcdFx0XHRcdC8vIE9ubHkgc2hvdyB2YXJpYXRpb25zIHRoYXQgYXJlIG5vdCB0aGUgcHJpbWFyeSBvbmUsIHNpbmNlXG5cdFx0XHRcdFx0XHQvLyBwcmltYXJ5IHZhcmlhdGlvbnMgYXJlIGNob3NlbiBieSBkZWZhdWx0XG5cdFx0XHRcdFx0XHRpZiAoaW5wdXRba2V5XSA+IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZlcmJvc2UpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXJpYXRpb25zLnB1c2goJywgdmFyaWF0aW9uICcgKyBpbnB1dFtrZXldICsgJyBhdCBtb3ZlICcgKyBrZXkpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHZhcmlhdGlvbnMucHVzaCgnLScgKyBrZXkgKyAnOicgKyBpbnB1dFtrZXldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dCArPSB2YXJpYXRpb25zLmpvaW4oJycpO1xuXHRcdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFR1cm4gYSBwYXRoIHN0cmluZyBpbnRvIGFuIG9iamVjdC5cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRpbnB1dCA9IHN0cmluZ2lmeShpbnB1dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWlucHV0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbTogMCB9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHBhdGggPSBpbnB1dC5zcGxpdCgnLScpO1xuXHRcdFx0XHRvdXRwdXQgPSB7XG5cdFx0XHRcdFx0bTogTnVtYmVyKHBhdGguc2hpZnQoKSlcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRpZiAocGF0aC5sZW5ndGgpIHtcblx0XHRcdFx0XHRwYXRoLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhdGlvbiwgaSkge1xuXHRcdFx0XHRcdFx0dmFyaWF0aW9uID0gdmFyaWF0aW9uLnNwbGl0KCc6Jyk7XG5cdFx0XHRcdFx0XHRvdXRwdXRbTnVtYmVyKHZhcmlhdGlvblswXSldID0gcGFyc2VJbnQodmFyaWF0aW9uWzFdLCAxMCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3V0cHV0VHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0b3V0cHV0ID0gc3RyaW5naWZ5KGlucHV0KTtcblx0XHRcdH0gZWxzZSBpZiAob3V0cHV0VHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0b3V0cHV0ID0gcGFyc2UoaW5wdXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0ID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gbmV3IFNtYXJ0Z2FtZXIoKTtcbn07XG4iLCLvu78vKiBnbG9iYWxzIG1vZHVsZTogZmFsc2UsIHJlcXVpcmU6IGZhbHNlXHJcblxyXG4qL1xyXG4vKipcclxuICogUHJvdmlkZXMgYSBmdW5jdGlvbiBmb3IgdHJhbnNmb3JtaW5nIFNHRiBmb3IgYSBHbyB2YXJpYW50IHRvIFNHRiBmb3IgYSBzdGFuZGFyZCBHbyB2aWV3ZXI7IGFsc28gcHJvdmlkZXMgYSBmdW5jdGlvbiBmb3IgdGhlIGludmVyc2UgdHJhbnNmb3JtYXRpb24uXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz1dIERlZmluZXMgdmFyaW91cyBvcHRpb25zIGZvciB0aGUgb3V0cHV0IFNHRi4gTWF5IGJlIG9taXR0ZWQsIGluIHdoaWNoIGNhc2UgdGhlIGRlZmF1bHQgb3B0aW9ucyAoc2VlIGJlbG93KSBhcmUgdXNlZC5cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hZGRDb21tZW50cyA9IGZhbHNlXSBXaGVuIGZsYWdnZWQsIGNvbW1lbnRzIGFyZSBhZGRlZCB0byBlYWNoIG5vZGUgZ2l2aW5nIHRoZSBtb3ZlIG51bWJlciBhbmQgdGhlIG51bWJlciBvZiBzdG9uZXMgY2FwdHVyZWQgYnkgQmxhY2sgYW5kIFdoaXRlLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmFkZE1vdmVOdW1iZXIgPSBmYWxzZV0gV2hlbiBmbGFnZ2VkLCBgTU5bPG1vdmVOdW1iZXI+XWAgaXMgYWRkZWQgdG8gZWFjaCBub2RlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubW92ZVR5cGUgPSAyXSBDb250cm9scyBob3cgbW92ZXMgYXJlIHJlcHJlc2VudGVkIGluIHRoZSB0cmFuc2Zvcm1lZCBTR0YuIEV4YW1wbGVzIGdpdmVuIGZvciBibGFjayBtb3Zlcywgc28gd2l0aCBvcHRpb24gMiBhIHdoaXRlIG1vdmUgaXMgcmVwcmVzZW50ZWQgYnkgYFdbcG9pbnRdQVdbb3RoZXJQb2ludHNdYC4gT3B0aW9uczogXHJcbiAqIFxyXG4gKiAtIDA6IGBBQltwb2ludHNdYDtcclxuICogXHJcbiAqIC0gMTogYEFCW3BvaW50c11CW11gIChzYW1lIGFzIGZvciBgbW92ZVR5cGU9PT0wYCBidXQgd2l0aCB0aGUg4oCccGFzc+KAnSAo4oCcQltd4oCdKTtcclxuICogXHJcbiAqIC0gMjogYEJbcG9pbnRdQUJbb3RoZXJQb2ludHNdYCB3aGVyZSBgcG9pbnRgIGlzIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbW92ZSBpbiB0aGUgbWFpbiBib2FyZCAoYSBzaW5nbGUgcG9pbnQpLCBhbmQgYG90aGVyUG9pbnRzYCBpcyBhbiBhcnJheSBvZiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIG1vdmUgaW4gdGhlIHdyYXBhcm91bmQgYXJlYS47XHJcbiAqIFxyXG4gKiAtIDM6IGBCW3BvaW50c11gO1xyXG4gKiBcclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmtMYXN0TW92ZSA9IG51bGxdIEdpdmVzIHRoZSBTR0YgYXR0cmlidXRlIHRvIGJlIGNyZWF0ZWQgdG8gbWFyayBlYWNoIG1vdmUuIE1heSBiZSBsZWZ0IGVtcHR5L251bGwvdW5kZWZpbmVkLiBPciBlbHNlIGEgdmFsdWUgbGlrZSBgXCJDUlwiYC5cclxuICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuYm9hcmREaW1lbnNpb25zID0gWzExLCAxMV1dIE1heSBiZSB1c2VkIGZvciByZWN0YW5ndWxhciB0LUdvLiBTaG91bGQgYmUgb21taXR0ZWQgZm9yIFtuLCBuXSB0LUdvLCB3aGVyZSBuIGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgU0dGIChAcGFyYW0gdmFyaWFudFNnZikuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb29yZGluYXRlc1R5cGUgPSAwXSBPcHRpb25zOiBcclxuICogXHJcbiAqIC0gMDogbm9uZTtcclxuICogXHJcbiAqIC0gMTogKOKGkuKGkTtBfDEtS3wxMSk6IFdlc3Rlcm47XHJcbiAqIFxyXG4gKiAtIDI6ICjihpLihpE7QXwxLUx8MTEpOiBXZXN0ZXJuLCBubyDigJxJ4oCdO1xyXG4gKiBcclxuICogLSAzOiAo4oaS4oaTOzF8MS0xMXwxMSk6IExhdGluL0xhdGluLCB0b3AgdG8gYm90dG9tO1xyXG4gKiBcclxuICogLSA0OiAo4oaS4oaTOzF8MS0xMXzljYHkuIApOiBMYXRpbi9DaGluZXNlLCB0b3AgdG8gYm90dG9tO1xyXG4gKiBcclxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndyYXBhcm91bmRNYXJrZXJzVHlwZSA9IDFdIE9wdGlvbnM6XHJcbiAqIFxyXG4gKiAtIDA6IG5vbmU7XHJcbiAqIFxyXG4gKiAtIDE6IEZ1bGwgb3V0bGluZSwgdXNpbmcgdW5pY29kZSBCb3ggRHJhd2luZyBzeW1ib2xzO1xyXG4gKiBcclxuICogLSAyOiBjb3JuZXJzIGFuZCBtaWRkbGVzLCB1c2luZyB1bmljb2RlIEJveCBEcmF3aW5nIHN5bWJvbHM7XHJcbiAqIFxyXG4gKiAtIDM6IGp1c3QgY29ybmVycywgdXNpbmcgdW5pY29kZSBCb3ggRHJhd2luZyBzeW1ib2xzO1xyXG4gKiBcclxuICogLSA0OiBqdXN0IG1pZGRsZXMsIHVzaW5nIHVuaWNvZGUgQm94IERyYXdpbmcgc3ltYm9scztcclxuICogXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3M9XSBGdXJ0aGVyIG9wdGlvbmFsIHNldHRpbmdzIGZvciBob3cgdGhlICh0b3JvaWRhbCwgb3Igb3RoZXIgc29ydCBvZikgYm9hcmQgaXMgcHJvamVjdGVkIHRvIGEgZmxhdCBncmlkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLndyYXBhcm91bmQgPSA0XSAgTnVtYmVyIG9mIGxpbmVzIHRvIGFkZCBmb3IgdGhlIOKAnHdyYXBhcm91bmTigJ0uXHJcbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXQgPSBbMCwwXV0gIFRyYW5zbGF0aW9uIHRvIGFwcGx5IHRvIGFsbCBtb3Zlcy5cclxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFuc2Zvcm1Ub1N0cmluZz10cnVlXSBXaGVuIHNldCB0byBmYWxzZSwgdGhlIG91dHB1dCBpcyBhbiBvYmplY3QgKGFuIGluc3RhbmNlIG9mIGEgU21hcnRnYW1lKS5cclxuICogQHB1YmxpY1xyXG4gKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCBleHBvc2luZyBmdW5jdGlvbnMgZm9yIGdvaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gU0dGIGZvciBhIHN0YW5kYXJkIHZpZXdlciwgYW5kIFNHRiBmb3IgYSBnYW1lIG9mIHRvcm9pZGFsIEdvXHJcbiAqLy8qdG9kb3M6XHJcbm9waW9ucy5wbGFjZXNUb0NvdW50IERlZmF1bHQ6IHVuZGVmaW5lZC4gTWF5IGJlOiAnbGFzdCd8W2NvdW50SW5mbzEsIC4uIGNvdW50SW5mbzFdLiBjb3VudEluZm8gaXMgYSBwYXRoIHBsdXMgYW4gYXJyYXkgd2l0aCBhIHBvaW50IGZvciBlYWNoIGNoYWluIHRvIGJlIGNvbnNpZGVyZWQgYXMgZGVhZC4ge3BhdGgsIGRlYWRDaGFpbnM6IFsuLi5dfVxyXG5vcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5yb3RhdGlvbiB7aW50ZWdlcn0gRGVmYXVsdCB2YWx1ZTogMC4gQWxsb3dlZCB2YWx1ZXM6IDAgLi4gM1xyXG5vcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5ub3JtYWxpemVQbGFjZSBhcnJheSwgb3Igb25lIG9mOiBDLCBUTCBUUiBCTCBCUiAoY2VudHJlLCB0b3AgbGVmdCwgdG9wIHJpZ2h0LCBib3R0b20gbGVmdCwgYm90dG9tIHJpZ2h0KVxyXG5vcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5ub3JtYWxpemUge2Jvb2xlYW59IFxyXG5cclxuKi9cclxuZnVuY3Rpb24gdHJhbnNmb3JtZXIob3B0aW9uc1xyXG4pIHtcclxuXHQndXNlIHN0cmljdCc7XHJcblx0Y29uc3RcclxuXHRcdF9mbGF0dGVuID0gcmVxdWlyZSgnbG9kYXNoL2ZsYXR0ZW4nKVxyXG5cdFx0LCBfdW5pcUJ5ID0gcmVxdWlyZSgnbG9kYXNoL3VuaXFCeScpXHJcblx0XHQsIF9maSA9IHJlcXVpcmUoJ2xvZGFzaC9maW5kSW5kZXgnKVxyXG5cdFx0LCBtb2R1bG8gPSAoeCwgeSkgPT4gKHggJSB5ICsgeSkgJSB5XHJcblx0XHQsIHNvdXJjZVNnZk1lc3NhZ2UgPSAnc291cmNlIHNnZiBmb3IgdG9yb2lkYWwgR28gaGFzIGJlZW4gYWRhcHRlZCBieSBnby12YXJpYW50cy10cmFuc2Zvcm1lciBzbyBhcyB0byBiZSByZW5kZXJlZCBieSBhbnkgc3RhbmRhcmQgR28gYXBwbGljYXRpb24nXHJcblx0b3B0aW9ucyA9IHtcclxuXHRcdGJvYXJkRGltZW5zaW9uczogWzExLCAxMV1cclxuXHRcdCwgdHJhbnNmb3JtVG9TdHJpbmc6IHRydWVcclxuXHRcdCwgYWRkQ29tbWVudHM6IHRydWVcclxuXHRcdCwgY29vcmRpbmF0ZXNUeXBlOiAwXHJcblx0XHQsIHdyYXBhcm91bmRNYXJrZXJzVHlwZTogMVxyXG5cdFx0LCBtb3ZlVHlwZTogMlxyXG5cdFx0LCBtYXJrTGFzdE1vdmU6IG51bGxcclxuXHRcdC8vYWJvdmUgYXJlIHRoZSBkZWZhdWx0c1xyXG5cdFx0LCAuLi5vcHRpb25zXHJcblx0fVxyXG5cdG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzID1cclxuXHRcdHtcclxuXHRcdFx0d3JhcGFyb3VuZDogNCxcclxuXHRcdFx0b2Zmc2V0OiBbMCwgMF0sXHJcblx0XHRcdC4uLm9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzXHJcblx0XHR9XHJcblxyXG5cdGlmIChvcHRpb25zLmFkZFBhc3NlcyA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0b3B0aW9ucy5hZGRQYXNzZXMgPSB0cnVlO1xyXG5cclxuXHRvcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zIHx8IFsxMSwgMTFdXHJcblxyXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybVRvU3RyaW5nID09PSB1bmRlZmluZWQpXHJcblx0XHRvcHRpb25zLnRyYW5zZm9ybVRvU3RyaW5nID0gdHJ1ZTtcclxuXHJcblx0aWYgKG9wdGlvbnMuYWRkQ29tbWVudHMgPT09IHVuZGVmaW5lZClcclxuXHRcdG9wdGlvbnMuYWRkQ29tbWVudHMgPSB0cnVlO1xyXG5cdC8vIG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzID0gXHJcblxyXG5cdGxldCB3cmFwYXJvdW5kID0gb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mud3JhcGFyb3VuZFxyXG5cclxuXHRsZXQgJCA9IHt9XHJcblx0XHQvLyAsIF9tYXJrZXJzRm9yV3JhcGFyb3VuZCA9IG51bGxcclxuXHRcdCwgY29vcmRpbmF0ZUxhYmVscyA9IGZ1bmN0aW9uIChpKSB7XHJcblx0XHRcdC8vIDk3Li4xMjIgYW5kIDY1Li45MFxyXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShpIDwgMjYgPyBpICsgOTcgOiBpICsgMzkpXHJcblx0XHRcdC8vNjUgLSAyNiA9XHJcblx0XHR9XHJcblx0XHQsXHJcblx0XHR0cmFuc2xhdGVDb29yZGluYXRlID0gKGMpID0+IHtcclxuXHRcdFx0bGV0IHIgPSBjLmNoYXJDb2RlQXQoMClcclxuXHRcdFx0cmV0dXJuIHIgPj0gOTcgPyByIC0gOTcgOiByIC0gMjZcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIFRyYW5zbGF0ZSBhbHBoYSBjb29yZGluYXRlcyBpbnRvIGFuIGFycmF5XHJcblx0XHQgKiBAcGFyYW0gc3RyaW5nIGFscGhhQ29vcmRpbmF0ZXNcclxuXHRcdCAqIEByZXR1cm4gYXJyYXkgW3gsIHldXHJcblx0XHQgKiovXHJcblx0XHR0cmFuc2xhdGVDb29yZGluYXRlcyA9IChhbHBoYUNvb3JkaW5hdGVzKSA9PiB7XHJcblx0XHRcdHJldHVybiBbdHJhbnNsYXRlQ29vcmRpbmF0ZShhbHBoYUNvb3JkaW5hdGVzLnN1YnN0cmluZygwLCAxKSlcclxuXHRcdFx0XHQsIHRyYW5zbGF0ZUNvb3JkaW5hdGUoYWxwaGFDb29yZGluYXRlcy5zdWJzdHJpbmcoMSwgMikpXVxyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdCQuY29vcmRpbmF0ZUxhYmVscyA9IGNvb3JkaW5hdGVMYWJlbHNcclxuXHQkLnRyYW5zbGF0ZUNvb3JkaW5hdGVzID0gdHJhbnNsYXRlQ29vcmRpbmF0ZXNcclxuXHQvKipcclxuXHQgKiBAcHVibGljXHJcblx0ICovXHJcblx0JC5vcHRpb25zID0gb3B0aW9uc1xyXG5cclxuXHQkLnByb2plY3RPbkxpbmUgPSBmdW5jdGlvbiAoYSwgaXNWZXJ0aWNhbCkge1xyXG5cdFx0LypcclxuXHRcdG06IGJvYXJkRGltZW5zaW9uc1swXSA6IDExXHJcblx0XHRuOiB3cmFwYXJvdW5kIDogNFxyXG5cdFx0bGluZTogMCwuLi4sKG0tMSlcclxuXHRcdD0+XHJcblx0XHQwLC4uLiwobi0xKSwgKHN0YXJ0IGxpbmUpIG4sIC4uLiAsIChuICsgbSAtIDEpIGVuZCBsaW5lLCAgKG4rbSksIC4uLiAsICgybiArIG0gLSAxKVxyXG5cclxuXHRcdGNvb3JkaW5hdGUgYSDiiIggezAgLi4gbS0xfSBwcm9qZWN0cyB0byBuICsgYSBpbiBtYWluIGFyZWFcclxuXHRcdGFsbCBwcm9qZWN0aW9ucyBhcmUgb2YgdGhlIGZvcm0gbiArIGEgKyB4bSwgeCDiiIgg4oSkIHMudC4gMCDiiaQgbiArIGEgKyB4bSDiiaQgMm4gKyBtIC0xXHJcblx0XHQteG0g4omkIG4gKyBhXHJcblx0XHRcdHNtYWxsZXN0IHN1Y2ggeCA8IDAgaXMgY2VpbCgtKG4rYSkvbSlcclxuXHRcdCB4bSDiiaQgbiArIG0gLSAxIC1hXHJcblx0XHRcdGxhcmdlc3Qgc3VjaCB4IGlzIGZsb29yKChuICsgbSAtIDEgLWEpIC8gbSlcclxuXHJcblxyXG5cdFx0Ki9cclxuXHJcblx0XHRjb25zdCBtIC8vPSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXVxyXG5cdFx0XHQ9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zW2lzVmVydGljYWwgPyAxIDogMF1cclxuXHJcblx0XHRcdCwgciA9IFtdXHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IE1hdGguY2VpbCgtKHdyYXBhcm91bmQgKyBhKSAvIG0pOyBpIDw9ICh3cmFwYXJvdW5kICsgbSAtIDEgLSBhKSAvIG07IGkrKylcclxuXHRcdFx0ci5wdXNoKHdyYXBhcm91bmQgKyBhICsgaSAqIG0pXHJcblxyXG5cdFx0aWYgKG9wdGlvbnMubW92ZVR5cGUgPT09IDIpIHsvL2Vuc3VyZSB0aGUgbGFzdCBpdGVtIGluIHRoZSByZXN1bHQgaXMgdGhlIG9uZSBpbnNpZGUgdGhlIG1haW4gYm9hcmQgYXJlYVxyXG5cdFx0XHRyLnNvcnQoKHgsIHkpID0+IHtcclxuXHRcdFx0XHRpZiAoeCA+PSB3cmFwYXJvdW5kICYmIHggPCB3cmFwYXJvdW5kICsgbSkgcmV0dXJuIDFcclxuXHRcdFx0XHRpZiAoeSA+PSB3cmFwYXJvdW5kICYmIHkgPCB3cmFwYXJvdW5kICsgbSkgcmV0dXJuIC0xXHJcblx0XHRcdFx0cmV0dXJuIDBcclxuXHRcdFx0fSlcclxuXHRcdH1cclxuXHRcdHJldHVybiByXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIGlzIHRoZSBpbnZlcnNlIGZ1bmN0aW9uIHRvIHRoZSBmdW5jdGlvbiDigJxwcm9qZWN0T25GbGF04oCdIOKAkyBhdCBsZWFzdCBpdCBpcyB3aGVuIOKAnG11bHRpcGxl4oCdIGlzIGZhbHNlLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBUaGUgcG9pbnQgb3IgYXJyYXkgb2YgcG9pbnRzIHByb2plY3RlZCBvbnRvIHRoZSBncmlkLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbj1mYWxzZX0gbXVsdGlwbGUgV2hldGhlciB0aGUgYXJndW1lbnQg4oCccG9pbnRz4oCdIGlzIHRoZSBpbWFnZSBvZiBhIHNpbmdsZSBwb2ludCAo4oCcbXVsdGlwbGU9ZmFsc2XigJ0pIG9yIG9mIG11bHRpcGxlIHBvaW50cy5cclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFdoZW4gdGhlIGZsYWcg4oCcbXVsdGlwbGXigJ0gaXMgZmxhZ2dlZCwgcmV0dXJucyBhbiBhcnJheSBvZiBwb2ludHM7IG90aGVyd2lzZSByZXR1cm5zIGEgc2luZ2xlIHBvaW50IChpLmUuIGFuIGFycmF5IG9mIHR3byBpbnRlZ2VycykuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gaW52ZXJzZVByb2plY3RPbkZsYXQocG9pbnRzLCBtdWx0aXBsZSkge1xyXG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHBvaW50c1swXSkpIHBvaW50cyA9IFtwb2ludHNdXHJcblx0XHRpZiAoIW11bHRpcGxlKVxyXG5cdFx0XHRyZXR1cm4gW21vZHVsbyhwb2ludHNbMF1bMF0gLSBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMF0gLSB3cmFwYXJvdW5kLCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXSlcclxuXHRcdFx0XHQsIG1vZHVsbyhwb2ludHNbMF1bMV0gLSBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMV0gLSB3cmFwYXJvdW5kLCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXSldXHJcblx0XHRyZXR1cm4gX3VuaXFCeShwb2ludHMubWFwKHggPT4gaW52ZXJzZVByb2plY3RPbkZsYXQoW3hdKSksICh4KSA9PiBgJHt4WzBdfV8ke3hbMV19YClcclxuXHR9XHJcblx0JC5pbnZlcnNlUHJvamVjdE9uRmxhdCA9IGludmVyc2VQcm9qZWN0T25GbGF0XHJcblxyXG5cdC8qKlxyXG5cdCAqIFByb2plY3RzIGEgcG9pbnQgb24gdGhlIHQtR28gYm9hcmQgdG8gdGhlIGFycmF5IG9mIHBvaW50cyBvbiB0aGUgc3RhbmRhcmQgZ3JpZC9ib2FyZC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBwIFRoZSBwb2ludCBpbiB0aGUgdC1HbyBib2FyZCB0byBiZSBwcm9qZWN0ZWQgb24gdG8gdGhlIGdyaWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIHByb2plY3RPbkZsYXQocCkge1xyXG5cdFx0Y29uc3QgYSA9ICQucHJvamVjdE9uTGluZShwWzBdICsgb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzBdKVxyXG5cdFx0XHQsIGIgPSAkLnByb2plY3RPbkxpbmUocFsxXSArIG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFsxXSwgdHJ1ZSlcclxuXHRcdFx0LCByID0gW11cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcclxuXHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBiLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdHIucHVzaChbYVtpXSwgYltqXV0pXHJcblx0XHRyZXR1cm4gclxyXG5cdH1cclxuXHQkLnByb2plY3RPbkZsYXQgPSBwcm9qZWN0T25GbGF0XHJcblxyXG5cdCQubW9kWCA9ICh4KSA9PiBtb2R1bG8oeCwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0pXHJcblx0JC5tb2RZID0gKHkpID0+IG1vZHVsbyh5LCBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXSlcclxuXHJcblx0bGV0IHNldFVwTWFya2VycyA9ICgpID0+IHtcclxuXHRcdCQud3JhcGFyb3VuZEFuZENvb3JkcyA9IFtdXHJcblxyXG5cdFx0Ly8gJC5nZXRNYXJrZXJzRm9yV3JhcGFyb3VuZCA9IGZ1bmN0aW9uICgpe1xyXG5cdFx0aWYgKG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLndyYXBhcm91bmQgPiAwKSB7XHJcblx0XHRcdGNvbnN0IG0gPSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1swXSxcclxuXHRcdFx0XHRuID0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV1cclxuXHJcblx0XHRcdC8qXHJcblx0XHRcdG06IGJvYXJkRGltZW5zaW9uc1swXSA6IDExXHJcblx0XHRcdHc6IHdyYXBhcm91bmQgOiA0XHJcblx0XHRcdGxpbmU6IDAsLi4uLChtLTEpXHJcblx0XHRcdD0+XHJcblx0XHRcdDAsLi4uLCh3LTEpLCAoc3RhcnQgbGluZSkgdywgLi4uICwgKHcgKyBtIC0gMSkgZW5kIGxpbmUsICh3K20pLCAuLi4gLCAoMncgKyBtIC0gMSlcclxuXHRcdFx0Ki9cclxuXHJcblx0XHRcdGxldCBib2FyZCA9IFtdXHJcblx0XHRcdGlmIChbMSwgMiwgNF0uaW5kZXhPZihvcHRpb25zLndyYXBhcm91bmRNYXJrZXJzVHlwZSkgPiAtMSkge1xyXG5cdFx0XHRcdGxldCBtaWRkbGVzID0gb3B0aW9ucy53cmFwYXJvdW5kTWFya2Vyc1R5cGUgPiAxID9cclxuXHRcdFx0XHRcdFtNYXRoLmZsb29yKChtIC0gMSkgLyAyKSArIDEsIE1hdGguY2VpbCgobSAtIDEpIC8gMikgKyAxLFxyXG5cdFx0XHRcdFx0TWF0aC5mbG9vcigobiAtIDEpIC8gMikgKyAxLCBNYXRoLmNlaWwoKG4gLSAxKSAvIDIpICsgMV1cclxuXHRcdFx0XHRcdDogWy0xLCA5OSwgLTEsIDk5XVxyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDw9IG07IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKGkgPCBtaWRkbGVzWzBdIHx8IGkgPiBtaWRkbGVzWzFdKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsZXQgbGFiZWwgPSAn4pSAJy8vVSsyNTAwIEJveCBEcmF3aW5ncyBMaWdodCBIb3Jpem9udGFsXHJcblxyXG5cdFx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxICsgaSkgKyBjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxKSArIFwiOlwiICsgbGFiZWwpXHJcblx0XHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEgKyBpKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCArIG0pICsgXCI6XCIgKyBsYWJlbClcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPD0gbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAoaSA8IG1pZGRsZXNbMl0gfHwgaSA+IG1pZGRsZXNbM10pIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWVcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxldCBsYWJlbCA9ICfilIInLy91bmljb2RlIHRvb1xyXG5cdFx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxKSArIGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCAtIDEgKyBpKSArIFwiOlwiICsgbGFiZWwpXHJcblx0XHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMod3JhcGFyb3VuZCArIG4pICsgY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSArIGkpICsgXCI6XCIgKyBsYWJlbClcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKFsxLCAyLCAzXS5pbmRleE9mKG9wdGlvbnMud3JhcGFyb3VuZE1hcmtlcnNUeXBlKSA+IC0xKSB7XHJcblx0XHRcdFx0Ly/ilJggIOKUjCAg4pSUIOKUkFxyXG5cdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSkgKyBjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgKyBuKSArIFwiOuKUlFwiKVxyXG5cdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kICsgbSkgKyBjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgKyBuKSArIFwiOuKUmFwiKVxyXG5cdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kIC0gMSkgKyBjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxKSArIFwiOuKUjFwiKVxyXG5cdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyh3cmFwYXJvdW5kICsgbSkgKyBjb29yZGluYXRlTGFiZWxzKHdyYXBhcm91bmQgLSAxKSArIFwiOuKUkFwiKVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5jb29yZGluYXRlc1R5cGUgPiAwICYmIHdyYXBhcm91bmQgPiAxKSB7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCAyICogd3JhcGFyb3VuZCArIG0gLSAxOyBpKyspIHtcclxuXHJcblx0XHRcdFx0XHRsZXQgY29vcmRJbmRleCA9ICQubW9kWCgtb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzBdIC0gd3JhcGFyb3VuZCArIGkpXHJcblxyXG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMuY29vcmRpbmF0ZXNUeXBlID09PSAyICYmIGNvb3JkSW5kZXggPj0gOCkge1xyXG5cdFx0XHRcdFx0XHQvL29taXQgdGhlIEkgLSBoaXN0b3JpY2FsIGNvb3JkaW5hdGVzIGZvciBHby4uLlxyXG5cdFx0XHRcdFx0XHQvL0k6IDl0aCBsZXR0ZXJcclxuXHRcdFx0XHRcdFx0Y29vcmRJbmRleCsrXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsZXQgbGFiZWwgPVxyXG5cdFx0XHRcdFx0XHRvcHRpb25zLmNvb3JkaW5hdGVzVHlwZSA8IDNcclxuXHRcdFx0XHRcdFx0XHQ/IGNvb3JkaW5hdGVMYWJlbHMoY29vcmRJbmRleCkudG9VcHBlckNhc2UoKVxyXG5cdFx0XHRcdFx0XHRcdDogJycgKyAoY29vcmRJbmRleCArIDEpXHJcblx0XHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMoaSkgKyBjb29yZGluYXRlTGFiZWxzKDApICsgXCI6XCIgKyBsYWJlbClcclxuXHRcdFx0XHRcdGJvYXJkLnB1c2goY29vcmRpbmF0ZUxhYmVscyhpKSArIGNvb3JkaW5hdGVMYWJlbHMoMiAqIHdyYXBhcm91bmQgKyBuIC0gMSkgKyBcIjpcIiArIGxhYmVsKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsZXQgY2prTnVtYmVycyA9ICfkuIDkuozkuInlm5vkupTlha3kuIPlhavkuZ0nXHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCAyICogd3JhcGFyb3VuZCArIG4gLSAxOyBpKyspIHtcclxuXHRcdFx0XHRcdC8qXHJcblx0XHRcdFx0XHQwXHRcdC13XHJcblx0XHRcdFx0XHQuLi5cclxuXHRcdFx0XHRcdHctMVx0LTFcclxuXHRcdFx0XHRcdHdcdFx0MFxyXG5cdFx0XHRcdFx0Li4uXHJcblx0XHRcdFx0XHR3ICsgbiAtMVxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0XHQqL1xyXG5cdFx0XHRcdFx0bGV0IGNvb3JkSW5kZXggPVxyXG5cdFx0XHRcdFx0XHRvcHRpb25zLmNvb3JkaW5hdGVzVHlwZSA8IDNcclxuXHRcdFx0XHRcdFx0XHQ/ICQubW9kWShuICsgb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzFdICsgd3JhcGFyb3VuZCAtIGkgLSAxKVxyXG5cdFx0XHRcdFx0XHRcdDogJC5tb2RZKGkgLSB3cmFwYXJvdW5kIC0gb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzFdKVxyXG5cdFx0XHRcdFx0bGV0IGxhYmVsID0gJydcclxuXHRcdFx0XHRcdHN3aXRjaCAob3B0aW9ucy5jb29yZGluYXRlc1R5cGUpIHtcclxuXHRcdFx0XHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdFx0XHRjYXNlIDI6XHJcblx0XHRcdFx0XHRcdGNhc2UgMzpcclxuXHRcdFx0XHRcdFx0XHRsYWJlbCA9ICcnICsgKGNvb3JkSW5kZXggKyAxKVxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHRcdGNhc2UgNDpcclxuXHRcdFx0XHRcdFx0XHRsYWJlbCA9IG1vZHVsbyhjb29yZEluZGV4LCAxMCkgPT09IDkgPyAnJyA6IGNqa051bWJlcnNbbW9kdWxvKGNvb3JkSW5kZXgsIDEwKV1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKGNvb3JkSW5kZXggPiA4KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRsYWJlbCA9IChjb29yZEluZGV4ID4gMTggPyBjamtOdW1iZXJzW01hdGguZmxvb3IoKGNvb3JkSW5kZXggKyAxKSAvIDEwKSAtIDFdIDogJycpICsgJ+WNgScgKyBsYWJlbFxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ym9hcmQucHVzaChjb29yZGluYXRlTGFiZWxzKDApICsgY29vcmRpbmF0ZUxhYmVscyhpKSArIFwiOlwiICsgbGFiZWwpXHJcblx0XHRcdFx0XHRib2FyZC5wdXNoKGNvb3JkaW5hdGVMYWJlbHMoMiAqIHdyYXBhcm91bmQgKyBtIC0gMSkgKyBjb29yZGluYXRlTGFiZWxzKGkpICsgXCI6XCIgKyBsYWJlbClcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCQud3JhcGFyb3VuZEFuZENvb3JkcyA9IGJvYXJkXHJcblx0XHR9XHJcblx0fVxyXG5cdHNldFVwTWFya2VycygpXHJcblxyXG5cclxuXHQkLmNvb3JkczJTdHJpbmcgPVxyXG5cdFx0LyoqXHJcblx0XHQgKiBjb252ZXJ0cyBjb29yZGluYXRlcyB0byBhIHN0cmluZ1xyXG5cdFx0ICovXHJcblx0XHRmdW5jdGlvbiBjb29yZHMyU3RyaW5nKGNvb3Jkcykge1xyXG5cdFx0XHRyZXR1cm4gY29vcmRpbmF0ZUxhYmVscyhjb29yZHNbMF0pICsgY29vcmRpbmF0ZUxhYmVscyhjb29yZHNbMV0pXHJcblx0XHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdvVGhyb3VnaFRyZWUoc3RhdGUpIHtcclxuXHRcdGxldCB7IHdyYXBwZWRHYW1lLCBub2RlLCBwZW5kaW5nLCBjdXJyZW50UGF0aCwgdEdvIH0gPSBzdGF0ZVxyXG5cdFx0XHQsIG5iVmFyaWF0aW9ucyA9IHdyYXBwZWRHYW1lLnZhcmlhdGlvbnMoKS5sZW5ndGhcclxuXHRcdGlmIChjdXJyZW50UGF0aC5tID4gMTAwMCkgdGhyb3cgbmV3IEVycm9yKCdzZWVtIHRvIGJlIHN0dWNrIScpO1xyXG5cdFx0c3RhdGUuaGFzU2libGluZ3MgPSBuYlZhcmlhdGlvbnMgPiAwXHJcblx0XHRpZiAoc3RhdGUuaGFzU2libGluZ3MpIHtcclxuXHRcdFx0Ly8gaWYoY3VycmVudFBhdGhbbV0gPT09IHVuZGVmaW5lZClcclxuXHRcdFx0Ly8gY3VycmVudFBhdGhbbV0gPSAwXHJcblx0XHRcdC8vIGVsc2VcclxuXHRcdFx0Ly8gY3VycmVudFBhdGhbbV0gKz0gMVxyXG5cdFx0XHQvLyBjdXJyZW50UGF0aC5tICs9IDFcclxuXHRcdFx0Zm9yIChsZXQgaSA9IG5iVmFyaWF0aW9ucyAtIDE7IGkgPiAwOyBpLS0pXHJcblx0XHRcdC8vcGlsZSB1cCBpbiB0aGlzIG9yZGVyLCBhcyBpdCdzIEZJTE8gYW5kIHdlIHdhbnQgdGhlIGxhc3QgdmFyaWF0aW9uLCB3aGljaCBtYXkgY29udGFpbiBhIG1vZGUgYWRkZWQgYnkgQ0dvYm9hcmQgdG8gZ28gbGFzdFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0bGV0IHBhdGhGb3JMYXRlciA9IHsgLi4uY3VycmVudFBhdGggfS8vT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudFBhdGgpXHJcblx0XHRcdFx0cGF0aEZvckxhdGVyW2N1cnJlbnRQYXRoLm0gKyAxXSA9IGlcclxuXHRcdFx0XHRwYXRoRm9yTGF0ZXIubSArPSAxXHJcblxyXG5cdFx0XHRcdGlmICh0R28gIT09IHVuZGVmaW5lZClcclxuXHRcdFx0XHRcdHBlbmRpbmcucHVzaCh7IHBhdGg6IHBhdGhGb3JMYXRlciwgdEdvRGF0YTogdEdvLmV4cG9ydERhdGEoKSB9KVxyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHBlbmRpbmcucHVzaCh7IHBhdGg6IHBhdGhGb3JMYXRlciB9KVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0XHRzdGF0ZS5ub2RlID0gd3JhcHBlZEdhbWUubmV4dCgpLm5vZGUoKVxyXG5cdFx0XHRjdXJyZW50UGF0aFtjdXJyZW50UGF0aC5tICsgMV0gPSAwXHJcblx0XHRcdGN1cnJlbnRQYXRoLm0gKz0gMVxyXG5cdFx0XHRyZXR1cm4gc3RhdGUubm9kZVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBuZXh0Tm9kZSA9IHdyYXBwZWRHYW1lLm5leHQoKS5ub2RlKClcclxuXHRcdGlmIChub2RlID09PSBuZXh0Tm9kZSkgey8vYXQgYSBsZWFmOlxyXG5cdFx0XHRpZiAocGVuZGluZy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRzdGF0ZS5ub2RlID0gbnVsbFxyXG5cdFx0XHRcdHJldHVybiBzdGF0ZS5ub2RlLy9maW5pc2hlZFxyXG5cdFx0XHR9XHJcblx0XHRcdGxldCBmcm9tU3RhY2sgPSBwZW5kaW5nLnBvcCgpXHJcblx0XHRcdHN0YXRlLmhhc1NpYmxpbmdzID0gdHJ1ZVxyXG5cdFx0XHQvLyBpZiAoZnJvbVN0YWNrID09PSBudWxsKSB7XHJcblx0XHRcdC8vIFx0bm9kZSA9IG51bGxcclxuXHRcdFx0Ly8gXHRyZXR1cm4vL2ZpbmlzaGVkIVxyXG5cdFx0XHQvLyB9XHJcblx0XHRcdGlmICh0R28gIT09IHVuZGVmaW5lZCkgdEdvLmxvYWREYXRhKGZyb21TdGFjay50R29EYXRhKVxyXG5cdFx0XHRzdGF0ZS5ub2RlID0gd3JhcHBlZEdhbWUuZ29Ubyhmcm9tU3RhY2sucGF0aCkubm9kZSgpXHJcblx0XHRcdHN0YXRlLmN1cnJlbnRQYXRoID0gZnJvbVN0YWNrLnBhdGhcclxuXHRcdFx0cmV0dXJuIHN0YXRlLm5vZGVcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRjdXJyZW50UGF0aC5tICs9IDFcclxuXHRcdFx0c3RhdGUubm9kZSA9IG5leHROb2RlXHJcblx0XHRcdHJldHVybiBzdGF0ZS5ub2RlXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBBcGFydCBmcm9tIGEgZmV3IGRldGFpbHMsIHRoaXMgaXMgYW4gaW52ZXJzZSBvZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uLlxyXG5cdCAqIEBwYXJhbSB7c21hcnRnYW1lfHN0cmluZ30gd3JhcHBlZEdhbWVcclxuXHQgKiBAcGFyYW0ge3NtYXJ0Z2FtZX0gc21hcnRnYW1lXHJcblx0ICogQHB1YmxpY1xyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGludmVyc2VUcmFuc2Zvcm0oXHJcblx0XHR3cmFwcGVkR2FtZSwgc21hcnRnYW1lKSB7XHJcblxyXG5cdFx0aWYgKHNtYXJ0Z2FtZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHNtYXJ0Z2FtZSA9IHJlcXVpcmUoJ3NtYXJ0Z2FtZScpXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB3cmFwcGVkR2FtZSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0bGV0IHNtYXJ0Z2FtZXIgPSByZXF1aXJlKCdzbWFydGdhbWVyJylcclxuXHRcdFx0d3JhcHBlZEdhbWUgPSBzbWFydGdhbWVyKHNtYXJ0Z2FtZS5wYXJzZSh3cmFwcGVkR2FtZSkpXHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IG5vZGUgPSB3cmFwcGVkR2FtZS5maXJzdCgpLm5vZGUoKVxyXG5cdFx0XHQsIHBlbmRpbmcgPSBbXVxyXG5cdFx0XHQsIGN1cnJlbnRQYXRoID0geyBtOiAwIH1cclxuXHRcdFx0LCBjbGVhbmVyUmVnRXggPSAvXlthLXpBLVogOjAtOVxcLShcXHJcXG5dK0dvVmFyaWFudHNUcmFuc2Zvcm1lclxcKS0tW1xcclxcbl0qL1xyXG5cdFx0XHQsIGNsZWFuQ29tbWVudHMgPSAoKSA9PiB7XHJcblx0XHRcdFx0aWYgKG5vZGUuQyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRub2RlLkMgPSBub2RlLkMucmVwbGFjZShjbGVhbmVyUmVnRXgsICcnKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAobm9kZS5DID09PSAnJylcclxuXHRcdFx0XHRcdGRlbGV0ZSBub2RlLkNcclxuXHRcdFx0fVxyXG5cdFx0XHQsXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBGdW5jdGlvbiB0bzpcclxuXHRcdFx0ICogXHQtIHJlbW92ZSB0aGUg4oCcYm9yZGVy4oCdICh1bmljb2RlIHN5bWJvbHMgYWRkZWQgYnkgdGhlIHRyYW5zZm9ybSB0byBpbmRpY2F0ZSB3aGVyZSB0aGUgd3JhcGFyb3VuZCBhcmVhIG1lZXRzIHRoZSBtYWluIGdyaWQpLlxyXG5cdFx0XHQgKiBcdC0gcmVtb3ZlIENNIChjb2xvdXIgbWFwKSBhbmQgQ1QgKGNvbG91ciB0YWJsZSkgd2hpY2ggYXJlIG5vbnN0YW5kYXJkIFNHRiBhZGRlZCBieSBDR29ib2FyZCBmb3IgYmFja2dyb3VuZCBjb2xvdXIgKGNvdWxkIGJlIGludGVyZXN0aW5nIHRvIHVzZSB0aGlzIGZlYXR1cmUgbGF0ZXIgb24pLlxyXG5cdFx0XHQgKi9cclxuXHRcdFx0Y2xlYW5MYWJlbHMgPSAoKSA9PiB7XHJcblxyXG5cdFx0XHRcdGxldCBsYWJlbHMgPSBbXVxyXG5cdFx0XHRcdGlmIChub2RlLkxCICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdGxhYmVscyA9IG5vZGUuTEJcclxuXHRcdFx0XHRcdGlmICghQXJyYXkuaXNBcnJheShsYWJlbHMpKVxyXG5cdFx0XHRcdFx0XHRsYWJlbHMgPSBbbGFiZWxzXVxyXG5cdFx0XHRcdFx0bGFiZWxzID0gbGFiZWxzLmZpbHRlcihpID0+ICEkLndyYXBhcm91bmRBbmRDb29yZHMuaW5jbHVkZXMoaSkpXHJcblx0XHRcdFx0XHQvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cclxuXHRcdFx0XHRcdGxhYmVscyA9XHJcblx0XHRcdFx0XHRcdF91bmlxQnkoXHJcblx0XHRcdFx0XHRcdFx0bGFiZWxzXHJcblx0XHRcdFx0XHRcdFx0XHQubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNwbGl0KCc6JywgMikgfSkvL2Fzc3VtZSB0aGUgbGFiZWwgZG9lc27igJl0IGNvbnRhaW4g4oCcOuKAnVxyXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcCgoeCkgPT4gWyQuY29vcmRzMlN0cmluZygkLmludmVyc2VQcm9qZWN0T25GbGF0KHRyYW5zbGF0ZUNvb3JkaW5hdGVzKHhbMF0pKSksIHhbMV1dKVxyXG5cdFx0XHRcdFx0XHRcdCwgKHgpID0+IHhbMF0pXHJcblx0XHRcdFx0XHRcdFx0Lm1hcCgoeCkgPT4gYCR7eFswXX06JHt4WzFdfWApXHJcblxyXG5cclxuXHRcdFx0XHRcdC8vIGxhYmVscyA9IFtdXHJcblx0XHRcdFx0XHQvLyBmb3IgKGxldCBpID0gMDsgaSA8IGxhYmVsczIubGVuZ3RoOyBpKyspXHJcblx0XHRcdFx0XHQvLyBcdGxhYmVscyA9IGxhYmVscy5jb25jYXQobGFiZWxzMilcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG5vZGUuTEIgPSBsYWJlbHNcclxuXHRcdFx0XHRpZiAobm9kZS5MQi5sZW5ndGggPT09IDApXHJcblx0XHRcdFx0XHRkZWxldGUgbm9kZS5MQlxyXG5cclxuXHRcdFx0XHRpZiAobm9kZS5DTSlcclxuXHRcdFx0XHRcdGRlbGV0ZSBub2RlLkNNXHJcblx0XHRcdFx0aWYgKG5vZGUuQ1QpXHJcblx0XHRcdFx0XHRkZWxldGUgbm9kZS5DVFxyXG5cdFx0XHR9XHJcblxyXG5cdFx0Y2xlYW5MYWJlbHMoKVxyXG5cdFx0bm9kZS5TWiA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdXHJcblx0XHRub2RlLkFQID0gXCJnby12YXJpYW50cy10cmFuc2Zvcm1lclwiXHJcblxyXG5cdFx0aWYgKG5vZGUuU08gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRsZXQgY2xlYW5Tb3VyY2VSZWdleCA9IG5ldyBSZWdFeHAoYCBcXFxcKCR7c291cmNlU2dmTWVzc2FnZX1cXFxcKWApXHJcblx0XHRcdG5vZGUuU08gPSBub2RlLlNPLnJlcGxhY2UoY2xlYW5Tb3VyY2VSZWdleCwgJycpXHJcblx0XHRcdC8vIGlmIChub2RlLlNPID09PSAnJylcclxuXHRcdFx0Ly8gXHRkZWxldGUgbm9kZS5TT1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBzdGF0ZSA9IHtcclxuXHRcdFx0d3JhcHBlZEdhbWUsIG5vZGUsIHBlbmRpbmcsIGN1cnJlbnRQYXRoLCBzaWJsaW5nTW92ZXM6IHt9Ly8sIHBhcmVudHNXaXRoQ2hpbGRUb0RlbGV0ZTogW10gXHJcblx0XHR9XHJcblxyXG5cdFx0bm9kZSA9IGdvVGhyb3VnaFRyZWUoc3RhdGUpXHJcblx0XHR3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xyXG5cdFx0XHRjbGVhbkxhYmVscygpXHJcblx0XHRcdGNsZWFuQ29tbWVudHMoKVxyXG5cclxuXHRcdFx0Y29uc3RcclxuXHRcdFx0XHRpc0JsYWNrID0gbm9kZS5BQiAhPT0gdW5kZWZpbmVkIHx8IG5vZGUuQiAhPT0gdW5kZWZpbmVkXHJcblx0XHRcdFx0LCBhZGRlZFN0b25lcyA9IGlzQmxhY2sgPyBub2RlLkFCIDogbm9kZS5BV1xyXG5cdFx0XHRcdCwgcGxheWVkU3RvbmUgPSBpc0JsYWNrID8gbm9kZS5CIDogbm9kZS5XXHJcblx0XHRcdFx0LCBtb3ZlID0gYWRkZWRTdG9uZXMgPyBhZGRlZFN0b25lcyA6IHBsYXllZFN0b25lXHJcblx0XHRcdFx0LCBtb3ZlQXNBcnJheSA9IEFycmF5LmlzQXJyYXkobW92ZSkgPyBtb3ZlIDogW21vdmVdXHJcblx0XHRcdFx0LCBpc0FQYXNzID0gaXNCbGFjayA/IG5vZGUuQiA9PT0gJycgOiBub2RlLlcgPT09ICcnXHJcblx0XHRcdFx0LCBtb3ZlSGFzQ29vcmRzID0gbW92ZSAhPT0gdW5kZWZpbmVkICYmIG1vdmUgIT09ICcnXHJcblx0XHRcdFx0LCBjb29yZHMgPSAhbW92ZUhhc0Nvb3JkcyA/IHVuZGVmaW5lZCA6ICQuY29vcmRzMlN0cmluZygkLmludmVyc2VQcm9qZWN0T25GbGF0KG1vdmVBc0FycmF5Lm1hcCh0cmFuc2xhdGVDb29yZGluYXRlcykpKVxyXG5cclxuXHRcdFx0Ly9hbHRlciB0aGUgbm9kZVxyXG5cclxuXHRcdFx0LypcclxuXHRcdFx0bG9naWMgcmVtb3ZpbmcgYSBub2RlIGFkZGVkIGJ5IENHb2JvYXJkLCBpZiB0aGVyZSBhbHJlYWR5IGlzIHRoZSBzYW1lIG1vdmUgYXMgQUIgb3IgQVcgaW4gYSBwcmlvciB2YXJpYXRpb247IGFzc3VtaW5nIFxyXG5cdFx0XHR0aGUgdmFyaWF0aW9uIHRvIGJlIHJlbW92ZWQgaXMgdGhlIGxhc3Qgb2YgdGhlIHNpYmxpbmdzIC0gd2hpY2ggZG9lcyBzZWVtIHRvIGJlIHRoZSB3YXkgQ0dvYm9hcmQgYmVoYXZlcyB3aGVuIGEgY2xpY2sgXHJcblx0XHRcdGlzIG1hZGUgb24gYSBwb2ludCB3aGVyZSB0aGUgbmV4dCBub2RlIGlzIEFCIG9yIEFXLiAgXHJcblx0XHRcdCovXHJcblx0XHRcdGlmIChzdGF0ZS5oYXNTaWJsaW5ncykge1xyXG5cdFx0XHRcdGxldCBwYXRoRm9yUGFyZW50ID0geyAuLi53cmFwcGVkR2FtZS5wYXRoIH0gLy9PYmplY3QuYXNzaWduKHt9LCB3cmFwcGVkR2FtZS5wYXRoKVxyXG5cdFx0XHRcdHBhdGhGb3JQYXJlbnQubS0tXHJcblx0XHRcdFx0ZGVsZXRlIHBhdGhGb3JQYXJlbnRbcGF0aEZvclBhcmVudC5tXVxyXG5cdFx0XHRcdHBhdGhGb3JQYXJlbnQgPSB3cmFwcGVkR2FtZS5wYXRoVHJhbnNmb3JtKHBhdGhGb3JQYXJlbnQpXHJcblx0XHRcdFx0Ly8gd3JhcHBlZEdhbWUucHJldmlvdXMoKVxyXG5cdFx0XHRcdGlmIChzdGF0ZS5zaWJsaW5nTW92ZXNbcGF0aEZvclBhcmVudF0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0c3RhdGUuc2libGluZ01vdmVzW3BhdGhGb3JQYXJlbnRdID0gW11cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGFkZGVkU3RvbmVzKSB7XHJcblx0XHRcdFx0XHRzdGF0ZS5zaWJsaW5nTW92ZXNbcGF0aEZvclBhcmVudF0ucHVzaChjb29yZHMpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdGlmIChwbGF5ZWRTdG9uZSAmJiBzdGF0ZS5zaWJsaW5nTW92ZXNbcGF0aEZvclBhcmVudF0uaW5kZXhPZihjb29yZHMpID4gLTEpIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIHN0YXRlLnBhcmVudHNXaXRoQ2hpbGRUb0RlbGV0ZS5wdXNoKHBhdGhGb3JQYXJlbnQpXHJcblx0XHRcdFx0XHRcdG5vZGUuWFggPSBcImludmVyc2VUcmFuc2Zvcm1Ub0RlbGV0ZVwiXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gd3JhcHBlZEdhbWUuZ29UbyhjdXJyZW50UGF0aClcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGVsZXRlIG5vZGVbaXNCbGFjayA/ICdBQicgOiAnQVcnXVxyXG5cdFx0XHRkZWxldGUgbm9kZVtpc0JsYWNrID8gJ0InIDogJ1cnXVxyXG5cdFx0XHRkZWxldGUgbm9kZS5DUlxyXG5cdFx0XHRkZWxldGUgbm9kZS5BRVxyXG5cclxuXHRcdFx0aWYgKGlzQVBhc3MpIHtcclxuXHRcdFx0XHRub2RlW2lzQmxhY2sgPyAnQicgOiAnVyddID0gJydcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKG1vdmVIYXNDb29yZHMpIHtcclxuXHRcdFx0XHRub2RlW2lzQmxhY2sgPyAnQicgOiAnVyddID0gY29vcmRzXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdDsvKm5vdGU6IHRoaXMgbmV4dCBzZW1pY29sb24gaXMgbmVlZGVkISAqL1svLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLXNlbWlcclxuXHRcdFx0XHQvLydDUicsdG9kbzogYWRkIGlmIG5vdCBtYXJraW5nIHRoZSBtb3ZlXHJcblx0XHRcdFx0J0REJywgJ01BJywgJ1NMJywgJ1NRJywgJ1RSJ10uZm9yRWFjaChmdW5jdGlvbiAoc2dmUHJvcGVydHkpIHtcclxuXHRcdFx0XHRcdC8vIF8ubWFwKFsnREQnLCdNQScsJ1NMJywnU1EnLCdUUiddLCBmdW5jdGlvbihzZ2ZQcm9wZXJ0eSl7XHJcblx0XHRcdFx0XHRpZiAobm9kZVtzZ2ZQcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkgcmV0dXJuXHJcblx0XHRcdFx0XHRsZXQgcG9pbnRzID0gW11cclxuXHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG5vZGVbc2dmUHJvcGVydHldKSkge1xyXG5cdFx0XHRcdFx0XHRwb2ludHMgPSBub2RlW3NnZlByb3BlcnR5XVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdHBvaW50cyA9IFtub2RlW3NnZlByb3BlcnR5XV1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHBvaW50cyA9XHJcblx0XHRcdFx0XHRcdCQuaW52ZXJzZVByb2plY3RPbkZsYXQoXHJcblx0XHRcdFx0XHRcdFx0cG9pbnRzLm1hcCh0cmFuc2xhdGVDb29yZGluYXRlcyksIHRydWVcclxuXHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0XHRcdC5tYXAoJC5jb29yZHMyU3RyaW5nKVxyXG5cdFx0XHRcdFx0bm9kZVtzZ2ZQcm9wZXJ0eV0gPSBwb2ludHNcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQvLyBtb3ZlIHRvIG5leHQgbm9kZVxyXG5cdFx0XHRub2RlID0gZ29UaHJvdWdoVHJlZShzdGF0ZSlcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzdGF0ZS5wYXJlbnRzV2l0aENoaWxkVG9EZWxldGUuZm9yRWFjaCgocGF0aCkgPT4ge1xyXG5cdFx0Ly8gXHQvL3JlbW92ZSB0aGUgc2dmIG5vZGVcclxuXHRcdC8vIFx0d3JhcHBlZEdhbWUuZ29UbyhwYXRoKVxyXG5cdFx0Ly8gXHRsZXQgc2VxdWVuY2VzID0gd3JhcHBlZEdhbWUuZ2FtZS5zZXF1ZW5jZXNcclxuXHRcdC8vIFx0bGV0IGluZGV4ID0gX2ZpKHNlcXVlbmNlcywgKHNlcSkgPT4gc2VxLm5vZGVzWzBdLmludmVyc2VUcmFuc2Zvcm1Ub0RlbGV0ZSlcclxuXHRcdC8vIFx0XHQsIHRtcEkgPSAwXHJcblx0XHQvLyBcdHdoaWxlIChpbmRleCA+IC0xKSB7XHJcblx0XHQvLyBcdFx0c2VxdWVuY2VzLnNwbGljZShpbmRleCwgMSlcclxuXHRcdC8vIFx0XHRpbmRleCA9IF9maShzZXF1ZW5jZXMsIChzZXEpID0+IHNlcS5ub2Rlc1swXS5pbnZlcnNlVHJhbnNmb3JtVG9EZWxldGUpXHJcblx0XHQvLyBcdFx0dG1wSSsrXHJcblx0XHQvLyBcdFx0aWYgKHRtcEkgPiAxMDApIHRocm93IG5ldyBFcnJvcignc2VlbSB0byBiZSBzdHVjayEnKTtcclxuXHRcdC8vIFx0fVxyXG5cclxuXHRcdC8vIFx0Ly8gY29uc29sZS5sb2cocGF0aClcclxuXHRcdC8vIH0pXHJcblxyXG5cdFx0bGV0IGRlbGV0ZU5vZGVzID0gKHNlcXVlbmNlKSA9PiB7XHJcblx0XHRcdGlmIChzZXF1ZW5jZS5zZXF1ZW5jZXMpIHtcclxuXHJcblx0XHRcdFx0bGV0XHJcblx0XHRcdFx0XHRzZXF1ZW5jZXMgPSBzZXF1ZW5jZS5zZXF1ZW5jZXNcclxuXHRcdFx0XHRcdCwgaW5kZXggPSBfZmkoc2VxdWVuY2VzLCAoc2VxKSA9PiBzZXEubm9kZXNbMF0uWFggPT09ICdpbnZlcnNlVHJhbnNmb3JtVG9EZWxldGUnKVxyXG5cdFx0XHRcdFx0LCB0bXBJID0gMCwgbWF4ID0gc2VxdWVuY2VzLmxlbmd0aFxyXG5cdFx0XHRcdHdoaWxlIChpbmRleCA+IC0xKSB7XHJcblx0XHRcdFx0XHRzZXF1ZW5jZXMuc3BsaWNlKGluZGV4LCAxKVxyXG5cdFx0XHRcdFx0aW5kZXggPSBfZmkoc2VxdWVuY2VzLCAoc2VxKSA9PiBzZXEubm9kZXNbMF0uWFggPT09ICdpbnZlcnNlVHJhbnNmb3JtVG9EZWxldGUnKVxyXG5cdFx0XHRcdFx0dG1wSSsrXHJcblx0XHRcdFx0XHRpZiAodG1wSSA+IG1heCkgdGhyb3cgbmV3IEVycm9yKCdzZWVtIHRvIGJlIHN0dWNrIScpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRmb3IgKGxldCBpbmRleDIgPSAwOyBpbmRleDIgPCBzZXF1ZW5jZXMubGVuZ3RoOyBpbmRleDIrKykge1xyXG5cdFx0XHRcdFx0Ly8gZGVsZXRlTm9kZXMoc2VxdWVuY2VzW2luZGV4Ml0ubm9kZXNbc2VxdWVuY2VzW2luZGV4Ml0ubm9kZXMubGVuZ3RoIC0gMV0pO1xyXG5cdFx0XHRcdFx0ZGVsZXRlTm9kZXMoc2VxdWVuY2VzW2luZGV4Ml0pO1xyXG5cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZiAoc2VxdWVuY2Uubm9kZXMpXHJcblx0XHRcdFx0ZGVsZXRlTm9kZXMoc2VxdWVuY2Uubm9kZXNbc2VxdWVuY2Uubm9kZXMubGVuZ3RoIC0gMV0pXHJcblx0XHR9XHJcblx0XHRkZWxldGVOb2Rlcyh3cmFwcGVkR2FtZS5nYW1lKVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnRyYW5zZm9ybVRvU3RyaW5nKVxyXG5cdFx0XHRyZXR1cm4gc21hcnRnYW1lLmdlbmVyYXRlKHsgZ2FtZVRyZWVzOiBbd3JhcHBlZEdhbWUuZ2FtZV0gfSk7XHJcblx0XHRlbHNlIHJldHVybiB3cmFwcGVkR2FtZVxyXG5cclxuXHR9XHJcblx0JC5pbnZlcnNlVHJhbnNmb3JtID0gaW52ZXJzZVRyYW5zZm9ybVxyXG5cclxuXHQvKipcclxuXHQgKiBNYWluIGZ1bmN0aW9uOyBjb252ZXJ0cyBTR0YgZm9yIGEgR28gdmFyaWFudCAoc28gZmFyLCBqdXN0IHRvcm9pZGFsIEdvIG9yIHQtR28pLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0U2dmXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRHbyBFbmdpbmUgZm9yIGNvdW50aW5nIGxpYmVydGllcyBpbiB0LUdvLiBBbiBpbnN0YW5jZSBvZiBnby12YXJpYW50cy1lbmdpbmUuXHJcblx0ICogQHBhcmFtIHsqfSBzbWFydGdhbWVcclxuXHQgKiBAcGFyYW0geyp9IHNtYXJ0Z2FtZXJcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfG9iamVjdH0gU0dGIHRoYXQgY2FuIGJlIHZpZXdlZCBpbiBhIHN0YW5kYXJkIFNHRiB2aWV3ZXIuIChTZWUgYG9wdGlvbnMudHJhbnNmb3JtVG9TdHJpbmdgIGZvciB0aGUgZGF0YSB0eXBlIG9mIHRoZSB2YWx1ZSByZXR1cm5lZC4pXHJcblx0ICogQHB1YmxpY1xyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybShcclxuXHRcdHRTZ2YgLy9lZyAxMXgxMSBzZ2YgZnJvbSBMaXR0bGVHb2xlbVxyXG5cdFx0LCB0R28gLy9hcHAgaW1wbGVtZW50aW5nIHQtR29cclxuXHRcdCwgc21hcnRnYW1lXHJcblx0XHQsIHNtYXJ0Z2FtZXIpIHtcclxuXHJcblx0XHRpZiAodEdvID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Ly8gIHRHbyA9IHJlcXVpcmUoJy4uL2Rpc3Qvbm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9zcmMvZW5naW5lLm1pbi5qcycpKHtcclxuXHRcdFx0Ly8gIHRHbyA9IHJlcXVpcmUoJy4uLy4uL2VuZ2luZS9kaXN0L2VuZ2luZS5taW4uanMnKSh7XHJcblx0XHRcdHRHbyA9IHJlcXVpcmUoJ2dvLXZhcmlhbnRzLWVuZ2luZScpKHtcclxuXHRcdFx0XHQvLyB0R28gPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvZ28tdmFyaWFudHMtZW5naW5lL3NyYy9lbmdpbmUnKSh7XHJcblx0XHRcdFx0Ly8gYm9hcmRNb2RlOid0JyxcclxuXHRcdFx0XHRib2FyZERpbWVuc2lvbnM6IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zXHJcblx0XHRcdH0pXHJcblx0XHRcdC8vIHRHbyA9IHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9nby12YXJpYW50cy1lbmdpbmUnKSh7Ym9hcmRNb2RlOid0JywgYm9hcmREaW1lbnNpb25zOm9wdGlvbnMuYm9hcmREaW1lbnNpb25zfSlcclxuXHRcdFx0Ly8gdEdvID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL2dvLXZhcmlhbnRzLWVuZ2luZS9zcmMvZW5naW5lJykoe2JvYXJkTW9kZTondCcsIGJvYXJkRGltZW5zaW9uczpvcHRpb25zLmJvYXJkRGltZW5zaW9uc30pXHJcblx0XHR9XHJcblx0XHQvLyBlbHNlIHtcclxuXHRcdC8vIFx0dEdvLm9wdGlvbnMuYm9hcmREaW1lbnNpb25zID0gb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNcclxuXHRcdC8vIH1cclxuXHJcblx0XHRpZiAoc21hcnRnYW1lID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c21hcnRnYW1lID0gcmVxdWlyZSgnc21hcnRnYW1lJylcclxuXHRcdH1cclxuXHRcdGlmIChzbWFydGdhbWVyID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0c21hcnRnYW1lciA9IHJlcXVpcmUoJ3NtYXJ0Z2FtZXInKVxyXG5cdFx0fVxyXG5cdFx0Ly8gY29uc29sZS5sb2codEdvKVxyXG5cdFx0bGV0IHBhcnNlZCA9IHNtYXJ0Z2FtZS5wYXJzZSh0U2dmKVxyXG5cdFx0XHQsIHdyYXBwZWRHYW1lID0gc21hcnRnYW1lcihwYXJzZWQpXHJcblx0XHRcdCwgbm9kZSA9IHdyYXBwZWRHYW1lLm5vZGUoKVxyXG5cdFx0XHQsIHBhc3NlcyA9IDBcclxuXHRcdFx0LCBwZW5kaW5nID0gW11cclxuXHRcdFx0LCBjdXJyZW50UGF0aCA9IHsgbTogMCB9XHJcblx0XHRpZiAobm9kZS5TWiAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGxldCBzeiA9IE51bWJlcihub2RlLlNaKVxyXG5cdFx0XHQvLyBzeis9IDIqb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mud3JhcGFyb3VuZFxyXG5cdFx0XHRvcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IFtzeiwgc3pdXHJcblx0XHRcdHRHby5vcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zXHJcblx0XHRcdHNldFVwTWFya2VycygpXHJcblx0XHR9XHJcblx0XHRpZiAobm9kZS5LTSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdG9wdGlvbnMucnVsZXMgPSB7IGtvbWk6IHBhcnNlRmxvYXQobm9kZS5LTSksIC4uLm9wdGlvbnMucnVsZXMgfVxyXG5cdFx0fVxyXG5cdFx0bm9kZS5TWiA9IFwiXCIgKyAob3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0gKyAyICogb3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mud3JhcGFyb3VuZCkvL25vdCBzdXJlIGhvdyB0byBtYWtlIGEgcmVjdGFuZ3VsYXIgZ29iYW4hXHJcblx0XHQvL29mZnNldCBtb2R1bG9cclxuXHRcdG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFswXSA9IG1vZHVsbyhvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy5vZmZzZXRbMF0sIG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdKVxyXG5cdFx0b3B0aW9ucy5wcm9qZWN0aW9uU2V0dGluZ3Mub2Zmc2V0WzFdID0gbW9kdWxvKG9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFsxXSwgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMV0pXHJcblx0XHRsZXQgc2V0TGFiZWxzID0gKCkgPT4ge1xyXG5cdFx0XHQvL25vZGUuTEIgPSAkLndyYXBhcm91bmRBbmRDb29yZHNcclxuXHRcdFx0bGV0IGxhYmVscyA9IFtdXHJcblx0XHRcdGlmIChub2RlLkxCICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRsYWJlbHMgPSBub2RlLkxCXHJcblx0XHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpXHJcblx0XHRcdFx0XHRsYWJlbHMgPSBbbGFiZWxzXVxyXG5cclxuXHRcdFx0XHQvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cclxuXHRcdFx0XHRsZXQgbGFiZWxzMiA9IGxhYmVscy8vXy5jaGFpbihsYWJlbHMpXHJcblx0XHRcdFx0XHQubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnNwbGl0KCc6JywgMikgfSkvL2Fzc3VtZSB0aGUgbGFiZWwgZG9lc27igJl0IGNvbnRhaW4g4oCcOuKAnVxyXG5cdFx0XHRcdFx0Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gW3RyYW5zbGF0ZUNvb3JkaW5hdGVzKHhbMF0pLCB4WzFdXSB9KVxyXG5cdFx0XHRcdFx0Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gWyQucHJvamVjdE9uRmxhdCh4WzBdKSwgeFsxXV0gfSlcclxuXHRcdFx0XHQvLyAudmFsdWUoKVxyXG5cdFx0XHRcdGxhYmVscyA9IFtdXHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsYWJlbHMyLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdFx0bGFiZWxzID0gbGFiZWxzLmNvbmNhdChcclxuXHRcdFx0XHRcdFx0bGFiZWxzMltpXVswXS5tYXAoZnVuY3Rpb24gKHgpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJC5jb29yZHMyU3RyaW5nKHgpICsgXCI6XCIgKyBsYWJlbHMyW2ldWzFdXHJcblx0XHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQpXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG5vZGUuTEIgPSAkLndyYXBhcm91bmRBbmRDb29yZHMuY29uY2F0KGxhYmVscylcclxuXHRcdFx0aWYgKG5vZGUuTEIubGVuZ3RoID09PSAwKVxyXG5cdFx0XHRcdC8vIGRlbGV0ZSBub2RlWydMQiddXHJcblx0XHRcdFx0ZGVsZXRlIG5vZGUuTEJcclxuXHRcdH1cclxuXHJcblx0XHRzZXRMYWJlbHMoKVxyXG5cclxuXHRcdGlmIChub2RlLlNPICE9PSB1bmRlZmluZWQpXHJcblx0XHRcdG5vZGUuU08gPSB3cmFwcGVkR2FtZS5nYW1lLm5vZGVzWzBdLlNPICsgYCAoJHtzb3VyY2VTZ2ZNZXNzYWdlfSlgXHJcblx0XHQvL2Vsc2Ugbm9kZS5TTyA9IHNvdXJjZVNnZk1lc3NhZ2UvL3ByZWZlciBub3QgdG8gYWRkIHRoZSBtZXNzYWdlIHdoZW4gb3JpZ2luYWwgU2dmIGhhcyBubyBTTyBpbmZvLlxyXG5cclxuXHRcdG5vZGUuQVAgPSBcImdvLXZhcmlhbnRzLXRyYW5zZm9ybWVyXCJcclxuXHJcblxyXG5cdFx0bGV0IHN0YXRlID0geyB3cmFwcGVkR2FtZSwgbm9kZSwgcGVuZGluZywgY3VycmVudFBhdGgsIHRHbyB9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY29tbWVudChpc1Bhc3MsIGlzQmxhY2ssIHNjb3JlKSB7XHJcblx0XHRcdGlmICghb3B0aW9ucy5hZGRDb21tZW50cyAmJiAhc2NvcmUpXHJcblx0XHRcdFx0cmV0dXJuXHJcblxyXG5cdFx0XHRsZXQgciA9ICghb3B0aW9ucy5hZGRDb21tZW50cyAmJiAhc2NvcmUpID9cclxuXHRcdFx0XHQnJ1xyXG5cdFx0XHRcdDogJ21vdmUgJyArIHN0YXRlLmN1cnJlbnRQYXRoLm0gKyAnXFxuJyArICdXaGl0ZSBzdG9uZXMgY2FwdHVyZWQgYnkgQmxhY2s6ICcgKyB0R28uYm9hcmQuY2FwdHVyZWRbMV0gKyAnXFxuQmxhY2sgc3RvbmVzIGNhcHR1cmVkIGJ5IFdoaXRlOiAnICsgdEdvLmJvYXJkLmNhcHR1cmVkWzBdXHJcblx0XHRcdFx0Ly9sZXQgciA9ICAnQmxhY2sgY2FwdHVyZXM6ICcgKyB0R28uYm9hcmQuY2FwdHVyZWRbMV0gKyAnXFxyXFxuV2hpdGUgY2FwdHVyZXM6ICcgKyB0R28uYm9hcmQuY2FwdHVyZWRbMF1cclxuXHRcdFx0XHQrICghaXNQYXNzID8gJycgOiAnXFxuJyArIChpc0JsYWNrID8gJ0JsYWNrIHBhc3NlcycgOiAnV2hpdGUgcGFzc2VzJykpXHJcblx0XHRcdFx0KyAoIXNjb3JlID8gJycgOiAnXFxuJyArIGByZXN1bHQ6ICR7c2NvcmV9YClcclxuXHJcblx0XHRcdHIgKz0gJ1xcbi0tKHRoZSBjb250ZW50IGFib3ZlIHdhcyBnZW5lcmF0ZWQgYXV0b21hdGljYWxseSBieSBHb1ZhcmlhbnRzVHJhbnNmb3JtZXIpLS0nXHJcblx0XHRcdHIgKz0gKG5vZGUuQyA9PT0gdW5kZWZpbmVkID8gJycgOiAnXFxuJyArIG5vZGUuQylcclxuXHRcdFx0bm9kZS5DID0gclxyXG5cdFx0XHRyZXR1cm5cclxuXHRcdH1cclxuXHJcblx0XHRub2RlID0gZ29UaHJvdWdoVHJlZShzdGF0ZSlcclxuXHRcdHdoaWxlIChub2RlICE9PSBudWxsKSB7XHJcblxyXG5cclxuXHRcdFx0bGV0XHJcblx0XHRcdFx0aXNCbGFjayA9IG5vZGUuQiAhPT0gdW5kZWZpbmVkXHJcblx0XHRcdFx0LCBtb3ZlID0gaXNCbGFjayA/IG5vZGUuQiA6IG5vZGUuV1xyXG5cdFx0XHRcdCwgaXNBUGFzcyA9IG1vdmUgPT09IFwiXCIgfHwgKG9wdGlvbnMuYm9hcmREaW1lbnNpb25zWzBdID09PSBvcHRpb25zLmJvYXJkRGltZW5zaW9uc1sxXVxyXG5cdFx0XHRcdFx0JiYgb3B0aW9ucy5ib2FyZERpbWVuc2lvbnNbMF0gPD0gMTlcclxuXHRcdFx0XHRcdCYmIG1vdmUgPT09IFwidHRcIiAvL3dlaXJkIFNHRlszXSB3YXkgdG8gc2hvdyBhIHBhc3MgbW92ZSFcclxuXHRcdFx0XHQpXHJcblx0XHRcdFx0LCBzdG9uZXNNYXJrZWRGb3JTY29yaW5nID0gW11cclxuXHJcblx0XHRcdGlmIChtb3ZlID09PSB1bmRlZmluZWQgJiYgIWlzQVBhc3MpIHtcclxuXHRcdFx0XHRub2RlID0gZ29UaHJvdWdoVHJlZShzdGF0ZSlcclxuXHRcdFx0XHRjb250aW51ZVxyXG5cdFx0XHR9XHJcblx0XHRcdHNldExhYmVscygpXHJcblxyXG5cdFx0XHRpZiAoaXNBUGFzcykge1xyXG5cdFx0XHRcdGRlbGV0ZSBub2RlW2lzQmxhY2sgPyAnQicgOiAnVyddXHJcblx0XHRcdFx0Y29tbWVudChpc0FQYXNzLCBpc0JsYWNrKVxyXG5cdFx0XHRcdG5vZGVbaXNCbGFjayA/ICdBQicgOiAnQVcnXSA9IFtdXHJcblx0XHRcdFx0Ly8gaWYgKHBhc3NlcyA9PT0gMikge1xyXG5cdFx0XHRcdC8vIFx0Ly93cmFwcGVkR2FtZS5nYW1lLm5vZGVzLnNwbGljZShpKzEpLy9nZXQgcmlkIG9mIG5vZGVzIGFmdGVyd2FyZHMgLS0gbWF5IG5vdCB3b3JrIHdpdGggdmFyaWF0aW9ucyEgdG9kb1xyXG5cdFx0XHRcdC8vIFx0YnJlYWs7Ly9zdG9wIGFmdGVyIDMgc3VjY2Vzc2l2ZSBwYXNzZXMgZm9yIG5vd1xyXG5cdFx0XHRcdC8vIH1cclxuXHRcdFx0XHRwYXNzZXMrK1xyXG5cdFx0XHRcdGlmIChwYXNzZXMgPj0gMTAwMClcclxuXHRcdFx0XHRcdGJyZWFrLy9qdXN0IGluIGNhc2UhXHJcblx0XHRcdFx0bm9kZSA9IGdvVGhyb3VnaFRyZWUoc3RhdGUpXHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0Y29uc3QgY29vcmRzID0gdHJhbnNsYXRlQ29vcmRpbmF0ZXMobW92ZSlcclxuXHRcdFx0XHRsZXQgcGxheVJlc3VsdCA9IG51bGxcclxuXHRcdFx0XHQvLyBydW4gbW92ZSB0aHJvdWdoIHRHbyBhbmQgdXBkYXRlIGdhbWUgYWNjb3JkaW5nbHlcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0cGxheVJlc3VsdCA9IHRHby5wbGF5KGlzQmxhY2sgPyAnYicgOiAndycsIGNvb3JkcylcclxuXHJcblx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdFx0XHRcdGlmIChlcnJvci5tZXNzYWdlICE9PSAncG9pbnQgaXMgbm90IGVtcHR5JyAvKmlnbm9yZSB0aGlzIC0gaXQgaGFwcGVucyB3aXRoIHNvbWUgc2dmIGZyb20gbGl0dGxlR29sZW0uIFRvZG86IGxvb2sgaW50byBzY29yaW5nIHRoZSBwb3NpdGlvbiBoZXJlLiAqLylcclxuXHRcdFx0XHRcdFx0dGhyb3cgKGVycm9yKVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb25zdCBwcm9qZWN0ZWRDb29yZHMgPSAkLnByb2plY3RPbkZsYXQoY29vcmRzKVxyXG5cdFx0XHRcdGxldCB0b0FkZCA9IHBsYXlSZXN1bHQgPT09IG51bGwgPyBbXSA6IHByb2plY3RlZENvb3Jkcy5tYXAoJC5jb29yZHMyU3RyaW5nKVxyXG5cdFx0XHRcdFx0LCB0b1JlbW92ZSA9IHBsYXlSZXN1bHQgPT09IG51bGwgPyBbXSA6XHJcblx0XHRcdFx0XHRcdC8vIF8uY2hhaW4ocGxheVJlc3VsdC5yZW1vdmVkKVxyXG5cdFx0XHRcdFx0XHQvLyBcdC5mbGF0dGVuKHRydWUpXHJcblx0XHRcdFx0XHRcdC8vIFx0Lm1hcCgkLnByb2plY3RPbkZsYXQpXHJcblx0XHRcdFx0XHRcdC8vIFx0LmZsYXR0ZW4odHJ1ZSlcclxuXHRcdFx0XHRcdFx0Ly8gXHQubWFwKCQuY29vcmRzMlN0cmluZylcclxuXHRcdFx0XHRcdFx0Ly8gXHQudmFsdWUoKVxyXG5cdFx0XHRcdFx0XHRfZmxhdHRlbihcclxuXHRcdFx0XHRcdFx0XHRfZmxhdHRlbihwbGF5UmVzdWx0LnJlbW92ZWQpXHJcblx0XHRcdFx0XHRcdFx0XHQubWFwKCQucHJvamVjdE9uRmxhdCkpXHJcblx0XHRcdFx0XHRcdFx0Lm1hcCgkLmNvb3JkczJTdHJpbmcpXHJcblxyXG5cdFx0XHRcdC8vYWx0ZXIgdGhlIG5vZGVcclxuXHRcdFx0XHRpZiAob3B0aW9ucy5tb3ZlVHlwZSA9PT0gMikge1xyXG5cdFx0XHRcdFx0bGV0IG1vdmVNYXJrZXIgPSBgJHtpc0JsYWNrID8gJ0InIDogJ1cnfWBcclxuXHRcdFx0XHRcdG5vZGVbbW92ZU1hcmtlcl0gPSB0b0FkZC5wb3AoKVxyXG5cdFx0XHRcdFx0aWYgKHRvQWRkLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0bm9kZVsnQScgKyBtb3ZlTWFya2VyXSA9IHRvQWRkXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRsZXQgbW92ZU1hcmtlciA9IGAke29wdGlvbnMubW92ZVR5cGUgPCAzID8gJ0EnIDogJyd9JHtpc0JsYWNrID8gJ0InIDogJ1cnfWBcclxuXHJcblx0XHRcdFx0XHRub2RlW21vdmVNYXJrZXJdID0gdG9BZGRcclxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm1hcmtMYXN0TW92ZSkge1xyXG5cdFx0XHRcdFx0XHRub2RlW29wdGlvbnMubWFya0xhc3RNb3ZlXSA9IHRvQWRkXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAob3B0aW9ucy5tb3ZlVHlwZSA9PT0gMSlcclxuXHRcdFx0XHRcdG5vZGVbaXNCbGFjayA/ICdCJyA6ICdXJ10gPSAnJ1xyXG5cclxuXHJcblx0XHRcdFx0aWYgKHRvUmVtb3ZlLmxlbmd0aCA+IDApXHJcblx0XHRcdFx0XHRub2RlLkFFID0gdG9SZW1vdmVcclxuXHJcblx0XHRcdFx0XHRcdC8qXHJcblx0XHRcdFx0XHRcdHRvZG86IG90aGVyIHByb3BlcnRpZXMgd2l0aCBib2FyZCBjb29yZGluYXRlc1xyXG5cdFx0XHRcdFx0XHRMZWF2ZSBmb3Igbm93OlxyXG5cdFx0XHRcdFx0XHRBUlxyXG5cdFx0XHRcdFx0XHRMTlxyXG5cdFx0XHRcdFx0XHQqL1xyXG5cclxuXHRcdFx0XHRcdFx0Oy8qbm90ZSB0aGlzIHNlbWljb2xvbiBpcyBuZWVkZWQhICovXHJcblx0XHRcdFx0W1xyXG5cdFx0XHRcdFx0Ly8nQ1InLHRvZG86IGFkZCBpZiBub3QgbWFya2luZyB0aGUgbW92ZVxyXG5cdFx0XHRcdFx0J0REJywgJ01BJywgJ1NMJywgJ1NRJywgJ1RSJ10uZm9yRWFjaChmdW5jdGlvbiAoc2dmUHJvcGVydHkpIHtcclxuXHRcdFx0XHRcdFx0Ly8gXy5tYXAoWydERCcsJ01BJywnU0wnLCdTUScsJ1RSJ10sIGZ1bmN0aW9uKHNnZlByb3BlcnR5KXtcclxuXHRcdFx0XHRcdFx0aWYgKG5vZGVbc2dmUHJvcGVydHldID09PSB1bmRlZmluZWQpIHJldHVyblxyXG5cdFx0XHRcdFx0XHRsZXQgcG9pbnRzID0gW11cclxuXHRcdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkobm9kZVtzZ2ZQcm9wZXJ0eV0pKSB7XHJcblx0XHRcdFx0XHRcdFx0cG9pbnRzID0gbm9kZVtzZ2ZQcm9wZXJ0eV1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRwb2ludHMgPSBbbm9kZVtzZ2ZQcm9wZXJ0eV1dXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYgKG5vZGUuU0MgJiYgc2dmUHJvcGVydHkgPT09ICdNQScpIHtcclxuXHRcdFx0XHRcdFx0XHRzdG9uZXNNYXJrZWRGb3JTY29yaW5nID1cclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnRzXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Lm1hcCh0cmFuc2xhdGVDb29yZGluYXRlcylcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cG9pbnRzID1cclxuXHRcdFx0XHRcdFx0XHQvLyBfLmNoYWluKHBvaW50cylcclxuXHRcdFx0XHRcdFx0XHQvLyBcdC5tYXAodHJhbnNsYXRlQ29vcmRpbmF0ZXMpXHJcblx0XHRcdFx0XHRcdFx0Ly8gXHQubWFwKCQucHJvamVjdE9uRmxhdClcclxuXHRcdFx0XHRcdFx0XHQvLyBcdC5mbGF0dGVuKHRydWUpXHJcblx0XHRcdFx0XHRcdFx0Ly8gXHQubWFwKCQuY29vcmRzMlN0cmluZylcclxuXHRcdFx0XHRcdFx0XHQvLyBcdC52YWx1ZSgpXHJcblx0XHRcdFx0XHRcdFx0X2ZsYXR0ZW4oXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludHNcclxuXHRcdFx0XHRcdFx0XHRcdFx0Lm1hcCh0cmFuc2xhdGVDb29yZGluYXRlcylcclxuXHRcdFx0XHRcdFx0XHRcdFx0Lm1hcCgkLnByb2plY3RPbkZsYXQpXHJcblx0XHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcCgkLmNvb3JkczJTdHJpbmcpXHJcblx0XHRcdFx0XHRcdG5vZGVbc2dmUHJvcGVydHldID0gcG9pbnRzXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdGlmIChvcHRpb25zLmFkZE1vdmVOdW1iZXIpXHJcblx0XHRcdFx0XHRub2RlLk1OID0gY3VycmVudFBhdGgubVxyXG5cclxuXHRcdFx0XHQvKlxyXG5cdFx0XHRcdFVzZSBhIGN1c3RvbSwgbmV3IFNHRiBwcm9wZXJ0eSwgU0MsIGluIG9yZGVyIHRvIHNlZSBpZiB0aGUgY3VycmVudCBwb3NpdGlvbiBzaG91bGQgYmUgc2NvcmVkLCBhbmQgaWYgc28sIHdoYXQgdG8gZG8gd2l0aCB0aGUgc2NvcmUuXHJcblx0XHRcdFx0SXTigJlzIGEgYml0IGZsYWcuICBcclxuXHRcdFx0XHQxXHTih5IgdXBkYXRlIHRoZSBjb21tZW50cyBmb3IgdGhlIG5vZGUgKHN1Y2NpbnQpLiBXaGVuIGZsYWdnZWQsIHRoZSBuZXh0IG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlLlxyXG5cdFx0XHRcdDJcdOKHkiB1cGRhdGUgdGhlIGNvbW1lbnRzIGZvciB0aGUgbm9kZSAodmVyYm9zZSlcclxuXHRcdFx0XHQ0XHTih5IgdXBkYXRlIHRoZSBnYW1lIHJlc3VsdCAoUkUpIGZvciB0aGUgcm9vdCBub2RlXHJcblx0XHRcdFx0VHlwaWNhbCB1c2FnZTogYWRkIOKAnFNDWzZd4oCdIHRvIHRoZSBsYXN0IG5vZGUsIGFuZCDigJxTQ1syXeKAnSB0byBzY29yZSBhIHZhcmlhdGlvbi5cclxuXHRcdFx0XHQqL1xyXG5cdFx0XHRcdGxldCB1cGRhdGVkQ29tbWVudCA9IGZhbHNlXHJcblx0XHRcdFx0aWYgKG5vZGUuU0MpIHtcclxuXHRcdFx0XHRcdHRHby5ydWxlcy5rb21pID0gcGFyc2VGbG9hdCh3cmFwcGVkR2FtZS5nYW1lLm5vZGVzWzBdLktNKVxyXG5cclxuXHRcdFx0XHRcdGxldCBzY29yZSA9IHRHby5ib2FyZC5zY29yZShzdG9uZXNNYXJrZWRGb3JTY29yaW5nKVxyXG5cdFx0XHRcdFx0XHQsIHNjb3JlT3B0aW9uID0gcGFyc2VJbnQobm9kZS5TQylcclxuXHRcdFx0XHRcdGlmICgoc2NvcmVPcHRpb24gJiAxKSA9PT0gMSkge1xyXG5cdFx0XHRcdFx0XHR1cGRhdGVkQ29tbWVudCA9IHRydWVcclxuXHRcdFx0XHRcdFx0Y29tbWVudChpc0FQYXNzLCBpc0JsYWNrLCBzY29yZS5SRSlcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2UgLypkb24ndCB3YW50IHRvIHRyZWF0IHN1Y2NpbnQgYW5kIHZlcmJvc2UgYXQgdGhlIHNhbWUgdGltZSovXHJcblx0XHRcdFx0XHRcdGlmICgoc2NvcmVPcHRpb24gJiAyKSA9PT0gMikge1xyXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZWRDb21tZW50ID0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRcdGNvbW1lbnQoaXNBUGFzcywgaXNCbGFjayxcclxuXHRcdFx0XHRcdFx0XHRcdGBCbGFjazogJHtzY29yZS5ibGFja1Njb3JlfSA9ICR7c2NvcmUudG90YWxCbGFja1RlcnJpdG9yeX0gdGVycml0b3J5ICsgJHtzY29yZS50b3RhbFdoaXRlRGVhZCArIHNjb3JlLnRvdGFsV2hpdGVDYXB0dXJlZH0gcHJpc29uZXJzXHJcbldoaXRlOiAke3Njb3JlLndoaXRlU2NvcmV9ID0gJHtzY29yZS50b3RhbFdoaXRlVGVycml0b3J5fSB0ZXJyaXRvcnkgKyAke3Njb3JlLnRvdGFsQmxhY2tEZWFkICsgc2NvcmUudG90YWxCbGFja0NhcHR1cmVkfSBwcmlzb25lcnMgKyAke3RHby5ydWxlcy5rb21pfSBrb21pXHJcblJlc3VsdDogJHtzY29yZS5SRX1gKVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoKHNjb3JlT3B0aW9uICYgNCkgPT09IDQpIHtcclxuXHRcdFx0XHRcdFx0d3JhcHBlZEdhbWUuZ2FtZS5ub2Rlc1swXS5SRSA9IHNjb3JlLlJFXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICghdXBkYXRlZENvbW1lbnQpXHJcblx0XHRcdFx0XHRjb21tZW50KGlzQVBhc3MsIGlzQmxhY2spXHJcblxyXG5cdFx0XHRcdC8vIG1vdmUgdG8gbmV4dCBub2RlXHJcblx0XHRcdFx0bm9kZSA9IGdvVGhyb3VnaFRyZWUoc3RhdGUpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChvcHRpb25zLnRyYW5zZm9ybVRvU3RyaW5nKVxyXG5cdFx0XHRyZXR1cm4gc21hcnRnYW1lLmdlbmVyYXRlKHsgZ2FtZVRyZWVzOiBbd3JhcHBlZEdhbWUuZ2FtZV0gfSk7XHJcblx0XHRlbHNlIHJldHVybiB3cmFwcGVkR2FtZVxyXG5cdH1cclxuXHQkLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxyXG5cdHJldHVybiAkXHJcblxyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtZXIiLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cclxuLyogZ2xvYmFsIEdvQm9hcmRBcGkgKi9cclxuLyogZXNsaW50IG5vLWNvbnNvbGU6IDAgKi9cclxuLyoqXHJcbiAqIEEgZnVuY3Rpb24gZm9yIHJlbmRlcmluZyB0aGUgdmlld2VyL2VkaXRvclxyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9XVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmluaGliaXRGb3JSb290ID0gdHJ1ZV0gV2hlbiBmbGFnZ2VkLCB0aGUgZnVuY3Rpb24gZG9lcyBub3RoaW5nIHdoZW4gdGhlIGN1cnJlbnQgd2luZG93J3MgbG9jYXRpb24ucGF0aCBpcyBlbXB0eS4gKFVzZWZ1bCBmb3IgcHJldmVudGluZyB0aGUgc2NyaXB0IGZyb20gcnVubmluZyB3aGVuIHNldmVyYWwgcG9zdHMgYXJlIGRpc3BsYXllZCBhdCB0aGUgaG9tZSBwYWdlIG9mIHRoZSBibG9nLikgXHJcbiovXHJcblxyXG5sZXQgZ29WYXJpYW50c0VkaXRvciA9IGZ1bmN0aW9uIChlZGl0b3JPcHRpb25zKSB7XHJcblx0ZWRpdG9yT3B0aW9ucyA9IHsgcm9vdElkOiAnc2dmRWRpdG9yJywgc2hvd0V4dHJhczogdHJ1ZSwgaW5oaWJpdEZvclJvb3Q6dHJ1ZSwgLi4uZWRpdG9yT3B0aW9ucyB9XHJcblx0bGV0IHsgcm9vdElkLCBzaG93RXh0cmFzIH0gPSBlZGl0b3JPcHRpb25zXHJcblx0XHQsIGVkaXRvclRlbXBsYXRlID0gcmVxdWlyZSgnLi9lZGl0b3IuanN4JylcclxuXHRcdCwgZ29fdmFyaWFudHNfdHJhbnNmb3JtZXIgPSByZXF1aXJlKCcuLi9zcmMvdHJhbnNmb3JtZXInKVxyXG5cdFx0LCAgZ2V0RWxlbWVudEJ5SWRTdWZmaXggPSAoc3VmZml4KSA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyb290SWQgKyAnXycgKyBzdWZmaXgpXHJcblx0XHQsICB2aWV3ZXIgPSB7fVxyXG5cdFxyXG5cdGlmICh2aWV3ZXIucmFuKSByZXR1cm5cclxuXHR2aWV3ZXIucmFuID0gdHJ1ZS8vanVzdCBydW4gdGhpcyBmdW5jdGlvbiBvbmNlXHJcblxyXG5cdC8vc3RhcnR1cFxyXG5cdGxldCBvcHRpb25zTm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXHJcblx0XHRgIyR7cm9vdElkfSAuZ28tdmFyaWFudHMtb3B0aW9uc2ApXHJcblx0aWYgKG9wdGlvbnNOb2RlLmxlbmd0aCA+IDApIHtcclxuXHRcdGxldCBvcHRpb25zID0gSlNPTi5wYXJzZShvcHRpb25zTm9kZVswXS5pbm5lclRleHQpXHJcblx0XHRlZGl0b3JPcHRpb25zID0gey4uLiBlZGl0b3JPcHRpb25zLCAuLi4gb3B0aW9uc31cclxuXHR9XHJcblx0aWYgKGVkaXRvck9wdGlvbnMuaW5oaWJpdEZvclJvb3QgJiYgbG9jYXRpb24ucGF0aG5hbWUgPT09ICcnKSByZXR1cm5cclxuXHJcblx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocm9vdElkKS5hcHBlbmRDaGlsZChlZGl0b3JUZW1wbGF0ZShlZGl0b3JPcHRpb25zKSlcclxuXHJcblx0XHJcblxyXG5cclxuXHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgndXBkYXRlQnV0dG9uJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB1cGRhdGVWYXJpYW50U2dmKVxyXG5cclxuXHRcdDtbXS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgIyR7cm9vdElkfV92aWV3ZXJDb250cm9scyBpbnB1dFt0eXBlPWJ1dHRvbl1gKSwgZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRsZXQgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50XHJcblx0XHRcdFx0c2hvd0JvYXJkKHsgcGFubmluZ0RpcmVjdGlvbjogdGFyZ2V0LnZhbHVlIH0pXHJcblx0XHRcdH0pXHJcblx0XHR9KVxyXG5cclxuXHRpZiAoc2hvd0V4dHJhcykge1xyXG5cdFx0W10uZm9yRWFjaC5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYCMke3Jvb3RJZH0gLmdvLXZhcmlhbnRzLWV4dHJhc2ApLCBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdFx0ZWwuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snXHJcblx0XHR9KVxyXG5cclxuXHRcdC8vIDsvKmFub3RoZXIgc2VtaWNvbG9uIHRoYXQncyBuZWVkZWQuLi4qL1tdLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAjJHtyb290SWR9IGZpZWxkc2V0LmdvLXZhcmlhbnRzLWV4dHJhc2ApLCBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdC8vIFx0ZWwuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snXHJcblx0XHQvLyB9KVxyXG5cclxuXHJcblx0XHRsZXQgc2VsZWN0ID0gZ2V0RWxlbWVudEJ5SWRTdWZmaXgoJ3NpemVTZWxlY3QnKVxyXG5cdFx0Zm9yIChsZXQgaW5kZXggPSA0OyBpbmRleCA8IDIwOyBpbmRleCsrKSB7XHJcblx0XHRcdGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpXHJcblx0XHRcdG9wdGlvbi52YWx1ZSA9ICcnICsgaW5kZXhcclxuXHRcdFx0b3B0aW9uLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGluZGV4KSlcclxuXHRcdFx0c2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbilcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdFtdLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAjJHtyb290SWR9IC5nby12YXJpYW50cy1leHRyYXNgKSwgZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRcdC8vZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbClcclxuXHRcdFx0ZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG5cdFx0fSlcclxuXHR9XHJcblxyXG5cdGdldEVsZW1lbnRCeUlkU3VmZml4KCdnb0J1dHRvbicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0c2hvd0JvYXJkKClcclxuXHR9KVxyXG5cdGdldEVsZW1lbnRCeUlkU3VmZml4KCdnb0xnQnV0dG9uJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRnZXRMaXR0bGVHb2xlbVNnZkFuZFNob3dCb2FyZCgpXHJcblx0fSlcclxuXHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgnbmV3QnV0dG9uJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeChcInNnZkluXCIpLnZhbHVlID0gYCg7R01bMV1GRls0XUFQW2dvLXZhcmlhbnRzLXRyYW5zZm9ybWVyXVNaWyR7Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ3NpemVTZWxlY3QnKS52YWx1ZX1dKWBcclxuXHRcdHNob3dCb2FyZCgpXHJcblx0fSlcclxuXHJcblx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ3ZpZXdlckNvbnRyb2xzJykuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXHJcblxyXG5cdC8vc3RhcnR1cFxyXG5cdGxldCBpbnB1dFNnZk5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxyXG5cdFx0Ly8gYCMke3Jvb3RJZH0gLmdvLXZhcmlhbnRzLWRhdGE6Zmlyc3Qtb2YtdHlwZWApXHJcblx0XHRgIyR7cm9vdElkfSAuZ28tdmFyaWFudHMtZGF0YWApXHJcblx0aWYgKGlucHV0U2dmTm9kZS5sZW5ndGggPiAwKSB7XHJcblx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeChcInNnZkluXCIpLnZhbHVlID0gaW5wdXRTZ2ZOb2RlWzBdLmlubmVyVGV4dFxyXG5cclxuXHRcdHNob3dCb2FyZCgpXHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0bGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKG5ldyBVUkwod2luZG93LmxvY2F0aW9uKSkuc2VhcmNoLnNsaWNlKDEpKVxyXG5cdFx0aWYgKHBhcmFtcy5oYXMoJ3NnZicpKSB7XHJcblx0XHRcdGxldCBzZ2YgPSBwYXJhbXMuZ2V0KCdzZ2YnKVxyXG5cdFx0XHRpZiAobG9va3NMaWtlU2dmKHNnZikpIHtcclxuXHRcdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeChcInNnZkluXCIpLnZhbHVlID0gc2dmXHJcblx0XHRcdFx0c2hvd0JvYXJkKClcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChwYXJhbXMuaGFzKCdsaXR0bGVnb2xlbWlkJykpIHtcclxuXHRcdFx0bGV0IGlkID0gcGFyYW1zLmdldCgnbGl0dGxlZ29sZW1pZCcpXHJcblx0XHRcdGlmICgvXlxcZCskL2cudGVzdChpZCkpIHtcclxuXHRcdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgnbGl0dGxlR29sZW1JZCcpLnZhbHVlID0gaWRcclxuXHRcdFx0XHRnZXRMaXR0bGVHb2xlbVNnZkFuZFNob3dCb2FyZCgpXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHRmdW5jdGlvbiBzaG93Qm9hcmQob3B0aW9ucykge1xyXG5cdFx0aWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgb3B0aW9ucyA9IHt9XHJcblx0XHRsZXQgeyB0U2dmLCBwYW5uaW5nRGlyZWN0aW9uLCBtb3ZlUmVmZXJlbmNlLCByZXNldCB9ID0gb3B0aW9uc1xyXG5cdFx0aWYgKHJlc2V0IHx8ICF2aWV3ZXIub2Zmc2V0KSB2aWV3ZXIub2Zmc2V0ID0gWzAsIDBdXHJcblx0XHRpZiAocGFubmluZ0RpcmVjdGlvbikge1xyXG5cdFx0XHRsZXQgcmlnaHQgPSB2aWV3ZXIub2Zmc2V0WzBdLCB1cCA9IHZpZXdlci5vZmZzZXRbMV1cclxuXHRcdFx0c3dpdGNoIChwYW5uaW5nRGlyZWN0aW9uKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgXCLihpFcIjpcclxuXHRcdFx0XHRcdHtcclxuXHRcdFx0XHRcdFx0dXAtLVxyXG5cdFx0XHRcdFx0XHRicmVha1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjYXNlIFwi4oaTXCI6XHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHVwKytcclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRjYXNlIFwi4oaQXCI6XHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdHJpZ2h0LS1cclxuXHRcdFx0XHRcdFx0YnJlYWtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y2FzZSBcIuKGklwiOlxyXG5cdFx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0XHRyaWdodCsrXHJcblx0XHRcdFx0XHRcdGJyZWFrXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dmlld2VyLm9mZnNldCA9IFtyaWdodCwgdXBdXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRTZ2YgPT09IHVuZGVmaW5lZCB8fCB0U2dmID09PSBudWxsKSB7XHJcblx0XHRcdHRTZ2YgPSBnZXRFbGVtZW50QnlJZFN1ZmZpeChcInNnZkluXCIpLnZhbHVlXHJcblx0XHR9XHJcblx0XHRpZiAodFNnZiA9PT0gJycpIHtcclxuXHRcdFx0aWYgKCF2aWV3ZXIud2FybmVkRW1wdHlTZ2YpIHtcclxuXHRcdFx0XHRhbGVydCgnTm8gU0dGIHdhcyBlbnRlcmVkLCBzbyBzaG93aW5nIGEgc2ltcGxlIHNhbXBsZSBpbnN0ZWFkLicpXHJcblx0XHRcdFx0dmlld2VyLndhcm5lZEVtcHR5U2dmID0gdHJ1ZVxyXG5cdFx0XHR9XHJcblx0XHRcdHRTZ2YgPSAnKDtHTVsxXUZGWzRdQ0FbVVRGLThdQVBbZ28tdmFyaWFudHMtdHJhbnNmb3JtZXJdU1RbMF1TWls0XUtNWzBdSEFbMF1QQltCbGFja11QV1tXaGl0ZV1DW0hlcmUgaXMgYSBzbWFsbCBzYW1wbGUgZ2FtZSBvZiBUb3JvaWRhbCBHby4gSXQgZW5kcyBpbiBhIHNla2kuXTtCW2FkXTtXW2JkXTtCW2JjXTtXW2FjXTtCW2JiXTtXW2FhXTtCW2FiXTtXW2RkXTtCW2NhXTtXW2NkXTtCW2RiXTtXW2RjXTtCW2NjXTtNQVtiYV1DW0l04oCZcyBhIHNla2k7IG5laXRoZXIgcGxheWVyIHNob3VsZCBwbGF5IGF0IFggbm93IC0gaWYgdGhleSBkbywgdGhleSBwdXQgdGhlaXIgb3duIHN0b25lcyBpbiBhdGFyaS4gVGhpcyBpcyBzaG93biBpbiB0aGUgbmV4dCB0d28gdmFyaWF0aW9ucy5dV1tkYV0oO0JbYmFdO1dbY2JdKSg7QltdO1dbYmFdO0JbYWRdKSknLy9mb3JrZWQgZnJvbSBzYW1wbGU3XHJcblx0XHRcdGdldEVsZW1lbnRCeUlkU3VmZml4KFwic2dmSW5cIikudmFsdWUgPSB0U2dmXHJcblx0XHR9XHJcblx0XHRsZXQgd3JhcGFyb3VuZCA9IE51bWJlcihnZXRFbGVtZW50QnlJZFN1ZmZpeCgnd3JhcGFyb3VuZFNlbGVjdCcpLnZhbHVlKVxyXG5cdFx0XHQsIHdyYXBhcm91bmRNYXJrZXJzVHlwZSA9IE51bWJlcihnZXRFbGVtZW50QnlJZFN1ZmZpeCgnd3JhcGFyb3VuZEJvcmRlclNlbGVjdCcpLnZhbHVlKVxyXG5cdFx0XHQsIGNvb3JkaW5hdGVzVHlwZSA9IE51bWJlcihnZXRFbGVtZW50QnlJZFN1ZmZpeCgnY29vcmRpbmF0ZVNlbGVjdCcpLnZhbHVlKVxyXG5cdFx0XHQsIGFkZENvbW1lbnRzID0gZ2V0RWxlbWVudEJ5SWRTdWZmaXgoJ2FkZENvbW1lbnRzJykuY2hlY2tlZFxyXG5cdFx0XHQsIHNnZiA9ICcnXHJcblx0XHR0cnkge1xyXG5cdFx0XHRsZXQgdHJhbnNmb3JtZXIgPSBnb192YXJpYW50c190cmFuc2Zvcm1lcih7XHJcblx0XHRcdFx0YWRkQ29tbWVudHMsXHJcblx0XHRcdFx0d3JhcGFyb3VuZE1hcmtlcnNUeXBlLFxyXG5cdFx0XHRcdGNvb3JkaW5hdGVzVHlwZSxcclxuXHRcdFx0XHRwcm9qZWN0aW9uU2V0dGluZ3M6IHtcclxuXHRcdFx0XHRcdG9mZnNldDogdmlld2VyLm9mZnNldCxcclxuXHRcdFx0XHRcdHdyYXBhcm91bmRcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pXHJcblx0XHRcdHNnZiA9IHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh0U2dmKVxyXG5cdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeChcInNnZk91dFwiKS52YWx1ZSA9IHNnZlxyXG5cdFx0XHR2aWV3ZXIudHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lclxyXG5cdFx0fVxyXG5cdFx0Y2F0Y2ggKGUpIHtcclxuXHRcdFx0YWxlcnQoJ2FuIGVycm9yIG9jY3VycmVkLicpXHJcblx0XHRcdHJldHVyblxyXG5cdFx0fVxyXG5cclxuXHRcdHZpZXdlci5zZ2YgPSBzZ2ZcclxuXHRcdGlmICghcGFubmluZ0RpcmVjdGlvbikge1xyXG5cclxuXHRcdFx0bGV0IG9HYW1lVHJlZSA9IEdvQm9hcmRBcGkuQ3JlYXRlX0dhbWVUcmVlKClcclxuXHRcdFx0dmlld2VyLm9HYW1lVHJlZSA9IG9HYW1lVHJlZVxyXG5cclxuXHRcdFx0R29Cb2FyZEFwaS5TZXRfT25HYW1lVHJlZU1vZGlmaWVkQ2FsbGJhY2sob0dhbWVUcmVlLCAoKSA9PiB7IH0pXHJcblx0XHRcdEdvQm9hcmRBcGkuVG9nZ2xlX1J1bGVycyhvR2FtZVRyZWUpXHJcblx0XHRcdEdvQm9hcmRBcGkuU2V0X0RyYXdIYW5kaWNhcE1hcmtzKG9HYW1lVHJlZSwgZmFsc2UpXHJcblx0XHRcdEdvQm9hcmRBcGkuU2V0X0NhcHR1cmluZ01vZGUob0dhbWVUcmVlLCBmYWxzZSlcclxuXHJcblx0XHRcdEdvQm9hcmRBcGkuQ3JlYXRlX0JvYXJkQ29tbWVudHNCdXR0b25zTmF2aWdhdG9yKG9HYW1lVHJlZSwgcm9vdElkICsgJ18nICsgXCJwbGF5ZXJEaXZcIilcclxuXHRcdFx0Ly8gR29Cb2FyZEFwaS5DcmVhdGVfRWRpdG9yVmVyKG9HYW1lVHJlZSwgXCJwbGF5ZXJEaXZcIik7XHJcblx0XHRcdGlmIChtb3ZlUmVmZXJlbmNlICE9PSB1bmRlZmluZWQpXHJcblx0XHRcdFx0R29Cb2FyZEFwaS5Mb2FkX1NnZih2aWV3ZXIub0dhbWVUcmVlLCBzZ2YsIHVuZGVmaW5lZCwgbW92ZVJlZmVyZW5jZSk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRHb0JvYXJkQXBpLkxvYWRfU2dmKG9HYW1lVHJlZSwgc2dmKTtcclxuXHJcblx0XHRcdEdvQm9hcmRBcGkuU2V0X09uR2FtZVRyZWVNb2RpZmllZENhbGxiYWNrKG9HYW1lVHJlZSwgZ2FtZVRyZWVNb2RpZmllZENhbGxiYWNrKVxyXG5cclxuXHRcdFx0d2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdEdvQm9hcmRBcGkuVXBkYXRlX1NpemUob0dhbWVUcmVlKTtcclxuXHRcdFx0fTtcclxuXHJcblxyXG5cdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgndmlld2VyQ29udHJvbHMnKS5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxyXG5cdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgndXBkYXRlQnV0dG9uRGl2Jykuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCJcclxuXHJcblx0XHRcdGlmIChzaG93RXh0cmFzKSB7XHJcblx0XHRcdFx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ3RyYW5zZm9ybWVkU2dmRnMnKS5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIlxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0R29Cb2FyZEFwaS5TZXRfT25HYW1lVHJlZU1vZGlmaWVkQ2FsbGJhY2sodmlld2VyLm9HYW1lVHJlZSwgKCkgPT4geyB9KVxyXG5cdFx0XHRtb3ZlUmVmZXJlbmNlID0gR29Cb2FyZEFwaS5HZXRfTW92ZVJlZmVyZW5jZSh2aWV3ZXIub0dhbWVUcmVlLCBmYWxzZSlcclxuXHRcdFx0R29Cb2FyZEFwaS5Mb2FkX1NnZih2aWV3ZXIub0dhbWVUcmVlLCBzZ2YsIHVuZGVmaW5lZCwgbW92ZVJlZmVyZW5jZSlcclxuXHRcdFx0R29Cb2FyZEFwaS5TZXRfT25HYW1lVHJlZU1vZGlmaWVkQ2FsbGJhY2sodmlld2VyLm9HYW1lVHJlZSwgZ2FtZVRyZWVNb2RpZmllZENhbGxiYWNrKVxyXG5cdFx0XHRnZXRFbGVtZW50QnlJZFN1ZmZpeCgnb2Zmc2V0VHInKS5pbm5lckhUTUwgPSAncGFubmVkOiBbJ1xyXG5cdFx0XHRcdCsgdmlld2VyLnRyYW5zZm9ybWVyLm1vZFgodmlld2VyLnRyYW5zZm9ybWVyLm9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFswXSlcclxuXHRcdFx0XHQrICcsICcgKyB2aWV3ZXIudHJhbnNmb3JtZXIubW9kWSgtdmlld2VyLnRyYW5zZm9ybWVyLm9wdGlvbnMucHJvamVjdGlvblNldHRpbmdzLm9mZnNldFsxXSkgKyAnXSdcclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnYW1lVHJlZU1vZGlmaWVkQ2FsbGJhY2soKSB7XHJcblx0XHQvL3doZW4gYSBtb3ZlIGlzIHBsYXllZCwgdGhlIGNhbGxiYWNrIGlzIHJhaXNlZCB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLiBXZSB3YW50IHRvIG9ubHkgZG8gd29yayBvbiB0aGUgc2Vjb25kIGNhbGwuXHJcblx0XHRpZiAoIXZpZXdlci5jYWxsYmFja0xhc3RDYWxsZWQpIHtcclxuXHRcdFx0dmlld2VyLmNhbGxiYWNrTGFzdENhbGxlZCA9IERhdGUubm93KClcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYgKERhdGUubm93KCkgLSB2aWV3ZXIuY2FsbGJhY2tMYXN0Q2FsbGVkIDwgMzAwKSB7XHJcblx0XHRcdHVwZGF0ZVZhcmlhbnRTZ2YoKVxyXG5cdFx0fVxyXG5cdFx0ZWxzZSB2aWV3ZXIuY2FsbGJhY2tMYXN0Q2FsbGVkID0gRGF0ZS5ub3coKVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbG9va3NMaWtlU2dmKHNnZiwgc2l6ZSkge1xyXG5cdFx0bGV0IHJlc3VsdCA9IHNnZi5zdGFydHNXaXRoKCcoJylcclxuXHRcdC8vICYmIHNnZi5pbmRleE9mKCdHTVsxXScpID4gMCAvL1NHRiBMRyBkb2Vzbid0IVxyXG5cclxuXHRcdGlmIChzaXplKSB7XHJcblx0XHRcdHJldHVybiByZXN1bHQgJiYgc2dmLmluZGV4T2YoYFNaWyR7c2l6ZX1dYCA+IDMpXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0ICYmIC9TWlxcW1xcZCtdLy50ZXN0KHNnZilcclxuXHR9XHJcblx0ZnVuY3Rpb24gdXBkYXRlVmFyaWFudFNnZigpIHtcclxuXHRcdGxldCBzZ2YgPSBHb0JvYXJkQXBpLlNhdmVfU2dmKHZpZXdlci5vR2FtZVRyZWUpXHJcblx0XHRpZiAoc2dmID09IHZpZXdlci5zZ2YpIHtcclxuXHRcdFx0cmV0dXJuXHJcblx0XHR9XHJcblx0XHR2aWV3ZXIuc2dmID0gc2dmXHJcblx0XHRsZXQgbW92ZVJlZmVyZW5jZSA9IEdvQm9hcmRBcGkuR2V0X01vdmVSZWZlcmVuY2Uodmlld2VyLm9HYW1lVHJlZSwgZmFsc2UpXHJcblx0XHQvLyBsZXQgb3B0aW9ucyA9IHZpZXdlci50cmFuc2Zvcm1lci5vcHRpb25zXHJcblx0XHQvLyBvcHRpb25zLmJvYXJkRGltZW5zaW9ucyA9IG9wdGlvbnMuYm9hcmREaW1lbnNpb25zLm1hcCgoeCkgPT4geCAtIDIgKiBvcHRpb25zLnByb2plY3Rpb25TZXR0aW5ncy53cmFwYXJvdW5kKSBcclxuXHRcdGxldCB0U2dmID0gdmlld2VyLnRyYW5zZm9ybWVyLmludmVyc2VUcmFuc2Zvcm0oc2dmKVxyXG5cdFx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoXCJzZ2ZJblwiKS52YWx1ZSA9IHRTZ2ZcclxuXHRcdHNob3dCb2FyZCh7IHRTZ2YsIG1vdmVSZWZlcmVuY2UgfSlcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldExpdHRsZUdvbGVtU2dmQW5kU2hvd0JvYXJkKCkge1xyXG5cdFx0bGV0IGdhbWVJZCA9IGdldEVsZW1lbnRCeUlkU3VmZml4KCdsaXR0bGVHb2xlbUlkJykudmFsdWVcclxuXHRcdGlmIChnYW1lSWQgPT09ICcnKSB7XHJcblx0XHRcdC8vZ2FtZUlkID0gJzE4NjA3OTUnXHJcblx0XHRcdGFsZXJ0KCdlbnRlciB0aGUgSUQgb2YgYSBnYW1lIGZyb20gTGl0dGxlR29sZW0sIGUuZy4g4oCcMTg2MDc5NeKAnScpXHJcblx0XHRcdHJldHVyblxyXG5cdFx0fVxyXG5cdFx0Z2FtZUlkID0gZ2FtZUlkLnRyaW0oKVxyXG5cclxuXHRcdGxldCBwcm94eXVybCA9IFwiaHR0cHM6Ly9jb3JzLWFueXdoZXJlLmhlcm9rdWFwcC5jb20vXCJcclxuXHRcdGxldCB1cmwgPSBgaHR0cDovL2xpdHRsZWdvbGVtLm5ldC9zZXJ2bGV0L3NnZi8ke2dhbWVJZH0vZ2FtZSR7Z2FtZUlkfS5zZ2ZgXHJcblx0XHRpZiAoIS9eXFxkKyQvZy50ZXN0KGdhbWVJZCkpIHtcclxuXHRcdFx0YWxlcnQoJ2ludmFsaWQgSUQnKVxyXG5cdFx0XHRyZXR1cm5cclxuXHRcdH1cclxuXHRcdGdldEVsZW1lbnRCeUlkU3VmZml4KCdnb0xnTXNnJykuaW5uZXJUZXh0ID0gJ2xvYWRpbmfigKYnXHJcblx0XHRsZXQgbXlIZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xyXG5cdFx0XHRcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3NnZlwiXHJcblx0XHR9KTtcclxuXHRcdGNvbnN0IGZhaWxNc2cgPSAnbG9hZCBmcm9tIGxpdHRlbCBHb2xlbSBmYWlsZWQnXHJcblx0XHRmZXRjaChwcm94eXVybCArIHVybCwgeyBoZWFkZXJzOiBteUhlYWRlcnMgfSkudGhlbihcclxuXHRcdFx0ZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XHJcblx0XHRcdFx0XHRjb25zb2xlLmxvZygnTG9va3MgbGlrZSB0aGVyZSB3YXMgYSBwcm9ibGVtLiBTdGF0dXMgQ29kZTogJyArIHJlc3BvbnNlLnN0YXR1cyk7XHJcblxyXG5cdFx0XHRcdFx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ2dvTGdNc2cnKS5pbm5lclRleHQgPSBmYWlsTXNnXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBFeGFtaW5lIHRoZSB0ZXh0IGluIHRoZSByZXNwb25zZVxyXG5cdFx0XHRcdHJlc3BvbnNlLnRleHQoKS50aGVuKGZ1bmN0aW9uIChzZ2YpIHtcclxuXHRcdFx0XHRcdGlmICghbG9va3NMaWtlU2dmKHNnZiwgMTEgLypMRyBpcyBhbHdheXMgMTF4MTEqLykpIHtcclxuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coJ2ludmFsaWQgU0dGLiBSZWNlaXZlZDonICsgc2dmKVxyXG5cclxuXHRcdFx0XHRcdFx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ2dvTGdNc2cnKS5pbm5lclRleHQgPSBmYWlsTXNnXHJcblx0XHRcdFx0XHRcdHJldHVyblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c2dmID0gc2dmLnJlcGxhY2UoJ1NaWzExXScsIGBTWlsxMV1TT1todHRwOi8vbGl0dGxlZ29sZW0ubmV0L2pzcC9nYW1lL2dhbWUuanNwP2dpZD0ke2dhbWVJZH1gKVxyXG5cclxuXHRcdFx0XHRcdGdldEVsZW1lbnRCeUlkU3VmZml4KFwic2dmSW5cIikudmFsdWUgPSBzZ2ZcclxuXHRcdFx0XHRcdHNob3dCb2FyZCgpXHJcblxyXG5cdFx0XHRcdFx0Z2V0RWxlbWVudEJ5SWRTdWZmaXgoJ2dvTGdNc2cnKS5pbm5lclRleHQgPSAnZ2FtZSBsb2FkZWQgZnJvbSBMaXR0bGUgR29sZW0nXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdCkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG5cdFx0XHRjb25zb2xlLmxvZygnRmV0Y2ggRXJyb3IgOi1TJywgZXJyKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblxyXG5cclxuXHJcbn1cclxuZG9jdW1lbnQuZ29WYXJpYW50c0VkaXRvciA9IGdvVmFyaWFudHNFZGl0b3JcclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcclxuXHRbXS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmdvLXZhcmlhbnRzLWVkaXRvcicpLCBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdGxldCBvcHRpb25zID0geyByb290SWQ6IGVsLmlkIH1cclxuXHRcdGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2dvLXZhcmlhbnRzLWhpZGUtZXh0cmFzJykpIHtcclxuXHRcdFx0b3B0aW9ucy5zaG93RXh0cmFzID0gZmFsc2VcclxuXHRcdH1cclxuXHRcdGRvY3VtZW50LmdvVmFyaWFudHNFZGl0b3Iob3B0aW9ucylcclxuXHR9KVxyXG59KSIsIm1vZHVsZS5leHBvcnRzID0gKG9wdGlvbnMpID0+IHtcclxuICAgIGxldCByb290SWQgPSBvcHRpb25zLnJvb3RJZFxyXG4gICAgcmV0dXJuIChcclxuICAgIDxkaXY+XHJcblxyXG4gICAgICAgIDxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj5cclxuICAgICAgICAgICAge2AjJHtyb290SWR9XHJcbi5tYXNvbnJ5IHtcclxuICAgIC1tb3otY29sdW1uLWNvdW50OiAzO1xyXG4gICAgLXdlYmtpdC1jb2x1bW4tY291bnQ6IDM7XHJcbiAgICBjb2x1bW4tY291bnQ6IDM7XHJcbiAgICBjb2x1bW4tZ2FwOiAxZW07XHJcbn1cclxuLml0ZW0ge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcclxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuICAgIG1hcmdpbjogMCAwIDFlbTtcclxuICAgIFxyXG4gICAgcGFkZGluZzogMnB4O1xyXG4gICAgYm9yZGVyOiAxcHggYmxhY2sgc29saWQ7XHJcbiAgICB3aWR0aDogMTAwJTtcclxufVxyXG59XHJcbi5nby12YXJpYW50cy1leHRyYXMge1xyXG5kaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XHJcbn1gfVxyXG4gICAgICAgIDwvc3R5bGU+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIm1hc29ucnlcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIml0ZW0gZ28tdmFyaWFudHMtZXh0cmFzXCI+XHJcbiAgICAgICAgICAgICAgICBQYXN0ZSB0aGUgU0dGIGZvciBhIGdhbWUgb2YgdG9yb2lkYWwgR28sIChlLmcuIGZyb20gTGl0dGxlIEdvbGVtKSBpbiB0aGUgYm94LCBhbmQgdGhlbiBwdXNoIHRoZSBidXR0b24gdG8gdmlldyB0aGUgZ2FtZSFcclxuICAgICAgICAgICAgPGJyIC8+PGxhYmVsIGZvcj17YCR7cm9vdElkfV9zZ2ZJbmB9PlQtR28gU0dGOjwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8dGV4dGFyZWEgaWQ9e2Ake3Jvb3RJZH1fc2dmSW5gfSByb3dzPVwiM1wiPjwvdGV4dGFyZWE+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIGlkPXtgJHtyb290SWR9X2dvQnV0dG9uYH0gdmFsdWU9XCJzaG93IGJvYXJkIChmcm9tIHQtR28gU0dGKVwiIC8+XHJcblxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtIGdvLXZhcmlhbnRzLWV4dHJhc1wiPlxyXG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj17YCR7cm9vdElkfV9saXR0bGVHb2xlbUlkYH0+TGl0dGxlR29sZW0gZ2FtZSBJRDo8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IGlkPXtgJHtyb290SWR9X2xpdHRsZUdvbGVtSWRgfSB0eXBlPVwidGV4dFwiPjwvaW5wdXQ+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIGlkPXtgJHtyb290SWR9X2dvTGdCdXR0b25gfSB2YWx1ZT1cInNob3cgYm9hcmQgKGZyb20gbGl0dGxlR29sZW0gZ2FtZSBJRClcIiAvPjxzcGFuIGlkPXtgJHtyb290SWR9X2dvTGdNc2dgfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtIGdvLXZhcmlhbnRzLWV4dHJhc1wiPlxyXG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj17YCR7cm9vdElkfV9zaXplU2VsZWN0YH0+U2l6ZTo8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPHNlbGVjdCBpZD17YCR7cm9vdElkfV9zaXplU2VsZWN0YH0+XHJcbiAgICAgICAgICAgICAgICAgICAgey8qIG9wdGlvbnMgZmlsbGVkIGJ5IGVkaXRvci5qcyAqL31cclxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJidXR0b25cIiBpZD17YCR7cm9vdElkfV9uZXdCdXR0b25gfSB2YWx1ZT1cIk5ldyBnYW1lXCIgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBub25lXCIgaWQ9e2Ake3Jvb3RJZH1fdHJhbnNmb3JtZWRTZ2ZGc2B9IGNsYXNzPVwiaXRlbSBnby12YXJpYW50cy1leHRyYXNcIj5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9e2Ake3Jvb3RJZH1fc2dmT3V0YH0+VHJhbnNmb3JtZWQgU0dGOjwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8dGV4dGFyZWEgaWQ9e2Ake3Jvb3RJZH1fc2dmT3V0YH0gcm93cz1cIjNcIj48L3RleHRhcmVhPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBpZD17YCR7cm9vdElkfV92aWV3ZXJDb250cm9sc2B9IHN0eWxlPVwiZGlzcGxheTpub25lXCIgY2xhc3M9XCJpdGVtXCI+XHJcblxyXG4gICAgICAgICAgICAgICAgPHRhYmxlIHRpdGxlPVwicGFubmluZ1wiIHN0eWxlPVwiZmxvYXQ6bGVmdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49XCIyXCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXJcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCLihpFcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgcm93c3Bhbj1cIjRcIiBzdHlsZT1cInZlcnRpY2FsLWFsaWduOiBtaWRkbGVcIj7igJxQYW5uaW5n4oCdXHJcbiAgICAgICAgICAgICAgICA8cD4gVXNlIHRoZSBidXR0b25zIHRvIHRoZSBsZWZ0IHRvIOKAnHBhbuKAnSB0aGUgYm9hcmQuPC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwi4oaQXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cIuKGklwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVwiMlwiIHN0eWxlPVwidGV4dC1hbGlnbjogY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImJ1dHRvblwiIHZhbHVlPVwi4oaTXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIGNvbHNwYW49XCIyXCIgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7IGZvbnQtc2l6ZTogc21hbGxcIiBpZD17YCR7cm9vdElkfV9vZmZzZXRUcmB9ID5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhbm5lZDogWzAsMF1cclxuICAgICAgICAgICAgPC90ZD5cclxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpdGVtXCI+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPXtgJHtyb290SWR9X3dyYXBhcm91bmRTZWxlY3RgfT5udW1iZXIgb2Ygd3JhcGFyb3VuZCBsaW5lcyB0byBhZGQ6PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9e2Ake3Jvb3RJZH1fd3JhcGFyb3VuZFNlbGVjdGB9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwXCI+MDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCI+MTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIyXCI+Mjwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIzXCI+Mzwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI0XCIgc2VsZWN0ZWQ+NDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI1XCI+NTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI2XCI+Njwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCI3XCI+Nzwvb3B0aW9uPlxyXG5cclxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICAgICAgPGJyIC8+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVwiYWRkQ29tbWVudHNcIj5hZGQgY29tbWVudHM6PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBpZD17YCR7cm9vdElkfV9hZGRDb21tZW50c2B9IC8+XHJcbiAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9e2Ake3Jvb3RJZH1fd3JhcGFyb3VuZEJvcmRlclNlbGVjdGB9PlR5cGUgb2YgYm9yZGVyIGZvciB3cmFwYXJvdW5kOjwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgICA8c2VsZWN0IGlkPXtgJHtyb290SWR9X3dyYXBhcm91bmRCb3JkZXJTZWxlY3RgfT5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMFwiPk5vIGJvcmRlcjwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCIgc2VsZWN0ZWQ+RnVsbCBib3JkZXI8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMlwiPlBhcnRpYWwgYm9yZGVyIChjb3JuZXJzICZhbXA7IG1pZGRsZXMpPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjNcIj5KdXN0IGNvcm5lcnM8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiNFwiPkp1c3QgbWlkZGxlczwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgICAgICA8YnIgLz5cclxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9e2Ake3Jvb3RJZH1fY29vcmRpbmF0ZVNlbGVjdGB9PlR5cGUgb2YgY29vcmRpbmF0ZXM6PC9sYWJlbD5cclxuICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9e2Ake3Jvb3RJZH1fY29vcmRpbmF0ZVNlbGVjdGB9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIwXCIgc2VsZWN0ZWQ+Tm9uZTwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxXCI+KOKGkuKGkTtBfDEtS3wxMSk6IFdlc3Rlcm48L29wdGlvbj5cclxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMlwiPijihpLihpE7QXwxLUx8MTEpOiBXZXN0ZXJuLCBubyDigJxJ4oCdPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjNcIj4o4oaS4oaTOzF8MS0xMXwxMSk6IExhdGluL0xhdGluLCB0b3AgdG8gYm90dG9tPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjRcIj4o4oaS4oaTOzF8MS0xMXzljYHkuIApOiBMYXRpbi9DaGluZXNlLCB0b3AgdG8gYm90dG9tPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgPGRpdiBpZD17YCR7cm9vdElkfV91cGRhdGVCdXR0b25EaXZgfSBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwiYnV0dG9uXCIgaWQ9e2Ake3Jvb3RJZH1fdXBkYXRlQnV0dG9uYH0gdmFsdWU9XCJ1cGRhdGUgKGZyb20gYm9hcmQpXCIgLz4gUHJlc3MgdGhpcyBidXR0b24gYWZ0ZXIgYWRkaW5nIG1hcmtzIHRvIHRoZSBib2FyZCBwb3NpdGlvbiBpbiBvcmRlciB0byBnZXQgdGhlIHdyYXBhcm91bmQgZWZmZWN0LlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGlkPXtgJHtyb290SWR9X3BsYXllckRpdmB9IHN0eWxlPVwicG9zaXRpb246cmVsYXRpdmU7IGhlaWdodDogNzV2aDt3aWR0aDogODV2d1wiPjwvZGl2PlxyXG4gICAgPC9kaXY+KVxyXG59Il19"}